{
  "type": "object",
  "properties": {
    "mUpgradedSplitter": {
      "$ref": "#/definitions/AFGBuildableAttachmentSplitter",
      "description": "If we're upgrading another actor."
    },
    "mSnappedConnectionComponents": {
      "description": "Used when upgrading.",
      "type": "array",
      "items": {}
    },
    "mMaxValidTurnOffset": {
      "description": "Used to limit the placement in turns. What's the maximum offset to check from center to detect the curve.",
      "type": "number"
    },
    "mMaxValidTurnAngle": {
      "description": "Used to limit the placement in turns. What's the maximum angle.",
      "type": "number"
    },
    "mSnappedConveyor": {
      "$ref": "#/definitions/AFGBuildableConveyorBelt",
      "description": "The conveyor we snapped to."
    },
    "mSnappedConection": {
      "description": "The connection we snapped to."
    },
    "mClearanceMeshComponent": {
      "description": "Mesh component used to display the clearance mesh"
    },
    "mClearanceMesh": {
      "description": "Mesh we want to use in the component",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mClearanceMaterial": {
      "description": "Material to use on the clearance component"
    },
    "mMaxPlacementFloorAngle": {
      "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
      "type": "number"
    },
    "mLegs": {
      "$ref": "#/definitions/UFGFactoryLegsComponent"
    },
    "mClearanceBox": {
      "description": "Component to check build clearance to other buildings."
    },
    "mSnappedBuilding": {
      "$ref": "#/definitions/AFGBuildable",
      "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
    },
    "mValidHitClasses": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "package": {
            "type": "string"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "package"
        ]
      }
    },
    "mRecipe": {
      "description": "The recipe for this hologram.",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mLoopSound": {
      "description": "Looping sound to play on holograms"
    },
    "mClearanceDetector": {
      "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
    },
    "mPlacementMaterial": {
      "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
      "type": "boolean"
    },
    "mValidPlacementMaterial": {
      "description": "Material on hologram for valid placement."
    },
    "mInvalidPlacementMaterial": {
      "description": "Material on hologram for invalid placement."
    },
    "mChildren": {
      "type": "array",
      "items": {
        "$ref": "#/definitions/AFGHologram"
      }
    },
    "mBuildClass": {
      "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mUseBuildClearanceOverlapSnapp": {
      "type": "boolean"
    },
    "mConstructionInstigator": {
      "description": "Who is building"
    },
    "mIsDisabled": {
      "description": "If this hologram is disabled and should not be visible or constructed.",
      "type": "boolean"
    },
    "mIsChanged": {
      "description": "If the hologram has changed, i.e. multi step placement or rotation.",
      "type": "boolean"
    },
    "mInitialScrollModeValue": {
      "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
      "type": "number"
    },
    "mConstructionPosition": {
      "$ref": "#/definitions/Vector",
      "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
    },
    "mConstructionRotation": {
      "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
    }
  },
  "required": [
    "mBuildClass",
    "mChildren",
    "mClearanceBox",
    "mClearanceDetector",
    "mClearanceMaterial",
    "mClearanceMesh",
    "mClearanceMeshComponent",
    "mConstructionInstigator",
    "mConstructionPosition",
    "mConstructionRotation",
    "mInitialScrollModeValue",
    "mInvalidPlacementMaterial",
    "mIsChanged",
    "mIsDisabled",
    "mLegs",
    "mLoopSound",
    "mMaxPlacementFloorAngle",
    "mMaxValidTurnAngle",
    "mMaxValidTurnOffset",
    "mPlacementMaterial",
    "mRecipe",
    "mSnappedBuilding",
    "mSnappedConection",
    "mSnappedConnectionComponents",
    "mSnappedConveyor",
    "mUpgradedSplitter",
    "mUseBuildClearanceOverlapSnapp",
    "mValidHitClasses",
    "mValidPlacementMaterial"
  ],
  "definitions": {
    "UFGActorRepresentation": {
      "type": "object",
      "properties": {
        "mRealActor": {
          "$ref": "#/definitions/AActor",
          "description": "This is the real actor that this representation represents"
        },
        "mActorLocation": {
          "description": "This is the actor location"
        },
        "mActorRotation": {
          "description": "This is the actor rotation"
        },
        "mIsStatic": {
          "description": "If the actor is static or can be moved",
          "type": "boolean"
        },
        "mRepresentationTexture": {
          "description": "This is the texture to show for this actor representation",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRepresentationText": {
          "description": "This is the text to show for this actor representation",
          "type": "string"
        },
        "mRepresentationColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "This is the color used for the representation of this actor"
        },
        "mRepresentationType": {
          "$ref": "#/definitions/ERepresentationType",
          "description": "This helps define how this actor representation should be presented"
        },
        "mFogOfWarRevealType": {
          "$ref": "#/definitions/EFogOfWarRevealType"
        },
        "mFogOfWarRevealRadius": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mShouldShowInCompass": {
          "description": "If this should be shown in the compass or not",
          "type": "boolean"
        },
        "mShouldShowOnMap": {
          "description": "If this should be shown on the map or not",
          "type": "boolean"
        },
        "mCompassViewDistance": {
          "$ref": "#/definitions/ECompassViewDistance",
          "description": "How far away this representation should be shown in the compass"
        }
      },
      "required": [
        "mActorLocation",
        "mActorRotation",
        "mCompassViewDistance",
        "mFogOfWarRevealRadius",
        "mFogOfWarRevealType",
        "mIsStatic",
        "mRealActor",
        "mRepresentationColor",
        "mRepresentationText",
        "mRepresentationTexture",
        "mRepresentationType",
        "mShouldShowInCompass",
        "mShouldShowOnMap"
      ]
    },
    "AActor": {
      "description": "Actor is the base class for an Object that can be placed or spawned in a level.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor/index.html",
      "type": "object"
    },
    "LinearColor": {
      "description": "A linear, 32-bit/component floating point RGBA color.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FLinearColor/index.html",
      "type": "object",
      "properties": {
        "R": {
          "description": "The color's red intensity.",
          "type": "number"
        },
        "G": {
          "description": "The color's green intensity.",
          "type": "number"
        },
        "B": {
          "description": "The color's blue intensity.",
          "type": "number"
        },
        "A": {
          "description": "The color's opacity.",
          "type": "number"
        }
      },
      "required": [
        "A",
        "B",
        "G",
        "R"
      ]
    },
    "ERepresentationType": {
      "enum": [
        0,
        1,
        10,
        11,
        12,
        13,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "EFogOfWarRevealType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "ECompassViewDistance": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "UFGSoundSplineComponent": {
      "type": "object",
      "properties": {
        "mEmitterInterval": {
          "description": "Distance beween each emitter on our parent spline, this might be scaled slightly so that we get a point on both start and end",
          "type": "number"
        }
      },
      "required": [
        "mEmitterInterval"
      ]
    },
    "FExponentialFogSettings": {
      "type": "object",
      "properties": {
        "FogHeight": {
          "description": "The ZValue of the fog",
          "type": "number"
        },
        "FogDensity": {
          "description": "Density of the fog",
          "type": "number"
        },
        "FogInscatteringColor": {
          "$ref": "#/definitions/LinearColor"
        },
        "FullyDirectionalInscatteringColorDistance": {
          "description": "Distance at which InscatteringColorCubemap should be used directly for the Inscattering Color.",
          "type": "number"
        },
        "NonDirectionalInscatteringColorDistance": {
          "description": "Distance at which only the average color of InscatteringColorCubemap should be used as Inscattering Color.",
          "type": "number"
        },
        "DirectionalInscatteringExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DirectionalInscatteringStartDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DirectionalInscatteringColor": {
          "$ref": "#/definitions/LinearColor"
        },
        "FogHeightFalloff": {
          "description": "A floating point number.",
          "type": "number"
        },
        "FogMaxOpacity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "StartDistance": {
          "description": "Distance from the camera that the fog will start, in world units.",
          "type": "number"
        },
        "FogCutoffDistance": {
          "description": "Scene elements past this distance will not have fog applied.  This is useful for excluding skyboxes which already have fog baked in.",
          "type": "number"
        }
      },
      "required": [
        "DirectionalInscatteringColor",
        "DirectionalInscatteringExponent",
        "DirectionalInscatteringStartDistance",
        "FogCutoffDistance",
        "FogDensity",
        "FogHeight",
        "FogHeightFalloff",
        "FogInscatteringColor",
        "FogMaxOpacity",
        "FullyDirectionalInscatteringColorDistance",
        "NonDirectionalInscatteringColorDistance",
        "StartDistance"
      ]
    },
    "AFGBuildableAttachmentSplitter": {
      "type": "object",
      "properties": {
        "mCurrentOutputIndex": {
          "description": "Cycles through the outputs, stores the output we want to put mItem on. Index is for the mOutputs array.",
          "type": "number"
        },
        "mCurrentInventoryIndex": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mDistributionTable": {
          "description": "Table of all items in the inventory mapped to a desired output. The array is filled from a call to FillDistributionTable which runs in factory tick",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FConnectionItemStruct"
          }
        },
        "mConveyorSpaceData": {
          "$ref": "#/definitions/Map<any,FConveyorSpaceData>",
          "description": "Store last cached available space and if an item have been grabbed by the connected components"
        },
        "mBufferInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBufferInventory",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mConveyorSpaceData",
        "mCurrentInventoryIndex",
        "mCurrentOutputIndex",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDistributionTable",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "FConnectionItemStruct": {
      "type": "object",
      "properties": {
        "Connection": {
          "description": "The connection to put the item on"
        },
        "Item": {
          "$ref": "#/definitions/FInventoryItem",
          "description": "The item to put on the connection"
        }
      },
      "required": [
        "Connection",
        "Item"
      ]
    },
    "FInventoryItem": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "The type of item",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ItemState": {
          "$ref": "#/definitions/FSharedInventoryStatePtr",
          "description": "Optionally store an actor, e.g. an equipment, so we can remember it's state."
        }
      },
      "required": [
        "ItemClass",
        "ItemState"
      ]
    },
    "FSharedInventoryStatePtr": {
      "type": "object",
      "properties": {
        "ActorPtr": {
          "$ref": "#/definitions/AActor",
          "description": "The actor we've shared ownership over."
        }
      },
      "required": [
        "ActorPtr"
      ]
    },
    "Map<any,FConveyorSpaceData>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGInventoryComponent": {
      "type": "object",
      "properties": {
        "ResizeInventoryDelegate": {
          "description": "Called when this inventory has been resized"
        },
        "OnItemAddedDelegate": {
          "description": "Called when this inventory has something added to it, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "OnItemRemovedDelegate": {
          "description": "Called when something has been removed from the inventory, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "mDefaultInventorySize": {
          "description": "When we make an inventory by adding the component to an actor we use this to specify its size",
          "type": "number"
        },
        "mAdjustedSizeDiff": {
          "description": "When we resize the inventory we save how much bigger or smaller the inventory was made",
          "type": "number"
        },
        "mInventoryStacks": {
          "description": "All items in the inventory",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mArbitrarySlotSizes": {
          "description": "In some rare cases we don't want to use the StackSize to limit the slot, so this way we can have larger or smaller slots",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mAllowedItemDescriptors": {
          "description": "This are the allowed inventory items, this we we can \"filter\" in BluePrint as well.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCanBeRearrange": {
          "description": "Can stuff in this inventory be rearranged, that is moved from one slot to the other?",
          "type": "boolean"
        }
      },
      "required": [
        "OnItemAddedDelegate",
        "OnItemRemovedDelegate",
        "ResizeInventoryDelegate",
        "mAdjustedSizeDiff",
        "mAllowedItemDescriptors",
        "mArbitrarySlotSizes",
        "mCanBeRearrange",
        "mDefaultInventorySize",
        "mInventoryStacks"
      ]
    },
    "FInventoryStack": {
      "type": "object",
      "properties": {
        "Item": {
          "$ref": "#/definitions/FInventoryItem",
          "description": "Type of item in this stack."
        },
        "NumItems": {
          "description": "Number of items in this stack.",
          "type": "number"
        }
      },
      "required": [
        "Item",
        "NumItems"
      ]
    },
    "UFGPowerInfoComponent": {
      "type": "object",
      "properties": {
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mTargetConsumption": {
          "description": "Power to draw from the circuit.",
          "type": "number"
        },
        "mActualConsumption": {
          "description": "The actual power we got from the circuit (updated each frame).",
          "type": "number"
        },
        "mBaseProduction": {
          "description": "Power to always provide to the circuit.",
          "type": "number"
        },
        "mDynamicProductionCapacity": {
          "description": "Power to optionally provide to the circuit.",
          "type": "number"
        },
        "mDynamicProductionDemandFactor": {
          "description": "The demand for dynamic power (updated each frame).",
          "type": "number"
        },
        "mIsFuseTriggered": {
          "description": "true if the circuit is overloaded and the fuse has been triggered.",
          "type": "number"
        }
      },
      "required": [
        "mActualConsumption",
        "mBaseProduction",
        "mCircuitID",
        "mDynamicProductionCapacity",
        "mDynamicProductionDemandFactor",
        "mIsFuseTriggered",
        "mTargetConsumption"
      ]
    },
    "EStackSize": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "type": "number"
    },
    "AFGReplicationDetailActor": {
      "type": "object",
      "properties": {
        "mOwningBuildable": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "Owning AFGBuildable to this replication detail actor object. Should never be null."
        }
      },
      "required": [
        "mOwningBuildable"
      ]
    },
    "AFGBuildable": {
      "type": "object",
      "properties": {
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect"
      ]
    },
    "Vector": {
      "description": "A vector in 3-D space composed of components (X, Y, Z) with floating point precision.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FVector/index.html",
      "type": "object",
      "properties": {
        "X": {
          "description": "The vector's X component.",
          "type": "number"
        },
        "Y": {
          "description": "The vector's Y component.",
          "type": "number"
        },
        "Z": {
          "description": "The vector's Z component.",
          "type": "number"
        }
      },
      "required": [
        "X",
        "Y",
        "Z"
      ]
    },
    "FFactoryTickFunction": {
      "type": "object"
    },
    "Map<string,UFGFactoryMaterialInstanceManager>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "AFGCharacterPlayer": {
      "type": "object",
      "properties": {
        "mBaseTurnRate": {
          "description": "Base turn rate, in deg/sec. Other scaling may affect final turn rate.",
          "type": "number"
        },
        "mBaseLookUpRate": {
          "description": "Base look up/down rate, in deg/sec. Other scaling may affect final rate.",
          "type": "number"
        },
        "mMesh1PAnimClass": {
          "description": "The default arms animation when we're idle.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh3P": {
          "description": "Pawn mesh: 3rd person view"
        },
        "mFoliagePickupProxyClass": {
          "description": "As we have no foliage actor to actually put pickup code in, we use this actor as a proxy",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFoliagePickupProxy": {
          "$ref": "#/definitions/AFGFoliagePickup",
          "description": "Actor that's used when trying to pickup foliage"
        },
        "mBuildGun": {
          "$ref": "#/definitions/AFGBuildGun",
          "description": "This is the infamous build gun."
        },
        "mResourceScanner": {
          "$ref": "#/definitions/AFGResourceScanner",
          "description": "Reference to the resource scanner"
        },
        "mResourceMiner": {
          "$ref": "#/definitions/AFGResourceMiner",
          "description": "Reference to the resource miner"
        },
        "mBestUsableActor": {
          "$ref": "#/definitions/AActor",
          "description": "The best usable actor nearby."
        },
        "mCachedUseState": {
          "$ref": "#/definitions/FUseState",
          "description": "Of the usable actor we are looking at, UPROPERTY to prevent the AdditionalData to be garbage collected"
        },
        "mAnimInstanceClass": {
          "description": "Anim instance class to use in third person",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAnimInstanceClass1P": {
          "description": "Anim instance class to use in first person",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mReviveDuration": {
          "description": "time (in seconds) it takes to revive a fellow player",
          "type": "number"
        },
        "mStartingResources": {
          "description": "The starting resources for the player",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mStartingResourceForTesting": {
          "description": "The starting resources for the player if we are NOT in shipping",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mDrownDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDrownDamage": {
          "description": "The amount of damage to receive when drowning.",
          "type": "number"
        },
        "mDrownDamageInterval": {
          "description": "Time between each application of drowning damage (in seconds)",
          "type": "number"
        },
        "mPlayerToRevive": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player that we are reviving"
        },
        "mPickupToCollect": {
          "$ref": "#/definitions/AFGItemPickup",
          "description": "The pickup we are collecting"
        },
        "m1PDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in m1PFootstepEffect"
        },
        "m1PFootstepEffect": {
          "description": "Effects to play when a foot hits the ground in first person",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "m1PFootstepEvent": {
          "description": "Effects to play when a foot hits the ground in first person",
          "type": "array",
          "items": {}
        },
        "mLastSafeGroundPositions": {
          "$ref": "#/definitions/Vector",
          "description": "latest safe ground location positions"
        },
        "mLastSafeGroundPositionLoopHead": {
          "description": "used for knowing which is the latest written safe ground position",
          "type": "number"
        },
        "mCameraComponent": {
          "description": "Player camera"
        },
        "mSpringArmComponent": {
          "description": "Spring arm for camera"
        },
        "mActiveEquipments": {
          "description": "This is the equipment we hold in our hands.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipment"
          }
        },
        "mClientActiveEquipments": {
          "description": "Simulated on the client so they know what to unequip.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipment"
          }
        },
        "mAllAttachments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipmentAttachment"
          }
        },
        "mActiveAttachments": {
          "description": "Remote client representation of the equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipmentAttachment"
          }
        },
        "mCurrentCameraMode": {
          "$ref": "#/definitions/ECameraMode",
          "description": "Current camera mode for the character"
        },
        "mPlayerPreferredCameraMode": {
          "$ref": "#/definitions/ECameraMode",
          "description": "What camera mode were we in before we opened the"
        },
        "mInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The players inventory."
        },
        "mAllowedResourceFormsInInventory": {
          "description": "The resource forms that are allowed in players inventory.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/EResourceForm"
          }
        },
        "mBeltSlot": {
          "$ref": "#/definitions/UFGInventoryComponentBeltSlot",
          "description": "The belt slot inventory."
        },
        "mTrashSlot": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The players inventory."
        },
        "mAllowCameraToggling": {
          "description": "Allow toggling of camera modes",
          "type": "boolean"
        },
        "mUseDistance": {
          "description": "Maximum distance we use objects on",
          "type": "number"
        },
        "mPickupCounter": {
          "description": "Counter used for replicating to remote clients when something is picked up",
          "type": "number"
        },
        "mReviver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player that is reviving me"
        },
        "mDefaultWalkHeadBobShake": {
          "description": "Reference to the default walk head bob shake",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultSprintHeadBobShake": {
          "description": "Reference to the default sprint head bob shake",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDrivenVehicle": {
          "$ref": "#/definitions/AFGDriveablePawn",
          "description": "Vehicle currently driven by pawn."
        },
        "mSavedDrivenVehicle": {
          "$ref": "#/definitions/AFGDriveablePawn"
        },
        "mOutlineComponent": {
          "$ref": "#/definitions/UFGOutlineComponent"
        },
        "mHealthGenerationThreshold": {
          "description": "Health Generation",
          "type": "number"
        },
        "mHealthGenerationAmount": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHealthGenerationInterval": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHealthGenerationWaitTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mRadiationIntensity": {
          "description": "The accumulated normalized radiation intensity of the players current location",
          "type": "number"
        },
        "mRadiationDamageAngle": {
          "description": "The angle from the players view to the accumulated radiation damage",
          "type": "number"
        },
        "mRadiationImmunity": {
          "description": "How much immunity do we have for radiation",
          "type": "number"
        },
        "mInRadioactiveZone": {
          "description": "Are we in a radioactive zone",
          "type": "boolean"
        },
        "mCameraOffsetBlendSpeed": {
          "description": "How fast the blend is",
          "type": "number"
        },
        "mReplicatedIsSliding": {
          "description": "Replicated value of sliding status. Used to let non owning player know whats happening",
          "type": "boolean"
        },
        "mCrouchSpeed": {
          "description": "How fast the blend is for crouch and slide",
          "type": "number"
        },
        "mStandSpeed": {
          "description": "How fast the blend is from crouch/slide to stand",
          "type": "number"
        },
        "mSlideToCrouchSpeed": {
          "description": "How fast the blend is from slide to crouch",
          "type": "number"
        },
        "mNoUpdate": {
          "type": "boolean"
        },
        "mFeetNames": {
          "description": "When receiving FootDown on index 2, then we will trace from mFeetNames[2] socket for ground",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in mFootstepEffects"
        },
        "mFootstepEffect": {
          "description": "Effects to play when a foot hits the ground",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "mFootstepAudioEvents": {
          "description": "Audio event to play (where index in array is the feet index passed from AnimNotify_FootDown)",
          "type": "array",
          "items": {}
        },
        "mMaxFootstepParticleSpawnDistance": {
          "description": "Maximum distance we want to play footstep particles at",
          "type": "number"
        },
        "mMaxFootstepDecalSpawnDistance": {
          "description": "Maximum distance we want to spawn footsteps decals at",
          "type": "number"
        },
        "mFootstepDecalSize": {
          "description": "Size of footstep decals",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mFootstepDecalLifetime": {
          "description": "Lifetime of footstep decals",
          "type": "number"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mFallDamageCurve": {
          "description": "How much damage to take falling with a given velocity"
        },
        "mFallDamageCurveOverride": {
          "description": "Overrides the default fall damage curve, utilized by Equipment"
        },
        "mFallDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxDeathStayTime": {
          "description": "The maximum time after death (in seconds) the pawn will stay in the world, so it will be removed even if it's in sight after this time",
          "type": "number"
        },
        "mDeathRemoveCheckTime": {
          "description": "How often will we check if the pawn is in sight of any player",
          "type": "number"
        },
        "mEnemyTargetDesirability": {
          "description": "Multiplier for targeting desirability",
          "type": "number"
        },
        "mTakeDamageSound": {
          "description": "Sound played when pawn takes damage"
        },
        "mDeathSound": {
          "description": "Sound played when pawn dies"
        },
        "mLandEvent": {
          "description": "Event posted when landing"
        },
        "mTakeDamageParticle": {
          "description": "Particle for when pawn takes damage"
        },
        "mMinVehiclePushVelocityForRagdoll": {
          "description": "Min push velocity required to start ragdoll",
          "type": "number"
        },
        "mTimeToGetUpFromRagdoll": {
          "description": "time in seconds until character gets up from ragdoll if alive",
          "type": "number"
        },
        "mMaxDistanceMovedToGetUp": {
          "description": "the furthest distance we can move during ragdoll before we are considered still enough to stand up from ragdoll",
          "type": "number"
        },
        "mIsRagdolled": {
          "description": "true if ragdolled",
          "type": "boolean"
        },
        "mRagdollMeshLoc": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshVelocity": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshLocBoneName": {
          "description": "Name of the bone we take mesh location from",
          "type": "string"
        },
        "mRagdollMeshPhysicsBoneName": {
          "description": "Name of the bone we take physics velocity from",
          "type": "string"
        },
        "mSyncBodyMaxDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mApplyDamageMomentum": {
          "description": "Should the auto momentum be applied when taking damage?",
          "type": "boolean"
        },
        "mIgnoredDamageTypes": {
          "description": "Damage types that this character is immune to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mWeakspotMultiplier": {
          "description": "How much more damage should be dealt when taking a weakspot hit",
          "type": "number"
        },
        "mWeakspotBoneNames": {
          "description": "Bone names that result in a weakspot hit",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mNormalDamageMultiplier": {
          "description": "Multiplier for this creature and normal damage taken",
          "type": "number"
        },
        "mIsPossessed": {
          "description": "Used to let client know when a pawn gets possessed/unpossessed",
          "type": "boolean"
        }
      },
      "required": [
        "m1PDefaultFootstepEffect",
        "m1PFootstepEffect",
        "m1PFootstepEvent",
        "mActiveAttachments",
        "mActiveEquipments",
        "mAllAttachments",
        "mAllowCameraToggling",
        "mAllowedResourceFormsInInventory",
        "mAnimInstanceClass",
        "mAnimInstanceClass1P",
        "mApplyDamageMomentum",
        "mBaseLookUpRate",
        "mBaseTurnRate",
        "mBeltSlot",
        "mBestUsableActor",
        "mBuildGun",
        "mCachedUseState",
        "mCameraComponent",
        "mCameraOffsetBlendSpeed",
        "mClientActiveEquipments",
        "mCrouchSpeed",
        "mCurrentCameraMode",
        "mDeathRemoveCheckTime",
        "mDeathSound",
        "mDefaultFootstepEffect",
        "mDefaultSprintHeadBobShake",
        "mDefaultWalkHeadBobShake",
        "mDrivenVehicle",
        "mDrownDamage",
        "mDrownDamageDamageType",
        "mDrownDamageInterval",
        "mEnemyTargetDesirability",
        "mFallDamageCurve",
        "mFallDamageCurveOverride",
        "mFallDamageDamageType",
        "mFeetNames",
        "mFoliagePickupProxy",
        "mFoliagePickupProxyClass",
        "mFootstepAudioEvents",
        "mFootstepDecalLifetime",
        "mFootstepDecalSize",
        "mFootstepEffect",
        "mHealthComponent",
        "mHealthGenerationAmount",
        "mHealthGenerationInterval",
        "mHealthGenerationThreshold",
        "mHealthGenerationWaitTime",
        "mIgnoredDamageTypes",
        "mInRadioactiveZone",
        "mInventory",
        "mIsPossessed",
        "mIsRagdolled",
        "mLandEvent",
        "mLastSafeGroundPositionLoopHead",
        "mLastSafeGroundPositions",
        "mMaxDeathStayTime",
        "mMaxDistanceMovedToGetUp",
        "mMaxFootstepDecalSpawnDistance",
        "mMaxFootstepParticleSpawnDistance",
        "mMesh1PAnimClass",
        "mMesh3P",
        "mMinVehiclePushVelocityForRagdoll",
        "mNoUpdate",
        "mNormalDamageMultiplier",
        "mOutlineComponent",
        "mPickupCounter",
        "mPickupToCollect",
        "mPlayerPreferredCameraMode",
        "mPlayerToRevive",
        "mRadiationDamageAngle",
        "mRadiationImmunity",
        "mRadiationIntensity",
        "mRagdollMeshLoc",
        "mRagdollMeshLocBoneName",
        "mRagdollMeshPhysicsBoneName",
        "mRagdollMeshVelocity",
        "mReplicatedIsSliding",
        "mResourceMiner",
        "mResourceScanner",
        "mReviveDuration",
        "mReviver",
        "mSavedDrivenVehicle",
        "mSlideToCrouchSpeed",
        "mSpringArmComponent",
        "mStandSpeed",
        "mStartingResourceForTesting",
        "mStartingResources",
        "mSyncBodyMaxDistance",
        "mTakeDamageParticle",
        "mTakeDamageSound",
        "mTimeToGetUpFromRagdoll",
        "mTrashSlot",
        "mUseDistance",
        "mWeakspotBoneNames",
        "mWeakspotMultiplier"
      ]
    },
    "AFGFoliagePickup": {
      "type": "object",
      "properties": {
        "mPickupMesh": {
          "description": "The mesh that should be outlining",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "mPickupMesh"
      ]
    },
    "AFGBuildGun": {
      "type": "object",
      "properties": {
        "mOnStateChanged": {
          "description": "Called when the build gun state changes."
        },
        "mOnRecipeChanged": {
          "description": "Called when the build gun build state receives a new recipe. This May be called prior to OnStateChanged."
        },
        "mBuildDistanceMax": {
          "description": "Trace distance for this build gun when building and dismantling.",
          "type": "number"
        },
        "mMenuStateClass": {
          "description": "The state to use when operating the menus.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildStateClass": {
          "description": "The state to use when building.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleStateClass": {
          "description": "The state to use when dismantling.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStates": {
          "$ref": "#/definitions/UFGBuildGunState",
          "description": "All the states."
        },
        "mHitResult": {
          "description": "Result of the latest trace."
        },
        "mCurrentStateEnum": {
          "$ref": "#/definitions/EBuildGunState"
        },
        "mCurrentState": {
          "$ref": "#/definitions/UFGBuildGunState"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mBuildDistanceMax",
        "mBuildStateClass",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mCurrentState",
        "mCurrentStateEnum",
        "mDismantleStateClass",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHitResult",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mMenuStateClass",
        "mOnRecipeChanged",
        "mOnStateChanged",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mStates",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "UFGBuildGunState": {
      "type": "object",
      "properties": {
        "mActionDelay": {
          "description": "Time (in seconds) it takes for the action (eg. Build, dismantle)",
          "type": "number"
        },
        "mActionMessage": {
          "description": "Text to show while action is in progress",
          "type": "string"
        }
      },
      "required": [
        "mActionDelay",
        "mActionMessage"
      ]
    },
    "EBuildGunState": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "EEquipmentSlot": {
      "description": "Equipments are equip on different slots on the player. One EQ per slot. These are the slots.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "AFGEquipmentChild": {
      "type": "object",
      "properties": {
        "mParentEquipment": {
          "$ref": "#/definitions/AFGEquipment",
          "description": "stores a reference to the FGEquipment that spawned this class"
        },
        "mAttachSocket": {
          "description": "The socket to attach any child equipment to",
          "type": "string"
        }
      },
      "required": [
        "mAttachSocket",
        "mParentEquipment"
      ]
    },
    "AFGEquipment": {
      "type": "object",
      "properties": {
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FItemAmount": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "The item.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Amount": {
          "description": "The amount of this item.",
          "type": "number"
        }
      },
      "required": [
        "Amount",
        "ItemClass"
      ]
    },
    "EArmEquipment": {
      "enum": [
        0,
        1,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "EBackEquipment": {
      "enum": [
        0,
        1
      ],
      "type": "number"
    },
    "AFGEquipmentAttachment": {
      "type": "object",
      "properties": {
        "mEquipmentClass": {
          "description": "The class of the equipment that spawned this attachment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseLocation": {
          "$ref": "#/definitions/Vector",
          "description": "This value get replicated to clients so they can play effect"
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mAttachedTo": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The character this is attached to."
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this attachment attached"
        },
        "mAnimationState": {
          "description": "integer used for animation states",
          "type": "number"
        }
      },
      "required": [
        "mAnimationState",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachedTo",
        "mBackAnimation",
        "mEquipmentClass",
        "mEquipmentSlot",
        "mUseLocation"
      ]
    },
    "AFGResourceScanner": {
      "type": "object",
      "properties": {
        "mResourceDescriptorToScanFor": {
          "description": "This is the resource class to scan for",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mNrOfClosestClustersToMark": {
          "description": "How many node clusters should be marked",
          "type": "number"
        },
        "mLastPressedTimeStamp": {
          "description": "Keeps track of the last time we pressed Scan",
          "type": "number"
        },
        "mHoldDownDurationForUI": {
          "description": "Time needed to hold down the key to show the selection UI",
          "type": "number"
        },
        "mIsPressingScan": {
          "description": "True in between OnScanPressed and OnScanReleased",
          "type": "boolean"
        },
        "mIsWaitingForSelectionUI": {
          "description": "True if we are waiting for the selection UI",
          "type": "boolean"
        },
        "mDistBetweenNodesInCluster": {
          "description": "If nodes are closer that dist they are considered within the cluster",
          "type": "number"
        },
        "mNodeClusters": {
          "description": "A list of all the clusters of nodes non the level",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FNodeClusterData"
          }
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mDistBetweenNodesInCluster",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHoldDownDurationForUI",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mIsPressingScan",
        "mIsWaitingForSelectionUI",
        "mLastPressedTimeStamp",
        "mNodeClusters",
        "mNrOfClosestClustersToMark",
        "mResourceDescriptorToScanFor",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FNodeClusterData": {
      "description": "Holds information about resource node clusters. This could be saved in actors on the level for optimization.",
      "type": "object",
      "properties": {
        "Nodes": {
          "description": "Cost of schematic if there are more than once item in this array the true cost will be randomly selected.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGResourceNode"
          }
        },
        "MidPoint": {
          "$ref": "#/definitions/Vector",
          "description": "The average location of all the nodes"
        },
        "ResourceDescriptor": {
          "description": "The resource descriptor of this cluster",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "MidPoint",
        "Nodes",
        "ResourceDescriptor"
      ]
    },
    "AFGResourceNode": {
      "type": "object",
      "properties": {
        "mResourceClass": {
          "description": "Type of resource",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPurity": {
          "$ref": "#/definitions/EResourcePurity",
          "description": "How pure the resource is"
        },
        "mAmount": {
          "$ref": "#/definitions/EResourceAmount",
          "description": "How pure the resource is"
        },
        "mDecalComponent": {
          "description": "the decal that used for displaying the resource"
        },
        "mBoxComponent": {
          "description": "If we have no static mesh but a decal, then we use this for collision"
        },
        "mResourcesLeft": {
          "description": "How much resources is left in this node",
          "type": "number"
        },
        "mIsOccupied": {
          "description": "If true, then we are occupied by something // [Dylan 3/2/2020] - Removed savegame meta",
          "type": "boolean"
        },
        "mRevealedOnMapBy": {
          "description": "Radar tower modifies this to show this resource node in the map",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UObject"
          }
        },
        "mIsLonerNode": {
          "description": "If true, this node will NEVER join another cluster of nodes, regardless of proximity.",
          "type": "boolean"
        },
        "mCanPlaceResourceExtractor": {
          "description": "Can this resource node be used for placing resource extractors on",
          "type": "boolean"
        },
        "mExtractMultiplier": {
          "description": "Multiplier that is applied in the end of extraction calculations. Is used for making deposits extract more than regular nodes",
          "type": "number"
        },
        "mPurityTextArray": {
          "description": "Text mapped to resource purity",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPurityTextPair"
          }
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDoSpawnParticle": {
          "description": "Bool for is we should spawn particle - @todo Do we really need to save this? //[Dylan 3/2/2020]",
          "type": "boolean"
        }
      },
      "required": [
        "mAmount",
        "mBoxComponent",
        "mCanPlaceResourceExtractor",
        "mDecalComponent",
        "mDoSpawnParticle",
        "mExtractMultiplier",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mIsLonerNode",
        "mIsOccupied",
        "mPurity",
        "mPurityTextArray",
        "mResourceClass",
        "mResourcesLeft",
        "mRevealedOnMapBy"
      ]
    },
    "EResourcePurity": {
      "description": "How how fast it is to mine the resource",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "EResourceAmount": {
      "description": "How much resources this node contains, a rich vein will deplete later",
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "UObject": {
      "description": "The base class of all UE4 objects.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UObject/index.html",
      "type": "object"
    },
    "FPurityTextPair": {
      "type": "object",
      "properties": {
        "Text": {
          "description": "Localizable text",
          "type": "string"
        },
        "Purity": {
          "$ref": "#/definitions/EResourcePurity",
          "description": "Enum to localize"
        }
      },
      "required": [
        "Purity",
        "Text"
      ]
    },
    "AFGResourceMiner": {
      "type": "object",
      "properties": {
        "mPickParticleSystem": {
          "description": "The effect the spawn when picking."
        },
        "mPickArmsAnim": {
          "description": "Animation to play when picking."
        },
        "mCachedResouceNode": {
          "$ref": "#/definitions/AFGResourceNode",
          "description": "The node we want to pick from"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mCachedResouceNode",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mPickArmsAnim",
        "mPickParticleSystem",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FUseState": {
      "type": "object",
      "properties": {
        "AdditionalData": {
          "$ref": "#/definitions/UFGUseState",
          "description": "Additional data that might be heavy to calculate several times the same frame, the reason it's cached here and not in the object, is that several players might want to cache different things"
        },
        "UseLocation": {
          "$ref": "#/definitions/Vector",
          "description": "Location of where the use happens"
        },
        "UseComponent": {
          "description": "Component that triggered the use"
        },
        "State": {
          "description": "Contains the usable state of the object, might be a error code",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "AdditionalData",
        "State",
        "UseComponent",
        "UseLocation"
      ]
    },
    "UFGUseState": {
      "type": "object",
      "properties": {
        "mWantAdditonalData": {
          "description": "If true, we will allocate a instance of the state, so we can store information in the state",
          "type": "boolean"
        },
        "mIsUsableState": {
          "description": "If true, we will allocate a instance of the state, so we can store information in the state",
          "type": "boolean"
        }
      },
      "required": [
        "mIsUsableState",
        "mWantAdditonalData"
      ]
    },
    "AFGItemPickup": {
      "type": "object",
      "properties": {
        "mTimeToPickUp": {
          "description": "The amount of time required to pickup < 0 == instant",
          "type": "number"
        },
        "mCollector": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player collecting the item"
        },
        "mCollectingTimerHandle": {
          "description": "Timer handler for item being picked up"
        },
        "mPickupItems": {
          "$ref": "#/definitions/FInventoryStack",
          "description": "The items we want to be able to pickup"
        },
        "mDestroyOnPickup": {
          "description": "If set to true, then we destroy the item when it's pickup:ed",
          "type": "boolean"
        },
        "mSoundComponent": {
          "description": "ak component that plays sound"
        },
        "mAudioEvent": {
          "description": "The ak event to post for the sound"
        }
      },
      "required": [
        "mAudioEvent",
        "mCollectingTimerHandle",
        "mCollector",
        "mDestroyOnPickup",
        "mPickupItems",
        "mSoundComponent",
        "mTimeToPickUp"
      ]
    },
    "FFootstepEffect": {
      "type": "object",
      "properties": {
        "Particle": {
          "description": "The particle to use when hitting the ground"
        },
        "GroundDecals": {
          "description": "The decal to place on the ground when walking around",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "GroundDecals",
        "Particle"
      ]
    },
    "FFootstepEffectSurface": {
      "type": "object",
      "properties": {
        "Surface": {
          "description": "The surface the foot hit"
        },
        "Effect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "The effect we want to play when hitting the surface"
        }
      },
      "required": [
        "Effect",
        "Surface"
      ]
    },
    "ECameraMode": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "EResourceForm": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "UFGInventoryComponentBeltSlot": {
      "type": "object",
      "properties": {
        "ResizeInventoryDelegate": {
          "description": "Called when this inventory has been resized"
        },
        "OnItemAddedDelegate": {
          "description": "Called when this inventory has something added to it, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "OnItemRemovedDelegate": {
          "description": "Called when something has been removed from the inventory, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "mDefaultInventorySize": {
          "description": "When we make an inventory by adding the component to an actor we use this to specify its size",
          "type": "number"
        },
        "mAdjustedSizeDiff": {
          "description": "When we resize the inventory we save how much bigger or smaller the inventory was made",
          "type": "number"
        },
        "mInventoryStacks": {
          "description": "All items in the inventory",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mArbitrarySlotSizes": {
          "description": "In some rare cases we don't want to use the StackSize to limit the slot, so this way we can have larger or smaller slots",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mAllowedItemDescriptors": {
          "description": "This are the allowed inventory items, this we we can \"filter\" in BluePrint as well.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCanBeRearrange": {
          "description": "Can stuff in this inventory be rearranged, that is moved from one slot to the other?",
          "type": "boolean"
        }
      },
      "required": [
        "OnItemAddedDelegate",
        "OnItemRemovedDelegate",
        "ResizeInventoryDelegate",
        "mAdjustedSizeDiff",
        "mAllowedItemDescriptors",
        "mArbitrarySlotSizes",
        "mCanBeRearrange",
        "mDefaultInventorySize",
        "mInventoryStacks"
      ]
    },
    "AFGDriveablePawn": {
      "type": "object",
      "properties": {
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mIsDriverVisible",
        "mIsDriving",
        "mShouldAttachDriver"
      ]
    },
    "UFGOutlineComponent": {
      "type": "object",
      "properties": {
        "mOutlineProxy": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mActiveOutlineActor": {
          "$ref": "#/definitions/AActor"
        },
        "mActiveMultiOutlineActors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AActor"
          }
        },
        "mCachedActorMaterials": {
          "$ref": "#/definitions/Map<AActor,FCachedMeshToMaterialObject>"
        },
        "mCachedSplineComponentMaterials": {
          "$ref": "#/definitions/Map<UFGSplineComponent,FCachedSplineMeshToMaterialObject>"
        },
        "mCachedProxyMeshMaterials": {
          "$ref": "#/definitions/Map<any,FCachedMaterialInterfaceArray>"
        }
      },
      "required": [
        "mActiveMultiOutlineActors",
        "mActiveOutlineActor",
        "mCachedActorMaterials",
        "mCachedProxyMeshMaterials",
        "mCachedSplineComponentMaterials",
        "mOutlineProxy"
      ]
    },
    "Map<AActor,FCachedMeshToMaterialObject>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<UFGSplineComponent,FCachedSplineMeshToMaterialObject>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<any,FCachedMaterialInterfaceArray>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGHealthComponent": {
      "type": "object",
      "properties": {
        "OnTakeAnyDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "OnTakePointDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "OnTakeRadialDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "DeathDelegate": {
          "description": "SERVER ONLY: Called when we die"
        },
        "HealDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mOnAdjustDamage": {
          "description": "Interested listeners for the adjust damage delegates",
          "type": "array",
          "items": {}
        },
        "mMaxHealth": {
          "description": "Our maximum health",
          "type": "number"
        },
        "mCurrentHealth": {
          "description": "Our current health",
          "type": "number"
        },
        "mRespawnHealthFactor": {
          "description": "Scale of max health to use when respawning",
          "type": "number"
        },
        "mIsDead": {
          "description": "If true, then we are dead. This is replicated to clients and they get the death event based on this.",
          "type": "number"
        },
        "mReplicateDamageEvents": {
          "description": "If true, then the client will trigger the following events: OnTakeAnyDamageDelegate, OnTakePointDamageDelegate, OnTakeRadialDamageDelegate",
          "type": "number"
        },
        "mReplicateDeathEvents": {
          "description": "If true, then the client will trigger the following event: DeathDelegate",
          "type": "number"
        }
      },
      "required": [
        "DeathDelegate",
        "HealDelegate",
        "OnTakeAnyDamageDelegate",
        "OnTakePointDamageDelegate",
        "OnTakeRadialDamageDelegate",
        "mCurrentHealth",
        "mIsDead",
        "mMaxHealth",
        "mOnAdjustDamage",
        "mReplicateDamageEvents",
        "mReplicateDeathEvents",
        "mRespawnHealthFactor"
      ]
    },
    "FNetConstructionID": {
      "description": "Used to track constructed (spawned) buildables matched with their holograms between client and server",
      "type": "object",
      "properties": {
        "NetPlayerID": {
          "description": "An 8-bit signed integer.",
          "type": "number"
        },
        "Server_ID": {
          "description": "An 16-bit unsigned integer.",
          "type": "number"
        },
        "Client_ID": {
          "description": "An 16-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "Client_ID",
        "NetPlayerID",
        "Server_ID"
      ]
    },
    "AFGBuildableConveyorBelt": {
      "type": "object",
      "properties": {
        "mMesh": {
          "description": "Mesh to use for his conveyor.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this conveyor.",
          "type": "number"
        },
        "mItemMeshMap": {
          "$ref": "#/definitions/Map<string,any>",
          "description": "Meshes for items."
        },
        "mSplineData": {
          "description": "Compact representation of mSplineComponent, used for replication and save game",
          "type": "array",
          "items": {}
        },
        "mSplineComponent": {
          "description": "The spline component for this conveyor. Note that this is only the spline."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mSoundSplineComponent": {
          "$ref": "#/definitions/UFGSoundSplineComponent",
          "description": "Wwise multiple position playback for the conveyor spline."
        },
        "mSplineAudioEvent": {
          "description": "The ak event to post for the sound spline"
        },
        "PresistentConveyorPackagingDataObject": {
          "$ref": "#/definitions/UPresistentConveyorPackagingData",
          "description": "held here, but created by conveyors when replicated, as we don't want to create it unless it's used."
        },
        "mSpeed": {
          "description": "Speed of this conveyor.",
          "type": "number"
        },
        "mItems": {
          "$ref": "#/definitions/FConveyorBeltItems",
          "description": "All the locally simulated resource offsets on the conveyor belt."
        },
        "mConnection0": {
          "description": "First connection on conveyor belt, Connections are always in the same order, mConnection0 is the input, mConnection1 is the output."
        },
        "mConnection1": {
          "description": "Second connection on conveyor belt"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "PresistentConveyorPackagingDataObject",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mItemMeshMap",
        "mItems",
        "mMaterialNameToInstanceManager",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSoundSplineComponent",
        "mSpeed",
        "mSplineAudioEvent",
        "mSplineComponent",
        "mSplineData"
      ]
    },
    "Map<string,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UPresistentConveyorPackagingData": {
      "type": "object"
    },
    "FConveyorBeltItems": {
      "type": "object"
    },
    "UFGFactoryLegsComponent": {
      "type": "object",
      "properties": {
        "mLegSocketNames": {
          "description": "Socket names on the parent mesh",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mLegMeshOverride": {
          "description": "The mesh to be used as legs on factories",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFootMeshOverride": {
          "description": "The mesh to be used as foots on factories",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxLegLengthOverride": {
          "description": "The maximum length the legs can be.",
          "type": "number"
        },
        "mLegMeshComponents": {
          "description": "The created leg components for this building",
          "type": "array",
          "items": {}
        },
        "mFootMeshComponents": {
          "description": "The created foot components for this building",
          "type": "array",
          "items": {}
        },
        "mCachedFeetOffset": {
          "description": "Stored so that we know the offset of the feet",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFeetOffset"
          }
        }
      },
      "required": [
        "mCachedFeetOffset",
        "mFootMeshComponents",
        "mFootMeshOverride",
        "mLegMeshComponents",
        "mLegMeshOverride",
        "mLegSocketNames",
        "mMaxLegLengthOverride"
      ]
    },
    "FFeetOffset": {
      "type": "object",
      "properties": {
        "FeetIndex": {
          "description": "The name of the foot's socket.",
          "type": "number"
        },
        "OffsetZ": {
          "description": "The offset along the Z axis from the parent mesh origo.",
          "type": "number"
        },
        "IsValidOffset": {
          "description": "Does this foot have a valid offset, only used during hologram placement.",
          "type": "boolean"
        }
      },
      "required": [
        "FeetIndex",
        "IsValidOffset",
        "OffsetZ"
      ]
    },
    "AFGHologram": {
      "type": "object",
      "properties": {
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceDetector",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLoopSound",
        "mPlacementMaterial",
        "mRecipe",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    }
  },
  "$schema": "http://json-schema.org/draft-07/schema#"
}