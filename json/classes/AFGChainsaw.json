{
  "type": "object",
  "properties": {
    "mFuelClass": {
      "description": "The fuel we want to be able to use with the chainsaw",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mEnergyConsumption": {
      "description": "How much energy the chainsaw consumes. In megawatt seconds (MWs)",
      "type": "number"
    },
    "mSawDownTreeTime": {
      "description": "How many seconds should it take to saw down a tree",
      "type": "number"
    },
    "mCollateralPickupRadius": {
      "description": "How large radius of automatic pick up of foliage is when using chainsaw",
      "type": "number"
    },
    "mExcludeChainsawableFoliage": {
      "description": "If collateral pickups should exclude chainsawable foliage when using chainsaw",
      "type": "boolean"
    },
    "mEnergyStored": {
      "description": "A floating point number.",
      "type": "number"
    },
    "mAttachmentClass": {
      "description": "This is the attachment for this class",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mSecondaryAttachmentClass": {
      "description": "This is the secondary attachment for this class",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mEquipmentSlot": {
      "$ref": "#/definitions/EEquipmentSlot",
      "description": "To what slot is this limited to?"
    },
    "mSprintHeadBobShake": {
      "description": "Camera shake to play when sprinting",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mEquipSound": {
      "description": "Sound played when equipping"
    },
    "mUnequipSound": {
      "description": "Sound played when unequipping"
    },
    "mEquipmentWidget": {
      "description": "Class of widget to add when equipping this equipment",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mChildEquipment": {
      "$ref": "#/definitions/AFGEquipmentChild",
      "description": "Holds a reference to the child equipment that may be spawned with this"
    },
    "m1PAnimClass": {
      "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mAttachSocket": {
      "description": "If this equipment should attach to a socket, this is the socket.",
      "type": "string"
    },
    "mChildEquipmentClass": {
      "description": "The class (if any) to use to spawn a child equipment",
      "type": "object",
      "properties": {
        "package": {
          "type": "string"
        },
        "name": {
          "type": "string"
        }
      },
      "required": [
        "name",
        "package"
      ]
    },
    "mCostToUse": {
      "description": "The cost of using this equipment",
      "type": "array",
      "items": {
        "$ref": "#/definitions/FItemAmount"
      }
    },
    "mArmAnimation": {
      "$ref": "#/definitions/EArmEquipment",
      "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
    },
    "mBackAnimation": {
      "$ref": "#/definitions/EBackEquipment",
      "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
    },
    "mHasPersistentOwner": {
      "description": "If the owner is persistent throughout the lifetime of this equipment",
      "type": "boolean"
    },
    "mAttachment": {
      "$ref": "#/definitions/AFGEquipmentAttachment",
      "description": "This is the attachment of this equipment"
    },
    "mSecondaryAttachment": {
      "$ref": "#/definitions/AFGEquipmentAttachment",
      "description": "This is a potential secondary attachment"
    },
    "mIdlePoseAnimation": {
      "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
    },
    "mIdlePoseAnimation3p": {
      "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
    },
    "mUseDefaultPrimaryFire": {
      "description": "Should we use the default primary fire implementation",
      "type": "boolean"
    }
  },
  "required": [
    "m1PAnimClass",
    "mArmAnimation",
    "mAttachSocket",
    "mAttachment",
    "mAttachmentClass",
    "mBackAnimation",
    "mChildEquipment",
    "mChildEquipmentClass",
    "mCollateralPickupRadius",
    "mCostToUse",
    "mEnergyConsumption",
    "mEnergyStored",
    "mEquipSound",
    "mEquipmentSlot",
    "mEquipmentWidget",
    "mExcludeChainsawableFoliage",
    "mFuelClass",
    "mHasPersistentOwner",
    "mIdlePoseAnimation",
    "mIdlePoseAnimation3p",
    "mSawDownTreeTime",
    "mSecondaryAttachment",
    "mSecondaryAttachmentClass",
    "mSprintHeadBobShake",
    "mUnequipSound",
    "mUseDefaultPrimaryFire"
  ],
  "definitions": {
    "UFGActorRepresentation": {
      "type": "object",
      "properties": {
        "mRealActor": {
          "$ref": "#/definitions/AActor",
          "description": "This is the real actor that this representation represents"
        },
        "mActorLocation": {
          "description": "This is the actor location"
        },
        "mActorRotation": {
          "description": "This is the actor rotation"
        },
        "mIsStatic": {
          "description": "If the actor is static or can be moved",
          "type": "boolean"
        },
        "mRepresentationTexture": {
          "description": "This is the texture to show for this actor representation",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRepresentationText": {
          "description": "This is the text to show for this actor representation",
          "type": "string"
        },
        "mRepresentationColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "This is the color used for the representation of this actor"
        },
        "mRepresentationType": {
          "$ref": "#/definitions/ERepresentationType",
          "description": "This helps define how this actor representation should be presented"
        },
        "mFogOfWarRevealType": {
          "$ref": "#/definitions/EFogOfWarRevealType"
        },
        "mFogOfWarRevealRadius": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mShouldShowInCompass": {
          "description": "If this should be shown in the compass or not",
          "type": "boolean"
        },
        "mShouldShowOnMap": {
          "description": "If this should be shown on the map or not",
          "type": "boolean"
        },
        "mCompassViewDistance": {
          "$ref": "#/definitions/ECompassViewDistance",
          "description": "How far away this representation should be shown in the compass"
        }
      },
      "required": [
        "mActorLocation",
        "mActorRotation",
        "mCompassViewDistance",
        "mFogOfWarRevealRadius",
        "mFogOfWarRevealType",
        "mIsStatic",
        "mRealActor",
        "mRepresentationColor",
        "mRepresentationText",
        "mRepresentationTexture",
        "mRepresentationType",
        "mShouldShowInCompass",
        "mShouldShowOnMap"
      ]
    },
    "AActor": {
      "description": "Actor is the base class for an Object that can be placed or spawned in a level.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor/index.html",
      "type": "object"
    },
    "LinearColor": {
      "description": "A linear, 32-bit/component floating point RGBA color.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FLinearColor/index.html",
      "type": "object",
      "properties": {
        "R": {
          "description": "The color's red intensity.",
          "type": "number"
        },
        "G": {
          "description": "The color's green intensity.",
          "type": "number"
        },
        "B": {
          "description": "The color's blue intensity.",
          "type": "number"
        },
        "A": {
          "description": "The color's opacity.",
          "type": "number"
        }
      },
      "required": [
        "A",
        "B",
        "G",
        "R"
      ]
    },
    "ERepresentationType": {
      "enum": [
        0,
        1,
        10,
        11,
        12,
        13,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "EFogOfWarRevealType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "ECompassViewDistance": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "UFGSoundSplineComponent": {
      "type": "object",
      "properties": {
        "mEmitterInterval": {
          "description": "Distance beween each emitter on our parent spline, this might be scaled slightly so that we get a point on both start and end",
          "type": "number"
        }
      },
      "required": [
        "mEmitterInterval"
      ]
    },
    "FExponentialFogSettings": {
      "type": "object",
      "properties": {
        "FogHeight": {
          "description": "The ZValue of the fog",
          "type": "number"
        },
        "FogDensity": {
          "description": "Density of the fog",
          "type": "number"
        },
        "FogInscatteringColor": {
          "$ref": "#/definitions/LinearColor"
        },
        "FullyDirectionalInscatteringColorDistance": {
          "description": "Distance at which InscatteringColorCubemap should be used directly for the Inscattering Color.",
          "type": "number"
        },
        "NonDirectionalInscatteringColorDistance": {
          "description": "Distance at which only the average color of InscatteringColorCubemap should be used as Inscattering Color.",
          "type": "number"
        },
        "DirectionalInscatteringExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DirectionalInscatteringStartDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DirectionalInscatteringColor": {
          "$ref": "#/definitions/LinearColor"
        },
        "FogHeightFalloff": {
          "description": "A floating point number.",
          "type": "number"
        },
        "FogMaxOpacity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "StartDistance": {
          "description": "Distance from the camera that the fog will start, in world units.",
          "type": "number"
        },
        "FogCutoffDistance": {
          "description": "Scene elements past this distance will not have fog applied.  This is useful for excluding skyboxes which already have fog baked in.",
          "type": "number"
        }
      },
      "required": [
        "DirectionalInscatteringColor",
        "DirectionalInscatteringExponent",
        "DirectionalInscatteringStartDistance",
        "FogCutoffDistance",
        "FogDensity",
        "FogHeight",
        "FogHeightFalloff",
        "FogInscatteringColor",
        "FogMaxOpacity",
        "FullyDirectionalInscatteringColorDistance",
        "NonDirectionalInscatteringColorDistance",
        "StartDistance"
      ]
    },
    "AFGBuildableAttachmentSplitter": {
      "type": "object",
      "properties": {
        "mCurrentOutputIndex": {
          "description": "Cycles through the outputs, stores the output we want to put mItem on. Index is for the mOutputs array.",
          "type": "number"
        },
        "mCurrentInventoryIndex": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mDistributionTable": {
          "description": "Table of all items in the inventory mapped to a desired output. The array is filled from a call to FillDistributionTable which runs in factory tick",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FConnectionItemStruct"
          }
        },
        "mConveyorSpaceData": {
          "$ref": "#/definitions/Map<any,FConveyorSpaceData>",
          "description": "Store last cached available space and if an item have been grabbed by the connected components"
        },
        "mBufferInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBufferInventory",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mConveyorSpaceData",
        "mCurrentInventoryIndex",
        "mCurrentOutputIndex",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDistributionTable",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "FConnectionItemStruct": {
      "type": "object",
      "properties": {
        "Connection": {
          "description": "The connection to put the item on"
        },
        "Item": {
          "$ref": "#/definitions/FInventoryItem",
          "description": "The item to put on the connection"
        }
      },
      "required": [
        "Connection",
        "Item"
      ]
    },
    "FInventoryItem": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "The type of item",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ItemState": {
          "$ref": "#/definitions/FSharedInventoryStatePtr",
          "description": "Optionally store an actor, e.g. an equipment, so we can remember it's state."
        }
      },
      "required": [
        "ItemClass",
        "ItemState"
      ]
    },
    "FSharedInventoryStatePtr": {
      "type": "object",
      "properties": {
        "ActorPtr": {
          "$ref": "#/definitions/AActor",
          "description": "The actor we've shared ownership over."
        }
      },
      "required": [
        "ActorPtr"
      ]
    },
    "Map<any,FConveyorSpaceData>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGInventoryComponent": {
      "type": "object",
      "properties": {
        "ResizeInventoryDelegate": {
          "description": "Called when this inventory has been resized"
        },
        "OnItemAddedDelegate": {
          "description": "Called when this inventory has something added to it, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "OnItemRemovedDelegate": {
          "description": "Called when something has been removed from the inventory, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "mDefaultInventorySize": {
          "description": "When we make an inventory by adding the component to an actor we use this to specify its size",
          "type": "number"
        },
        "mAdjustedSizeDiff": {
          "description": "When we resize the inventory we save how much bigger or smaller the inventory was made",
          "type": "number"
        },
        "mInventoryStacks": {
          "description": "All items in the inventory",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mArbitrarySlotSizes": {
          "description": "In some rare cases we don't want to use the StackSize to limit the slot, so this way we can have larger or smaller slots",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mAllowedItemDescriptors": {
          "description": "This are the allowed inventory items, this we we can \"filter\" in BluePrint as well.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCanBeRearrange": {
          "description": "Can stuff in this inventory be rearranged, that is moved from one slot to the other?",
          "type": "boolean"
        }
      },
      "required": [
        "OnItemAddedDelegate",
        "OnItemRemovedDelegate",
        "ResizeInventoryDelegate",
        "mAdjustedSizeDiff",
        "mAllowedItemDescriptors",
        "mArbitrarySlotSizes",
        "mCanBeRearrange",
        "mDefaultInventorySize",
        "mInventoryStacks"
      ]
    },
    "FInventoryStack": {
      "type": "object",
      "properties": {
        "Item": {
          "$ref": "#/definitions/FInventoryItem",
          "description": "Type of item in this stack."
        },
        "NumItems": {
          "description": "Number of items in this stack.",
          "type": "number"
        }
      },
      "required": [
        "Item",
        "NumItems"
      ]
    },
    "UFGPowerInfoComponent": {
      "type": "object",
      "properties": {
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mTargetConsumption": {
          "description": "Power to draw from the circuit.",
          "type": "number"
        },
        "mActualConsumption": {
          "description": "The actual power we got from the circuit (updated each frame).",
          "type": "number"
        },
        "mBaseProduction": {
          "description": "Power to always provide to the circuit.",
          "type": "number"
        },
        "mDynamicProductionCapacity": {
          "description": "Power to optionally provide to the circuit.",
          "type": "number"
        },
        "mDynamicProductionDemandFactor": {
          "description": "The demand for dynamic power (updated each frame).",
          "type": "number"
        },
        "mIsFuseTriggered": {
          "description": "true if the circuit is overloaded and the fuse has been triggered.",
          "type": "number"
        }
      },
      "required": [
        "mActualConsumption",
        "mBaseProduction",
        "mCircuitID",
        "mDynamicProductionCapacity",
        "mDynamicProductionDemandFactor",
        "mIsFuseTriggered",
        "mTargetConsumption"
      ]
    },
    "EStackSize": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "type": "number"
    },
    "AFGReplicationDetailActor": {
      "type": "object",
      "properties": {
        "mOwningBuildable": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "Owning AFGBuildable to this replication detail actor object. Should never be null."
        }
      },
      "required": [
        "mOwningBuildable"
      ]
    },
    "AFGBuildable": {
      "type": "object",
      "properties": {
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect"
      ]
    },
    "Vector": {
      "description": "A vector in 3-D space composed of components (X, Y, Z) with floating point precision.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FVector/index.html",
      "type": "object",
      "properties": {
        "X": {
          "description": "The vector's X component.",
          "type": "number"
        },
        "Y": {
          "description": "The vector's Y component.",
          "type": "number"
        },
        "Z": {
          "description": "The vector's Z component.",
          "type": "number"
        }
      },
      "required": [
        "X",
        "Y",
        "Z"
      ]
    },
    "FFactoryTickFunction": {
      "type": "object"
    },
    "Map<string,UFGFactoryMaterialInstanceManager>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "AFGCharacterPlayer": {
      "type": "object",
      "properties": {
        "mBaseTurnRate": {
          "description": "Base turn rate, in deg/sec. Other scaling may affect final turn rate.",
          "type": "number"
        },
        "mBaseLookUpRate": {
          "description": "Base look up/down rate, in deg/sec. Other scaling may affect final rate.",
          "type": "number"
        },
        "mMesh1PAnimClass": {
          "description": "The default arms animation when we're idle.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh3P": {
          "description": "Pawn mesh: 3rd person view"
        },
        "mFoliagePickupProxyClass": {
          "description": "As we have no foliage actor to actually put pickup code in, we use this actor as a proxy",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFoliagePickupProxy": {
          "$ref": "#/definitions/AFGFoliagePickup",
          "description": "Actor that's used when trying to pickup foliage"
        },
        "mBuildGun": {
          "$ref": "#/definitions/AFGBuildGun",
          "description": "This is the infamous build gun."
        },
        "mResourceScanner": {
          "$ref": "#/definitions/AFGResourceScanner",
          "description": "Reference to the resource scanner"
        },
        "mResourceMiner": {
          "$ref": "#/definitions/AFGResourceMiner",
          "description": "Reference to the resource miner"
        },
        "mBestUsableActor": {
          "$ref": "#/definitions/AActor",
          "description": "The best usable actor nearby."
        },
        "mCachedUseState": {
          "$ref": "#/definitions/FUseState",
          "description": "Of the usable actor we are looking at, UPROPERTY to prevent the AdditionalData to be garbage collected"
        },
        "mAnimInstanceClass": {
          "description": "Anim instance class to use in third person",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAnimInstanceClass1P": {
          "description": "Anim instance class to use in first person",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mReviveDuration": {
          "description": "time (in seconds) it takes to revive a fellow player",
          "type": "number"
        },
        "mStartingResources": {
          "description": "The starting resources for the player",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mStartingResourceForTesting": {
          "description": "The starting resources for the player if we are NOT in shipping",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mDrownDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDrownDamage": {
          "description": "The amount of damage to receive when drowning.",
          "type": "number"
        },
        "mDrownDamageInterval": {
          "description": "Time between each application of drowning damage (in seconds)",
          "type": "number"
        },
        "mPlayerToRevive": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player that we are reviving"
        },
        "mPickupToCollect": {
          "$ref": "#/definitions/AFGItemPickup",
          "description": "The pickup we are collecting"
        },
        "m1PDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in m1PFootstepEffect"
        },
        "m1PFootstepEffect": {
          "description": "Effects to play when a foot hits the ground in first person",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "m1PFootstepEvent": {
          "description": "Effects to play when a foot hits the ground in first person",
          "type": "array",
          "items": {}
        },
        "mLastSafeGroundPositions": {
          "$ref": "#/definitions/Vector",
          "description": "latest safe ground location positions"
        },
        "mLastSafeGroundPositionLoopHead": {
          "description": "used for knowing which is the latest written safe ground position",
          "type": "number"
        },
        "mCameraComponent": {
          "description": "Player camera"
        },
        "mSpringArmComponent": {
          "description": "Spring arm for camera"
        },
        "mActiveEquipments": {
          "description": "This is the equipment we hold in our hands.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipment"
          }
        },
        "mClientActiveEquipments": {
          "description": "Simulated on the client so they know what to unequip.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipment"
          }
        },
        "mAllAttachments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipmentAttachment"
          }
        },
        "mActiveAttachments": {
          "description": "Remote client representation of the equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipmentAttachment"
          }
        },
        "mCurrentCameraMode": {
          "$ref": "#/definitions/ECameraMode",
          "description": "Current camera mode for the character"
        },
        "mPlayerPreferredCameraMode": {
          "$ref": "#/definitions/ECameraMode",
          "description": "What camera mode were we in before we opened the"
        },
        "mInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The players inventory."
        },
        "mAllowedResourceFormsInInventory": {
          "description": "The resource forms that are allowed in players inventory.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/EResourceForm"
          }
        },
        "mBeltSlot": {
          "$ref": "#/definitions/UFGInventoryComponentBeltSlot",
          "description": "The belt slot inventory."
        },
        "mTrashSlot": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The players inventory."
        },
        "mAllowCameraToggling": {
          "description": "Allow toggling of camera modes",
          "type": "boolean"
        },
        "mUseDistance": {
          "description": "Maximum distance we use objects on",
          "type": "number"
        },
        "mPickupCounter": {
          "description": "Counter used for replicating to remote clients when something is picked up",
          "type": "number"
        },
        "mReviver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player that is reviving me"
        },
        "mDefaultWalkHeadBobShake": {
          "description": "Reference to the default walk head bob shake",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultSprintHeadBobShake": {
          "description": "Reference to the default sprint head bob shake",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDrivenVehicle": {
          "$ref": "#/definitions/AFGDriveablePawn",
          "description": "Vehicle currently driven by pawn."
        },
        "mSavedDrivenVehicle": {
          "$ref": "#/definitions/AFGDriveablePawn"
        },
        "mOutlineComponent": {
          "$ref": "#/definitions/UFGOutlineComponent"
        },
        "mHealthGenerationThreshold": {
          "description": "Health Generation",
          "type": "number"
        },
        "mHealthGenerationAmount": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHealthGenerationInterval": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHealthGenerationWaitTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mRadiationIntensity": {
          "description": "The accumulated normalized radiation intensity of the players current location",
          "type": "number"
        },
        "mRadiationDamageAngle": {
          "description": "The angle from the players view to the accumulated radiation damage",
          "type": "number"
        },
        "mRadiationImmunity": {
          "description": "How much immunity do we have for radiation",
          "type": "number"
        },
        "mInRadioactiveZone": {
          "description": "Are we in a radioactive zone",
          "type": "boolean"
        },
        "mCameraOffsetBlendSpeed": {
          "description": "How fast the blend is",
          "type": "number"
        },
        "mReplicatedIsSliding": {
          "description": "Replicated value of sliding status. Used to let non owning player know whats happening",
          "type": "boolean"
        },
        "mCrouchSpeed": {
          "description": "How fast the blend is for crouch and slide",
          "type": "number"
        },
        "mStandSpeed": {
          "description": "How fast the blend is from crouch/slide to stand",
          "type": "number"
        },
        "mSlideToCrouchSpeed": {
          "description": "How fast the blend is from slide to crouch",
          "type": "number"
        },
        "mNoUpdate": {
          "type": "boolean"
        },
        "mFeetNames": {
          "description": "When receiving FootDown on index 2, then we will trace from mFeetNames[2] socket for ground",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in mFootstepEffects"
        },
        "mFootstepEffect": {
          "description": "Effects to play when a foot hits the ground",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "mFootstepAudioEvents": {
          "description": "Audio event to play (where index in array is the feet index passed from AnimNotify_FootDown)",
          "type": "array",
          "items": {}
        },
        "mMaxFootstepParticleSpawnDistance": {
          "description": "Maximum distance we want to play footstep particles at",
          "type": "number"
        },
        "mMaxFootstepDecalSpawnDistance": {
          "description": "Maximum distance we want to spawn footsteps decals at",
          "type": "number"
        },
        "mFootstepDecalSize": {
          "description": "Size of footstep decals",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mFootstepDecalLifetime": {
          "description": "Lifetime of footstep decals",
          "type": "number"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mFallDamageCurve": {
          "description": "How much damage to take falling with a given velocity"
        },
        "mFallDamageCurveOverride": {
          "description": "Overrides the default fall damage curve, utilized by Equipment"
        },
        "mFallDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxDeathStayTime": {
          "description": "The maximum time after death (in seconds) the pawn will stay in the world, so it will be removed even if it's in sight after this time",
          "type": "number"
        },
        "mDeathRemoveCheckTime": {
          "description": "How often will we check if the pawn is in sight of any player",
          "type": "number"
        },
        "mEnemyTargetDesirability": {
          "description": "Multiplier for targeting desirability",
          "type": "number"
        },
        "mTakeDamageSound": {
          "description": "Sound played when pawn takes damage"
        },
        "mDeathSound": {
          "description": "Sound played when pawn dies"
        },
        "mLandEvent": {
          "description": "Event posted when landing"
        },
        "mTakeDamageParticle": {
          "description": "Particle for when pawn takes damage"
        },
        "mMinVehiclePushVelocityForRagdoll": {
          "description": "Min push velocity required to start ragdoll",
          "type": "number"
        },
        "mTimeToGetUpFromRagdoll": {
          "description": "time in seconds until character gets up from ragdoll if alive",
          "type": "number"
        },
        "mMaxDistanceMovedToGetUp": {
          "description": "the furthest distance we can move during ragdoll before we are considered still enough to stand up from ragdoll",
          "type": "number"
        },
        "mIsRagdolled": {
          "description": "true if ragdolled",
          "type": "boolean"
        },
        "mRagdollMeshLoc": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshVelocity": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshLocBoneName": {
          "description": "Name of the bone we take mesh location from",
          "type": "string"
        },
        "mRagdollMeshPhysicsBoneName": {
          "description": "Name of the bone we take physics velocity from",
          "type": "string"
        },
        "mSyncBodyMaxDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mApplyDamageMomentum": {
          "description": "Should the auto momentum be applied when taking damage?",
          "type": "boolean"
        },
        "mIgnoredDamageTypes": {
          "description": "Damage types that this character is immune to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mWeakspotMultiplier": {
          "description": "How much more damage should be dealt when taking a weakspot hit",
          "type": "number"
        },
        "mWeakspotBoneNames": {
          "description": "Bone names that result in a weakspot hit",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mNormalDamageMultiplier": {
          "description": "Multiplier for this creature and normal damage taken",
          "type": "number"
        },
        "mIsPossessed": {
          "description": "Used to let client know when a pawn gets possessed/unpossessed",
          "type": "boolean"
        }
      },
      "required": [
        "m1PDefaultFootstepEffect",
        "m1PFootstepEffect",
        "m1PFootstepEvent",
        "mActiveAttachments",
        "mActiveEquipments",
        "mAllAttachments",
        "mAllowCameraToggling",
        "mAllowedResourceFormsInInventory",
        "mAnimInstanceClass",
        "mAnimInstanceClass1P",
        "mApplyDamageMomentum",
        "mBaseLookUpRate",
        "mBaseTurnRate",
        "mBeltSlot",
        "mBestUsableActor",
        "mBuildGun",
        "mCachedUseState",
        "mCameraComponent",
        "mCameraOffsetBlendSpeed",
        "mClientActiveEquipments",
        "mCrouchSpeed",
        "mCurrentCameraMode",
        "mDeathRemoveCheckTime",
        "mDeathSound",
        "mDefaultFootstepEffect",
        "mDefaultSprintHeadBobShake",
        "mDefaultWalkHeadBobShake",
        "mDrivenVehicle",
        "mDrownDamage",
        "mDrownDamageDamageType",
        "mDrownDamageInterval",
        "mEnemyTargetDesirability",
        "mFallDamageCurve",
        "mFallDamageCurveOverride",
        "mFallDamageDamageType",
        "mFeetNames",
        "mFoliagePickupProxy",
        "mFoliagePickupProxyClass",
        "mFootstepAudioEvents",
        "mFootstepDecalLifetime",
        "mFootstepDecalSize",
        "mFootstepEffect",
        "mHealthComponent",
        "mHealthGenerationAmount",
        "mHealthGenerationInterval",
        "mHealthGenerationThreshold",
        "mHealthGenerationWaitTime",
        "mIgnoredDamageTypes",
        "mInRadioactiveZone",
        "mInventory",
        "mIsPossessed",
        "mIsRagdolled",
        "mLandEvent",
        "mLastSafeGroundPositionLoopHead",
        "mLastSafeGroundPositions",
        "mMaxDeathStayTime",
        "mMaxDistanceMovedToGetUp",
        "mMaxFootstepDecalSpawnDistance",
        "mMaxFootstepParticleSpawnDistance",
        "mMesh1PAnimClass",
        "mMesh3P",
        "mMinVehiclePushVelocityForRagdoll",
        "mNoUpdate",
        "mNormalDamageMultiplier",
        "mOutlineComponent",
        "mPickupCounter",
        "mPickupToCollect",
        "mPlayerPreferredCameraMode",
        "mPlayerToRevive",
        "mRadiationDamageAngle",
        "mRadiationImmunity",
        "mRadiationIntensity",
        "mRagdollMeshLoc",
        "mRagdollMeshLocBoneName",
        "mRagdollMeshPhysicsBoneName",
        "mRagdollMeshVelocity",
        "mReplicatedIsSliding",
        "mResourceMiner",
        "mResourceScanner",
        "mReviveDuration",
        "mReviver",
        "mSavedDrivenVehicle",
        "mSlideToCrouchSpeed",
        "mSpringArmComponent",
        "mStandSpeed",
        "mStartingResourceForTesting",
        "mStartingResources",
        "mSyncBodyMaxDistance",
        "mTakeDamageParticle",
        "mTakeDamageSound",
        "mTimeToGetUpFromRagdoll",
        "mTrashSlot",
        "mUseDistance",
        "mWeakspotBoneNames",
        "mWeakspotMultiplier"
      ]
    },
    "AFGFoliagePickup": {
      "type": "object",
      "properties": {
        "mPickupMesh": {
          "description": "The mesh that should be outlining",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "mPickupMesh"
      ]
    },
    "AFGBuildGun": {
      "type": "object",
      "properties": {
        "mOnStateChanged": {
          "description": "Called when the build gun state changes."
        },
        "mOnRecipeChanged": {
          "description": "Called when the build gun build state receives a new recipe. This May be called prior to OnStateChanged."
        },
        "mBuildDistanceMax": {
          "description": "Trace distance for this build gun when building and dismantling.",
          "type": "number"
        },
        "mMenuStateClass": {
          "description": "The state to use when operating the menus.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildStateClass": {
          "description": "The state to use when building.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleStateClass": {
          "description": "The state to use when dismantling.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStates": {
          "$ref": "#/definitions/UFGBuildGunState",
          "description": "All the states."
        },
        "mHitResult": {
          "description": "Result of the latest trace."
        },
        "mCurrentStateEnum": {
          "$ref": "#/definitions/EBuildGunState"
        },
        "mCurrentState": {
          "$ref": "#/definitions/UFGBuildGunState"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mBuildDistanceMax",
        "mBuildStateClass",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mCurrentState",
        "mCurrentStateEnum",
        "mDismantleStateClass",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHitResult",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mMenuStateClass",
        "mOnRecipeChanged",
        "mOnStateChanged",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mStates",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "UFGBuildGunState": {
      "type": "object",
      "properties": {
        "mActionDelay": {
          "description": "Time (in seconds) it takes for the action (eg. Build, dismantle)",
          "type": "number"
        },
        "mActionMessage": {
          "description": "Text to show while action is in progress",
          "type": "string"
        }
      },
      "required": [
        "mActionDelay",
        "mActionMessage"
      ]
    },
    "EBuildGunState": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "EEquipmentSlot": {
      "description": "Equipments are equip on different slots on the player. One EQ per slot. These are the slots.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "AFGEquipmentChild": {
      "type": "object",
      "properties": {
        "mParentEquipment": {
          "$ref": "#/definitions/AFGEquipment",
          "description": "stores a reference to the FGEquipment that spawned this class"
        },
        "mAttachSocket": {
          "description": "The socket to attach any child equipment to",
          "type": "string"
        }
      },
      "required": [
        "mAttachSocket",
        "mParentEquipment"
      ]
    },
    "AFGEquipment": {
      "type": "object",
      "properties": {
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FItemAmount": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "The item.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Amount": {
          "description": "The amount of this item.",
          "type": "number"
        }
      },
      "required": [
        "Amount",
        "ItemClass"
      ]
    },
    "EArmEquipment": {
      "enum": [
        0,
        1,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "EBackEquipment": {
      "enum": [
        0,
        1
      ],
      "type": "number"
    },
    "AFGEquipmentAttachment": {
      "type": "object",
      "properties": {
        "mEquipmentClass": {
          "description": "The class of the equipment that spawned this attachment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseLocation": {
          "$ref": "#/definitions/Vector",
          "description": "This value get replicated to clients so they can play effect"
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mAttachedTo": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The character this is attached to."
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this attachment attached"
        },
        "mAnimationState": {
          "description": "integer used for animation states",
          "type": "number"
        }
      },
      "required": [
        "mAnimationState",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachedTo",
        "mBackAnimation",
        "mEquipmentClass",
        "mEquipmentSlot",
        "mUseLocation"
      ]
    },
    "AFGResourceScanner": {
      "type": "object",
      "properties": {
        "mResourceDescriptorToScanFor": {
          "description": "This is the resource class to scan for",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mNrOfClosestClustersToMark": {
          "description": "How many node clusters should be marked",
          "type": "number"
        },
        "mLastPressedTimeStamp": {
          "description": "Keeps track of the last time we pressed Scan",
          "type": "number"
        },
        "mHoldDownDurationForUI": {
          "description": "Time needed to hold down the key to show the selection UI",
          "type": "number"
        },
        "mIsPressingScan": {
          "description": "True in between OnScanPressed and OnScanReleased",
          "type": "boolean"
        },
        "mIsWaitingForSelectionUI": {
          "description": "True if we are waiting for the selection UI",
          "type": "boolean"
        },
        "mDistBetweenNodesInCluster": {
          "description": "If nodes are closer that dist they are considered within the cluster",
          "type": "number"
        },
        "mNodeClusters": {
          "description": "A list of all the clusters of nodes non the level",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FNodeClusterData"
          }
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mDistBetweenNodesInCluster",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHoldDownDurationForUI",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mIsPressingScan",
        "mIsWaitingForSelectionUI",
        "mLastPressedTimeStamp",
        "mNodeClusters",
        "mNrOfClosestClustersToMark",
        "mResourceDescriptorToScanFor",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FNodeClusterData": {
      "description": "Holds information about resource node clusters. This could be saved in actors on the level for optimization.",
      "type": "object",
      "properties": {
        "Nodes": {
          "description": "Cost of schematic if there are more than once item in this array the true cost will be randomly selected.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGResourceNode"
          }
        },
        "MidPoint": {
          "$ref": "#/definitions/Vector",
          "description": "The average location of all the nodes"
        },
        "ResourceDescriptor": {
          "description": "The resource descriptor of this cluster",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "MidPoint",
        "Nodes",
        "ResourceDescriptor"
      ]
    },
    "AFGResourceNode": {
      "type": "object",
      "properties": {
        "mResourceClass": {
          "description": "Type of resource",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPurity": {
          "$ref": "#/definitions/EResourcePurity",
          "description": "How pure the resource is"
        },
        "mAmount": {
          "$ref": "#/definitions/EResourceAmount",
          "description": "How pure the resource is"
        },
        "mDecalComponent": {
          "description": "the decal that used for displaying the resource"
        },
        "mBoxComponent": {
          "description": "If we have no static mesh but a decal, then we use this for collision"
        },
        "mResourcesLeft": {
          "description": "How much resources is left in this node",
          "type": "number"
        },
        "mIsOccupied": {
          "description": "If true, then we are occupied by something // [Dylan 3/2/2020] - Removed savegame meta",
          "type": "boolean"
        },
        "mRevealedOnMapBy": {
          "description": "Radar tower modifies this to show this resource node in the map",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UObject"
          }
        },
        "mIsLonerNode": {
          "description": "If true, this node will NEVER join another cluster of nodes, regardless of proximity.",
          "type": "boolean"
        },
        "mCanPlaceResourceExtractor": {
          "description": "Can this resource node be used for placing resource extractors on",
          "type": "boolean"
        },
        "mExtractMultiplier": {
          "description": "Multiplier that is applied in the end of extraction calculations. Is used for making deposits extract more than regular nodes",
          "type": "number"
        },
        "mPurityTextArray": {
          "description": "Text mapped to resource purity",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPurityTextPair"
          }
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDoSpawnParticle": {
          "description": "Bool for is we should spawn particle - @todo Do we really need to save this? //[Dylan 3/2/2020]",
          "type": "boolean"
        }
      },
      "required": [
        "mAmount",
        "mBoxComponent",
        "mCanPlaceResourceExtractor",
        "mDecalComponent",
        "mDoSpawnParticle",
        "mExtractMultiplier",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mIsLonerNode",
        "mIsOccupied",
        "mPurity",
        "mPurityTextArray",
        "mResourceClass",
        "mResourcesLeft",
        "mRevealedOnMapBy"
      ]
    },
    "EResourcePurity": {
      "description": "How how fast it is to mine the resource",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "EResourceAmount": {
      "description": "How much resources this node contains, a rich vein will deplete later",
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "UObject": {
      "description": "The base class of all UE4 objects.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UObject/index.html",
      "type": "object"
    },
    "FPurityTextPair": {
      "type": "object",
      "properties": {
        "Text": {
          "description": "Localizable text",
          "type": "string"
        },
        "Purity": {
          "$ref": "#/definitions/EResourcePurity",
          "description": "Enum to localize"
        }
      },
      "required": [
        "Purity",
        "Text"
      ]
    },
    "AFGResourceMiner": {
      "type": "object",
      "properties": {
        "mPickParticleSystem": {
          "description": "The effect the spawn when picking."
        },
        "mPickArmsAnim": {
          "description": "Animation to play when picking."
        },
        "mCachedResouceNode": {
          "$ref": "#/definitions/AFGResourceNode",
          "description": "The node we want to pick from"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mCachedResouceNode",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mPickArmsAnim",
        "mPickParticleSystem",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FUseState": {
      "type": "object",
      "properties": {
        "AdditionalData": {
          "$ref": "#/definitions/UFGUseState",
          "description": "Additional data that might be heavy to calculate several times the same frame, the reason it's cached here and not in the object, is that several players might want to cache different things"
        },
        "UseLocation": {
          "$ref": "#/definitions/Vector",
          "description": "Location of where the use happens"
        },
        "UseComponent": {
          "description": "Component that triggered the use"
        },
        "State": {
          "description": "Contains the usable state of the object, might be a error code",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "AdditionalData",
        "State",
        "UseComponent",
        "UseLocation"
      ]
    },
    "UFGUseState": {
      "type": "object",
      "properties": {
        "mWantAdditonalData": {
          "description": "If true, we will allocate a instance of the state, so we can store information in the state",
          "type": "boolean"
        },
        "mIsUsableState": {
          "description": "If true, we will allocate a instance of the state, so we can store information in the state",
          "type": "boolean"
        }
      },
      "required": [
        "mIsUsableState",
        "mWantAdditonalData"
      ]
    },
    "AFGItemPickup": {
      "type": "object",
      "properties": {
        "mTimeToPickUp": {
          "description": "The amount of time required to pickup < 0 == instant",
          "type": "number"
        },
        "mCollector": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player collecting the item"
        },
        "mCollectingTimerHandle": {
          "description": "Timer handler for item being picked up"
        },
        "mPickupItems": {
          "$ref": "#/definitions/FInventoryStack",
          "description": "The items we want to be able to pickup"
        },
        "mDestroyOnPickup": {
          "description": "If set to true, then we destroy the item when it's pickup:ed",
          "type": "boolean"
        },
        "mSoundComponent": {
          "description": "ak component that plays sound"
        },
        "mAudioEvent": {
          "description": "The ak event to post for the sound"
        }
      },
      "required": [
        "mAudioEvent",
        "mCollectingTimerHandle",
        "mCollector",
        "mDestroyOnPickup",
        "mPickupItems",
        "mSoundComponent",
        "mTimeToPickUp"
      ]
    },
    "FFootstepEffect": {
      "type": "object",
      "properties": {
        "Particle": {
          "description": "The particle to use when hitting the ground"
        },
        "GroundDecals": {
          "description": "The decal to place on the ground when walking around",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "GroundDecals",
        "Particle"
      ]
    },
    "FFootstepEffectSurface": {
      "type": "object",
      "properties": {
        "Surface": {
          "description": "The surface the foot hit"
        },
        "Effect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "The effect we want to play when hitting the surface"
        }
      },
      "required": [
        "Effect",
        "Surface"
      ]
    },
    "ECameraMode": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "EResourceForm": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "UFGInventoryComponentBeltSlot": {
      "type": "object",
      "properties": {
        "ResizeInventoryDelegate": {
          "description": "Called when this inventory has been resized"
        },
        "OnItemAddedDelegate": {
          "description": "Called when this inventory has something added to it, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "OnItemRemovedDelegate": {
          "description": "Called when something has been removed from the inventory, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "mDefaultInventorySize": {
          "description": "When we make an inventory by adding the component to an actor we use this to specify its size",
          "type": "number"
        },
        "mAdjustedSizeDiff": {
          "description": "When we resize the inventory we save how much bigger or smaller the inventory was made",
          "type": "number"
        },
        "mInventoryStacks": {
          "description": "All items in the inventory",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mArbitrarySlotSizes": {
          "description": "In some rare cases we don't want to use the StackSize to limit the slot, so this way we can have larger or smaller slots",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mAllowedItemDescriptors": {
          "description": "This are the allowed inventory items, this we we can \"filter\" in BluePrint as well.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCanBeRearrange": {
          "description": "Can stuff in this inventory be rearranged, that is moved from one slot to the other?",
          "type": "boolean"
        }
      },
      "required": [
        "OnItemAddedDelegate",
        "OnItemRemovedDelegate",
        "ResizeInventoryDelegate",
        "mAdjustedSizeDiff",
        "mAllowedItemDescriptors",
        "mArbitrarySlotSizes",
        "mCanBeRearrange",
        "mDefaultInventorySize",
        "mInventoryStacks"
      ]
    },
    "AFGDriveablePawn": {
      "type": "object",
      "properties": {
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mIsDriverVisible",
        "mIsDriving",
        "mShouldAttachDriver"
      ]
    },
    "UFGOutlineComponent": {
      "type": "object",
      "properties": {
        "mOutlineProxy": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mActiveOutlineActor": {
          "$ref": "#/definitions/AActor"
        },
        "mActiveMultiOutlineActors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AActor"
          }
        },
        "mCachedActorMaterials": {
          "$ref": "#/definitions/Map<AActor,FCachedMeshToMaterialObject>"
        },
        "mCachedSplineComponentMaterials": {
          "$ref": "#/definitions/Map<UFGSplineComponent,FCachedSplineMeshToMaterialObject>"
        },
        "mCachedProxyMeshMaterials": {
          "$ref": "#/definitions/Map<any,FCachedMaterialInterfaceArray>"
        }
      },
      "required": [
        "mActiveMultiOutlineActors",
        "mActiveOutlineActor",
        "mCachedActorMaterials",
        "mCachedProxyMeshMaterials",
        "mCachedSplineComponentMaterials",
        "mOutlineProxy"
      ]
    },
    "Map<AActor,FCachedMeshToMaterialObject>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<UFGSplineComponent,FCachedSplineMeshToMaterialObject>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<any,FCachedMaterialInterfaceArray>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGHealthComponent": {
      "type": "object",
      "properties": {
        "OnTakeAnyDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "OnTakePointDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "OnTakeRadialDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "DeathDelegate": {
          "description": "SERVER ONLY: Called when we die"
        },
        "HealDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mOnAdjustDamage": {
          "description": "Interested listeners for the adjust damage delegates",
          "type": "array",
          "items": {}
        },
        "mMaxHealth": {
          "description": "Our maximum health",
          "type": "number"
        },
        "mCurrentHealth": {
          "description": "Our current health",
          "type": "number"
        },
        "mRespawnHealthFactor": {
          "description": "Scale of max health to use when respawning",
          "type": "number"
        },
        "mIsDead": {
          "description": "If true, then we are dead. This is replicated to clients and they get the death event based on this.",
          "type": "number"
        },
        "mReplicateDamageEvents": {
          "description": "If true, then the client will trigger the following events: OnTakeAnyDamageDelegate, OnTakePointDamageDelegate, OnTakeRadialDamageDelegate",
          "type": "number"
        },
        "mReplicateDeathEvents": {
          "description": "If true, then the client will trigger the following event: DeathDelegate",
          "type": "number"
        }
      },
      "required": [
        "DeathDelegate",
        "HealDelegate",
        "OnTakeAnyDamageDelegate",
        "OnTakePointDamageDelegate",
        "OnTakeRadialDamageDelegate",
        "mCurrentHealth",
        "mIsDead",
        "mMaxHealth",
        "mOnAdjustDamage",
        "mReplicateDamageEvents",
        "mReplicateDeathEvents",
        "mRespawnHealthFactor"
      ]
    },
    "FNetConstructionID": {
      "description": "Used to track constructed (spawned) buildables matched with their holograms between client and server",
      "type": "object",
      "properties": {
        "NetPlayerID": {
          "description": "An 8-bit signed integer.",
          "type": "number"
        },
        "Server_ID": {
          "description": "An 16-bit unsigned integer.",
          "type": "number"
        },
        "Client_ID": {
          "description": "An 16-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "Client_ID",
        "NetPlayerID",
        "Server_ID"
      ]
    },
    "AFGBuildableConveyorBelt": {
      "type": "object",
      "properties": {
        "mMesh": {
          "description": "Mesh to use for his conveyor.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this conveyor.",
          "type": "number"
        },
        "mItemMeshMap": {
          "$ref": "#/definitions/Map<string,any>",
          "description": "Meshes for items."
        },
        "mSplineData": {
          "description": "Compact representation of mSplineComponent, used for replication and save game",
          "type": "array",
          "items": {}
        },
        "mSplineComponent": {
          "description": "The spline component for this conveyor. Note that this is only the spline."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mSoundSplineComponent": {
          "$ref": "#/definitions/UFGSoundSplineComponent",
          "description": "Wwise multiple position playback for the conveyor spline."
        },
        "mSplineAudioEvent": {
          "description": "The ak event to post for the sound spline"
        },
        "PresistentConveyorPackagingDataObject": {
          "$ref": "#/definitions/UPresistentConveyorPackagingData",
          "description": "held here, but created by conveyors when replicated, as we don't want to create it unless it's used."
        },
        "mSpeed": {
          "description": "Speed of this conveyor.",
          "type": "number"
        },
        "mItems": {
          "$ref": "#/definitions/FConveyorBeltItems",
          "description": "All the locally simulated resource offsets on the conveyor belt."
        },
        "mConnection0": {
          "description": "First connection on conveyor belt, Connections are always in the same order, mConnection0 is the input, mConnection1 is the output."
        },
        "mConnection1": {
          "description": "Second connection on conveyor belt"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "PresistentConveyorPackagingDataObject",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mItemMeshMap",
        "mItems",
        "mMaterialNameToInstanceManager",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSoundSplineComponent",
        "mSpeed",
        "mSplineAudioEvent",
        "mSplineComponent",
        "mSplineData"
      ]
    },
    "Map<string,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UPresistentConveyorPackagingData": {
      "type": "object"
    },
    "FConveyorBeltItems": {
      "type": "object"
    },
    "UFGFactoryLegsComponent": {
      "type": "object",
      "properties": {
        "mLegSocketNames": {
          "description": "Socket names on the parent mesh",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mLegMeshOverride": {
          "description": "The mesh to be used as legs on factories",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFootMeshOverride": {
          "description": "The mesh to be used as foots on factories",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxLegLengthOverride": {
          "description": "The maximum length the legs can be.",
          "type": "number"
        },
        "mLegMeshComponents": {
          "description": "The created leg components for this building",
          "type": "array",
          "items": {}
        },
        "mFootMeshComponents": {
          "description": "The created foot components for this building",
          "type": "array",
          "items": {}
        },
        "mCachedFeetOffset": {
          "description": "Stored so that we know the offset of the feet",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFeetOffset"
          }
        }
      },
      "required": [
        "mCachedFeetOffset",
        "mFootMeshComponents",
        "mFootMeshOverride",
        "mLegMeshComponents",
        "mLegMeshOverride",
        "mLegSocketNames",
        "mMaxLegLengthOverride"
      ]
    },
    "FFeetOffset": {
      "type": "object",
      "properties": {
        "FeetIndex": {
          "description": "The name of the foot's socket.",
          "type": "number"
        },
        "OffsetZ": {
          "description": "The offset along the Z axis from the parent mesh origo.",
          "type": "number"
        },
        "IsValidOffset": {
          "description": "Does this foot have a valid offset, only used during hologram placement.",
          "type": "boolean"
        }
      },
      "required": [
        "FeetIndex",
        "IsValidOffset",
        "OffsetZ"
      ]
    },
    "AFGHologram": {
      "type": "object",
      "properties": {
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceDetector",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLoopSound",
        "mPlacementMaterial",
        "mRecipe",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGPlayerState": {
      "type": "object",
      "properties": {
        "BuildableConstructedDelegate": {
          "description": "Broadcast when a buildable or decor has been constructed."
        },
        "mHotbarShortcuts": {
          "description": "All hotbar actions assigned",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGHotbarShortcut"
          }
        },
        "mDefaultRecipeShortcuts": {
          "description": "Default recipes to have shortcuts to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mNewRecipes": {
          "description": "Recipes that are new to the player. This is only for UI feedback and doesn't affect the players ability to use the recipe",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mSlotNum": {
          "description": "The slot num of this player state",
          "type": "number"
        },
        "mSlotData": {
          "$ref": "#/definitions/FSlotData",
          "description": "This players color container"
        },
        "mOwnedPawn": {
          "description": "Pawn we should take control of when rejoining game/loading game"
        },
        "mHasReceivedInitialItems": {
          "description": "Set to true after we have received our initial items",
          "type": "number"
        },
        "mHasSetupDefaultShortcuts": {
          "description": "Set to true after we have setup our initial shortcuts",
          "type": "number"
        },
        "mIsServerAdmin": {
          "description": "If true, then we are server admin",
          "type": "number"
        },
        "mTutorialSubsystem": {
          "$ref": "#/definitions/UFGTutorialSubsystem",
          "description": "Each local player has their own tutorial subsystem"
        },
        "mTutorialSubsystemClass": {
          "description": "Class of tutorial subsystem to spawn",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMessageData": {
          "description": "Data about all messages that can be displayed in the codex",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FMessageData"
          }
        },
        "mRememberedFirstTimeEquipmentClasses": {
          "description": "List of equipment classes that have been equipped at least once.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mNumArmSlots": {
          "description": "Total number of arm equipment slots for this player",
          "type": "number"
        },
        "mOnlyShowAffordableRecipes": {
          "description": "True if we only should show affordable recipes in manufacturing widgets",
          "type": "boolean"
        },
        "mCollapsedItemCategories": {
          "description": "The item categories that the user have collapsed in manufacturing widgets",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mFilteredOutMapTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ERepresentationType"
          }
        },
        "mFilteredOutCompassTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ERepresentationType"
          }
        },
        "mLastSelectedResourceSinkShopCategory": {
          "description": "The last selected category in the resource sink shop so we can open the shop at the same category later",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "BuildableConstructedDelegate",
        "mCollapsedItemCategories",
        "mDefaultRecipeShortcuts",
        "mFilteredOutCompassTypes",
        "mFilteredOutMapTypes",
        "mHasReceivedInitialItems",
        "mHasSetupDefaultShortcuts",
        "mHotbarShortcuts",
        "mIsServerAdmin",
        "mLastSelectedResourceSinkShopCategory",
        "mMessageData",
        "mNewRecipes",
        "mNumArmSlots",
        "mOnlyShowAffordableRecipes",
        "mOwnedPawn",
        "mRememberedFirstTimeEquipmentClasses",
        "mSlotData",
        "mSlotNum",
        "mTutorialSubsystem",
        "mTutorialSubsystemClass"
      ]
    },
    "UFGHotbarShortcut": {
      "type": "object"
    },
    "FSlotData": {
      "type": "object",
      "properties": {
        "PingColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The color of the players ping"
        },
        "NametagColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The color of the players nametag above their head, and in the UI"
        }
      },
      "required": [
        "NametagColor",
        "PingColor"
      ]
    },
    "UFGTutorialSubsystem": {
      "type": "object",
      "properties": {
        "mBuildingsBuilt": {
          "description": "classes of things we have build",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mHasSeenIntroTutorial": {
          "description": "Used to indicate if we should push the intro messages",
          "type": "boolean"
        },
        "mIntroTutorialMessages": {
          "description": "Messages to display when first starting the game",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mTutorialData": {
          "description": "In this array we specify what buildings we want in-game tutorial for",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTutorialData"
          }
        },
        "mOwningPlayerState": {
          "$ref": "#/definitions/AFGPlayerState",
          "description": "Needed to set up delegates"
        }
      },
      "required": [
        "mBuildingsBuilt",
        "mHasSeenIntroTutorial",
        "mIntroTutorialMessages",
        "mOwningPlayerState",
        "mTutorialData"
      ]
    },
    "FTutorialData": {
      "type": "object",
      "properties": {
        "ClassBuilt": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "MessageID": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "ClassBuilt",
        "MessageID"
      ]
    },
    "FMessageData": {
      "type": "object",
      "properties": {
        "WasRead": {
          "description": "Has message been read",
          "type": "boolean"
        },
        "MessageClass": {
          "description": "What class is the message",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "MessageClass",
        "WasRead"
      ]
    },
    "FFluidBox": {
      "type": "object"
    },
    "UFGReplicationDetailInventoryComponent": {
      "type": "object"
    },
    "UFGColoredInstanceMeshProxy": {
      "type": "object",
      "properties": {
        "mCanBecolored": {
          "type": "boolean"
        },
        "mBlockInstancing": {
          "type": "boolean"
        }
      },
      "required": [
        "mBlockInstancing",
        "mCanBecolored"
      ]
    },
    "FFoundationSideSelectionFlags": {
      "description": "Disable snapping on specific sides.",
      "type": "object",
      "properties": {
        "Front": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Right": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Back": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Left": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Top": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Bottom": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "Back",
        "Bottom",
        "Front",
        "Left",
        "Right",
        "Top"
      ]
    },
    "AFGBuildableTradingPost": {
      "type": "object",
      "properties": {
        "mDefaultGeneratorRecipe": {
          "description": "Class of generators to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mGenerators": {
          "description": "References to the created generators",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableGenerator"
          }
        },
        "mDefaultStorageRecipe": {
          "description": "Class of storage to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultHubTerminalRecipe": {
          "description": "Class of hub terminal to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultWorkBenchRecipe": {
          "description": "Class of work bench to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStorage": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "References to the created storage"
        },
        "mHubTerminal": {
          "$ref": "#/definitions/AFGBuildableHubTerminal",
          "description": "References to the created Hub Terminal"
        },
        "mWorkBench": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "References to the created work bench"
        },
        "mGeneratorVisibilityLevels": {
          "description": "Arrays containing ints for what level  we should activate/show the generator",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mStorageInventorySize": {
          "description": "Size of the storage box",
          "type": "number"
        },
        "mStorageVisibilityLevel": {
          "description": "At what trading post level should the storage be visible",
          "type": "number"
        },
        "mInputInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "Our input inventory where items are stored before put on ship"
        },
        "mSpawningGroundZOffset": {
          "description": "How far above the ground the spawn-points should be adjusted",
          "type": "number"
        },
        "mGroundSearchZDistance": {
          "description": "How much up and down we should search for the ground around all child actors that's spawning AFGPlayerStartTradingPost",
          "type": "number"
        },
        "mSchematicManager": {
          "$ref": "#/definitions/AFGSchematicManager",
          "description": "A cached schematic manager"
        },
        "mStorageInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in."
        },
        "mDefaultResources": {
          "description": "The starting resources in the tradingpost storage",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mGenerator1Location": {
          "description": "Component used to determine generators location"
        },
        "mGenerator2Location": {
          "description": "Component used to determine generators location"
        },
        "mStorageLocation": {
          "description": "Component used to determine storage location"
        },
        "mHubTerminalLocation": {
          "description": "Component used to determine Hub terminal location"
        },
        "mWorkBenchLocation": {
          "description": "Component used to determine work bench terminal location"
        },
        "mNeedPlayingBuildEffectNotification": {
          "description": "Bool to sync playing of build and upgrade effects",
          "type": "boolean"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDefaultGeneratorRecipe",
        "mDefaultHubTerminalRecipe",
        "mDefaultResources",
        "mDefaultStorageRecipe",
        "mDefaultWorkBenchRecipe",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mGenerator1Location",
        "mGenerator2Location",
        "mGeneratorVisibilityLevels",
        "mGenerators",
        "mGroundSearchZDistance",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mHubTerminal",
        "mHubTerminalLocation",
        "mInputInventory",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNeedPlayingBuildEffectNotification",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSchematicManager",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mSpawningGroundZOffset",
        "mStorage",
        "mStorageInventory",
        "mStorageInventorySize",
        "mStorageLocation",
        "mStorageVisibilityLevel",
        "mTimeSinceStartStopProducing",
        "mWorkBench",
        "mWorkBenchLocation"
      ]
    },
    "AFGBuildableGenerator": {
      "type": "object",
      "properties": {
        "mPowerProduction": {
          "description": "Amount of power this generator produces in MW.",
          "type": "number"
        },
        "mPowerProductionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mLoadPercentage": {
          "description": "Current load of this generator in the range [0,1].",
          "type": "number"
        },
        "mIsFuseTriggered": {
          "description": "Is the fuse triggered.",
          "type": "boolean"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsFuseTriggered",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mLoadPercentage",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPowerProduction",
        "mPowerProductionExponent",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableHubTerminal": {
      "type": "object",
      "properties": {
        "mTradingPost": {
          "$ref": "#/definitions/AFGBuildableTradingPost"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mTradingPost"
      ]
    },
    "AFGSchematicManager": {
      "type": "object",
      "properties": {
        "PurchasedSchematicDelegate": {
          "description": "Called when we players are granted a schematic."
        },
        "PaidOffOnSchematicDelegate": {
          "description": "Called when a payment on a schematic occurs"
        },
        "mAllSchematics": {
          "description": "All schematic assets that have been sucked up in the PopulateSchematicsList function. Contains cheats and all sort of schematic.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mAvailableSchematics": {
          "description": "All schematics that are available to the player",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mPurchasedSchematics": {
          "description": "Once schematic is purchased it ends up here",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mPaidOffSchematic": {
          "description": "This keeps track of what players have paid off on different schematics",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSchematicCost"
          }
        },
        "mActiveSchematic": {
          "description": "The active schematic the resources is being sold towards.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mOnActiveSchematicChanged": {
          "description": "Called when we the schematic has been changed ."
        },
        "mShipLandTimeStamp": {
          "description": "Time stamp for when the ship is gonna land back at the Trading Post.",
          "type": "number"
        },
        "mShipLandTimeStampSave": {
          "description": "Used to save the ship land timestamp",
          "type": "number"
        },
        "mHasTechTierLimit": {
          "type": "boolean"
        },
        "mMaxAllowedTechTier": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mShipReturnedMessage": {
          "description": "Message sent when trading post ship has returned",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "PaidOffOnSchematicDelegate",
        "PurchasedSchematicDelegate",
        "mActiveSchematic",
        "mAllSchematics",
        "mAvailableSchematics",
        "mHasTechTierLimit",
        "mMaxAllowedTechTier",
        "mOnActiveSchematicChanged",
        "mPaidOffSchematic",
        "mPurchasedSchematics",
        "mShipLandTimeStamp",
        "mShipLandTimeStampSave",
        "mShipReturnedMessage"
      ]
    },
    "FSchematicCost": {
      "description": "Holds info about a schematic and How much has been paid of on it.",
      "type": "object",
      "properties": {
        "Schematic": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ItemCost": {
          "description": "Amount paid off",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        }
      },
      "required": [
        "ItemCost",
        "Schematic"
      ]
    },
    "FQuantizedPipelineIndicatorData": {
      "type": "object",
      "properties": {
        "PackedFlow": {
          "description": "See setters for how this data is packed.",
          "type": "number"
        },
        "PackedContent": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "PackedContent",
        "PackedFlow"
      ]
    },
    "FStringPair": {
      "type": "object",
      "properties": {
        "WwiseSafeName": {
          "type": "string"
        },
        "ActualName": {
          "type": "string"
        }
      },
      "required": [
        "ActualName",
        "WwiseSafeName"
      ]
    },
    "FQuantizedPumpIndicatorData": {
      "type": "object",
      "properties": {
        "PackedFlow": {
          "description": "See setters for how this data is packed.",
          "type": "number"
        },
        "PackedPressure": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "PackedFlow",
        "PackedPressure"
      ]
    },
    "FQuantizedReservoirIndicatorData": {
      "type": "object",
      "properties": {
        "PackedFlowFill": {
          "description": "See setters for how this data is packed.",
          "type": "number"
        },
        "PackedFlowDrain": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "PackedContent": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "PackedContent",
        "PackedFlowDrain",
        "PackedFlowFill"
      ]
    },
    "UFGPowerConnectionComponent": {
      "type": "object",
      "properties": {
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent"
        },
        "mMaxNumConnectionLinks": {
          "description": "How many connections this component can have connected.",
          "type": "number"
        },
        "mIsHiddenConnection": {
          "description": "This connection is hidden and can only be connected through the code. E.g. powered walls have a hidden connection all machines connect to.",
          "type": "boolean"
        },
        "mWires": {
          "description": "The wired connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableWire"
          }
        },
        "mNbWiresConnected": {
          "description": "The wired connections to this.",
          "type": "number"
        },
        "mHiddenConnections": {
          "description": "The non-wired (if this or the other is hidden) connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuitConnectionComponent"
          }
        },
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        }
      },
      "required": [
        "mCircuitID",
        "mHiddenConnections",
        "mIsHiddenConnection",
        "mMaxNumConnectionLinks",
        "mNbWiresConnected",
        "mPowerInfo",
        "mWires"
      ]
    },
    "AFGBuildableWire": {
      "type": "object",
      "properties": {
        "mMaxLength": {
          "description": "Maximum length a wire may be. [cm]",
          "type": "number"
        },
        "mLengthPerCost": {
          "description": "How much length we get per unit cost, 0 to disable per length cost. [cm]",
          "type": "number"
        },
        "mWireMesh": {
          "description": "Mesh used to visualize the power line"
        },
        "mConnections": {
          "description": "Reference to an instance of a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLocations": {
          "$ref": "#/definitions/Vector",
          "description": "The two locations this wire span."
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnections",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mLengthPerCost",
        "mLocations",
        "mMaterialNameToInstanceManager",
        "mMaxLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mWireMesh"
      ]
    },
    "UFGCircuitConnectionComponent": {
      "type": "object",
      "properties": {
        "mMaxNumConnectionLinks": {
          "description": "How many connections this component can have connected.",
          "type": "number"
        },
        "mIsHiddenConnection": {
          "description": "This connection is hidden and can only be connected through the code. E.g. powered walls have a hidden connection all machines connect to.",
          "type": "boolean"
        },
        "mWires": {
          "description": "The wired connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableWire"
          }
        },
        "mNbWiresConnected": {
          "description": "The wired connections to this.",
          "type": "number"
        },
        "mHiddenConnections": {
          "description": "The non-wired (if this or the other is hidden) connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuitConnectionComponent"
          }
        },
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        }
      },
      "required": [
        "mCircuitID",
        "mHiddenConnections",
        "mIsHiddenConnection",
        "mMaxNumConnectionLinks",
        "mNbWiresConnected",
        "mWires"
      ]
    },
    "UFGSplineComponent": {
      "type": "object",
      "properties": {
        "mSplineMesh": {
          "description": "The mesh to repeat on curved sections.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSplineMeshLength": {
          "description": "The size of each spline mesh.",
          "type": "number"
        },
        "mGenerateCollisions": {
          "description": "Spacing between the collision components.",
          "type": "boolean"
        },
        "mCollisionSpacing": {
          "description": "Spacing between the collision components.",
          "type": "number"
        },
        "mCollisionExtent": {
          "$ref": "#/definitions/Vector",
          "description": "Extent of the collision components. X is forward."
        },
        "mCollisionOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Offset of the collision components. X is forward."
        },
        "mOverrideMaterial": {
          "description": "The cached material, we cache this as the number of meshes grow/shrink as we drag the conveyor belt."
        },
        "mUseInstancing": {
          "description": "Whether to use instancing or not.",
          "type": "boolean"
        },
        "mSplineMeshComponents": {
          "description": "The meshes that make up the spline.",
          "type": "array",
          "items": {}
        },
        "mCustomDepthSplineMeshComponents": {
          "description": "If we have enabled custom depth pass, then we store the custom depth spline meshes here",
          "type": "array",
          "items": {}
        },
        "mSplineMeshInstances": {
          "description": "The meshes that make up the spline when instanced."
        },
        "mCustomDepthSplineMeshInstances": {
          "description": "If we have enabled custom depth pass, this will be non-null"
        },
        "mSplineCollisionComponents": {
          "description": "The collisions that make up the spline.",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "mCollisionExtent",
        "mCollisionOffset",
        "mCollisionSpacing",
        "mCustomDepthSplineMeshComponents",
        "mCustomDepthSplineMeshInstances",
        "mGenerateCollisions",
        "mOverrideMaterial",
        "mSplineCollisionComponents",
        "mSplineMesh",
        "mSplineMeshComponents",
        "mSplineMeshInstances",
        "mSplineMeshLength",
        "mUseInstancing"
      ]
    },
    "AFGTrainStationIdentifier": {
      "type": "object",
      "properties": {
        "mStation": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "The station this info represents."
        },
        "mTrackGraphID": {
          "description": "The track this station is on.",
          "type": "number"
        },
        "mStationName": {
          "description": "Cached here for clients.",
          "type": "string"
        }
      },
      "required": [
        "mStation",
        "mStationName",
        "mTrackGraphID"
      ]
    },
    "AFGBuildableRailroadStation": {
      "type": "object",
      "properties": {
        "mStationIdentifier": {
          "$ref": "#/definitions/AFGTrainStationIdentifier",
          "description": "Light weight representation about this station, the railroad subsystem is responsible for this."
        },
        "mDockedPlatformList": {
          "description": "When docked, this station will fill this array with every potential platform in its tail. 1 for each train segment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableTrainPlatform"
          }
        },
        "mDockingLocomotive": {
          "$ref": "#/definitions/AFGLocomotive",
          "description": "Reference to the docked locomotive."
        },
        "mRailroadTrack": {
          "$ref": "#/definitions/AFGBuildableRailroadTrack"
        },
        "mPlatformConnections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGTrainPlatformConnection"
          }
        },
        "mPlatformConnection0": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mPlatformConnection1": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mDockedRailroadVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle"
        },
        "mStationDockingMaster": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "Stores a reference to the station that initiated a docking sequence. Used to notify the station that we have completed"
        },
        "mIsOrientationReversed": {
          "description": "Is this platform reversed from its attached station?",
          "type": "boolean"
        },
        "mPlatformDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "Where are we in the docking status. Updated by the mDockingSequenceTimer which is set by NotifyTrainDocked"
        },
        "mSavedDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "However since it also drives the anim blueprint undesired anim starts are triggered if we save / modify the actually used mPlatformDockingStatus"
        },
        "mDockingSequenceTimerHandle": {
          "description": "Timer handle that is set and retriggered over the course of a docking sequence"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDockedPlatformList",
        "mDockedRailroadVehicle",
        "mDockingLocomotive",
        "mDockingSequenceTimerHandle",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsOrientationReversed",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPlatformConnection0",
        "mPlatformConnection1",
        "mPlatformConnections",
        "mPlatformDockingStatus",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mRailroadTrack",
        "mReplicationDetailActor",
        "mSavedDockingStatus",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mStationDockingMaster",
        "mStationIdentifier",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableTrainPlatform": {
      "type": "object",
      "properties": {
        "mRailroadTrack": {
          "$ref": "#/definitions/AFGBuildableRailroadTrack"
        },
        "mPlatformConnections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGTrainPlatformConnection"
          }
        },
        "mPlatformConnection0": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mPlatformConnection1": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mDockedRailroadVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle"
        },
        "mStationDockingMaster": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "Stores a reference to the station that initiated a docking sequence. Used to notify the station that we have completed"
        },
        "mIsOrientationReversed": {
          "description": "Is this platform reversed from its attached station?",
          "type": "boolean"
        },
        "mPlatformDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "Where are we in the docking status. Updated by the mDockingSequenceTimer which is set by NotifyTrainDocked"
        },
        "mSavedDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "However since it also drives the anim blueprint undesired anim starts are triggered if we save / modify the actually used mPlatformDockingStatus"
        },
        "mDockingSequenceTimerHandle": {
          "description": "Timer handle that is set and retriggered over the course of a docking sequence"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDockedRailroadVehicle",
        "mDockingSequenceTimerHandle",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsOrientationReversed",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPlatformConnection0",
        "mPlatformConnection1",
        "mPlatformConnections",
        "mPlatformDockingStatus",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mRailroadTrack",
        "mReplicationDetailActor",
        "mSavedDockingStatus",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mStationDockingMaster",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableRailroadTrack": {
      "type": "object",
      "properties": {
        "mMesh": {
          "description": "Mesh to use for his track.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this track",
          "type": "number"
        },
        "mSplineComponent": {
          "description": "The spline component for this train track."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mSplineData": {
          "description": "Spline data saved in a compact form for saving and replicating. All the vectors are in local space.",
          "type": "array",
          "items": {}
        },
        "mConnections": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "This tracks connection component."
        },
        "mIsOwnedByPlatform": {
          "description": "Was this track created and is owned by a platform.",
          "type": "boolean"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnections",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsOwnedByPlatform",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSplineComponent",
        "mSplineData"
      ]
    },
    "UFGRailroadTrackConnectionComponent": {
      "type": "object",
      "properties": {
        "mRailRoadSwitchDelegate": {
          "description": "Delegate to fire when changing switch on a track"
        },
        "mConnectedComponents": {
          "description": "The components we're connected to. If >1 this is a switch.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGRailroadTrackConnectionComponent"
          }
        },
        "mSwitchPosition": {
          "description": "If this is a switch, this is the switch position.",
          "type": "number"
        },
        "mSwitchControl": {
          "$ref": "#/definitions/AFGBuildableRailroadSwitchControl",
          "description": "The switch control associated with this connection, if any."
        },
        "mStation": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "The station associated with this connection, if any."
        },
        "mSignal": {
          "$ref": "#/definitions/AFGBuildableRailroadSignal",
          "description": "The signal associated with this connection, if any."
        }
      },
      "required": [
        "mConnectedComponents",
        "mRailRoadSwitchDelegate",
        "mSignal",
        "mStation",
        "mSwitchControl",
        "mSwitchPosition"
      ]
    },
    "AFGBuildableRailroadSwitchControl": {
      "type": "object",
      "properties": {
        "mControlledConnection": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "Connection we control."
        },
        "mSwitchPosition": {
          "description": "Current switch position read from the controlled connection, polled each tick.",
          "type": "number"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mControlledConnection",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mSwitchPosition",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableRailroadSignal": {
      "type": "object",
      "properties": {
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect"
      ]
    },
    "UFGTrainPlatformConnection": {
      "type": "object",
      "properties": {
        "mComponentDirection": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mPlatformConnectionStatus": {
          "$ref": "#/definitions/ETrainPlatformConnectionType",
          "description": "Enum indicating the status of this connection"
        },
        "platformOwner": {
          "$ref": "#/definitions/AFGBuildableTrainPlatform",
          "description": "store a reference to the owner of this connection as a FGBuildableTrainPlatform, not a UProperty as this is our Owning actor cached so we don't need to keep casting"
        },
        "mRailroadTrackConnection": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "Stores a reference to the track connection (Not a Uproperty because the reference exists in the railroad track)"
        },
        "mConnectedTo": {
          "$ref": "#/definitions/UFGTrainPlatformConnection",
          "description": "Stores a reference to the connected platform component, if there is one (Not a UProperty as this is just a reference to an external component)"
        }
      },
      "required": [
        "mComponentDirection",
        "mConnectedTo",
        "mPlatformConnectionStatus",
        "mRailroadTrackConnection",
        "platformOwner"
      ]
    },
    "ETrainPlatformConnectionType": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "AFGRailroadVehicle": {
      "type": "object",
      "properties": {
        "mTrain": {
          "$ref": "#/definitions/AFGTrain",
          "description": "The train this vehicle is part of, updated from the railroad subsystem"
        },
        "mLength": {
          "description": "How long is this vehicle.",
          "type": "number"
        },
        "mIsOrientationReversed": {
          "description": "If this vehicle is reversed in the train formation.",
          "type": "boolean"
        },
        "mTrackPosition": {
          "$ref": "#/definitions/FRailroadTrackPosition",
          "description": "Where along the track is the train."
        },
        "mDisplayName": {
          "description": "The human readable name for this vehicle.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description for this vehicle.",
          "type": "string"
        },
        "mHologramClass": {
          "description": "Hologram to build this class with.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh": {
          "description": "The main skeletal mesh associated with this Vehicle"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mDisabledByWaterLocations": {
          "description": "If any of these locations enters water, then we are unusable",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this vehicle was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mIsSelfDriving": {
          "description": "If this vehicle is self driving.",
          "type": "boolean"
        },
        "mSelfDrivingController": {
          "description": "The AI that controls this vehicle when self-driving is activated."
        },
        "mStoredPhysicsData": {
          "description": "Saved like this, as we can't store it in serialize, as it will be killed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehiclePhysicsData"
          }
        },
        "mConstructSound": {
          "description": "Sound played when this vehicle is created"
        },
        "mIsDestructible": {
          "description": "Can this vehicle be destroyed by damage?",
          "type": "number"
        },
        "mIsSubmergedInWater": {
          "description": "If true, then we are submerged in water",
          "type": "number"
        },
        "mSubmergedAngularDamping": {
          "description": "increased angular damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedLinearDamping": {
          "description": "increased linear damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedBouyantForce": {
          "description": "upwards force applied to vehicles when underwater",
          "type": "number"
        },
        "mGasDamageType": {
          "description": "Gas damage typ that should be redirected to the driver",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the vehicle should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this vehicle should be significant within",
          "type": "number"
        },
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mAddToSignificanceManager",
        "mBuiltWithRecipe",
        "mConstructSound",
        "mDescription",
        "mDisabledByWaterLocations",
        "mDisplayName",
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mGasDamageType",
        "mHealthComponent",
        "mHologramClass",
        "mIsDestructible",
        "mIsDriverVisible",
        "mIsDriving",
        "mIsOrientationReversed",
        "mIsSelfDriving",
        "mIsSubmergedInWater",
        "mLength",
        "mMesh",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mSelfDrivingController",
        "mShouldAttachDriver",
        "mSignificanceBias",
        "mSignificanceRange",
        "mStoredPhysicsData",
        "mSubmergedAngularDamping",
        "mSubmergedBouyantForce",
        "mSubmergedLinearDamping",
        "mTrackPosition",
        "mTrain"
      ]
    },
    "AFGTrain": {
      "type": "object",
      "properties": {
        "mOnSelfDrivingChanged": {
          "description": "Called when the self driving is turn on or off."
        },
        "mOnDockingStateChanged": {
          "description": "Called when the docking state changes."
        },
        "mConsistData": {
          "$ref": "#/definitions/FTrainConsist",
          "description": "Static information about the consist, it changes when rolling stock is added/removed or a container is loaded/unloaded."
        },
        "mAtcData": {
          "$ref": "#/definitions/FTrainAtcData",
          "description": "Runtime data for the automatic train control. See struct for more info."
        },
        "mSimulationData": {
          "$ref": "#/definitions/FTrainSimulationData",
          "description": "Physics simulation for the train"
        },
        "mTrainName": {
          "description": "The name of this train.",
          "type": "string"
        },
        "mTrackGraphID": {
          "description": "The track this train is on.",
          "type": "number"
        },
        "FirstVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle",
          "description": "Train are a doubly linked list, use TTrainIterator to iterate over a train."
        },
        "LastVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle"
        },
        "mMultipleUnitMaster": {
          "$ref": "#/definitions/AFGLocomotive",
          "description": "This is the master locomotives that sends its input (throttle/brake/etc) to all other locomotives in the train."
        },
        "TimeTable": {
          "$ref": "#/definitions/AFGRailroadTimeTable",
          "description": "This trains time table."
        },
        "mIsSelfDrivingEnabled": {
          "description": "Is this train self driving",
          "type": "boolean"
        },
        "mSelfDrivingError": {
          "$ref": "#/definitions/ESelfDrivingLocomotiveError",
          "description": "Error reported by the AI."
        },
        "mDockingState": {
          "$ref": "#/definitions/ETrainDockingState",
          "description": "The status for an ongoing dock, this is not saved, it's updated from the station we're docked to on load."
        },
        "mSoundComponent": {
          "$ref": "#/definitions/UFGRailroadVehicleSoundComponent",
          "description": "Sound component controlling all the moving/idle sounds for the train"
        }
      },
      "required": [
        "FirstVehicle",
        "LastVehicle",
        "TimeTable",
        "mAtcData",
        "mConsistData",
        "mDockingState",
        "mIsSelfDrivingEnabled",
        "mMultipleUnitMaster",
        "mOnDockingStateChanged",
        "mOnSelfDrivingChanged",
        "mSelfDrivingError",
        "mSimulationData",
        "mSoundComponent",
        "mTrackGraphID",
        "mTrainName"
      ]
    },
    "FTrainConsist": {
      "type": "object",
      "properties": {
        "Vehicles": {
          "description": "The vehicles in this consist.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "Length": {
          "description": "Length of the consist, [cm]",
          "type": "number"
        },
        "Mass": {
          "description": "Mass of the consist, [kg]",
          "type": "number"
        },
        "MaxSpeed": {
          "description": "Maximum speed for the slowest vehicle in the consist. [cm/s]",
          "type": "number"
        }
      },
      "required": [
        "Length",
        "Mass",
        "MaxSpeed",
        "Vehicles"
      ]
    },
    "FTrainAtcData": {
      "type": "object"
    },
    "FTrainSimulationData": {
      "type": "object",
      "properties": {
        "SimulatedVehicles": {
          "description": "Cached vehicles in the direction of travel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGRailroadVehicle"
          }
        },
        "SimulatedMovements": {
          "description": "Cached movements in the same order as the vehicles.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGRailroadVehicleMovementComponent"
          }
        },
        "MasterMovement": {
          "$ref": "#/definitions/UFGLocomotiveMovementComponent",
          "description": "Cached master locomotive."
        },
        "Velocity": {
          "description": "Velocity of this train [directional] [cm/s]",
          "type": "number"
        }
      },
      "required": [
        "MasterMovement",
        "SimulatedMovements",
        "SimulatedVehicles",
        "Velocity"
      ]
    },
    "UFGRailroadVehicleMovementComponent": {
      "type": "object",
      "properties": {
        "mWheelsetSetups": {
          "description": "Wheelsets for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FWheelsetSetup"
          }
        },
        "mWheelRadius": {
          "description": "The radius of the wheels. [cm]",
          "type": "number"
        },
        "mCouplerSetups": {
          "description": "Couplers for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FCouplerSetup"
          }
        },
        "mMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxVelocity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPayloadMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mDragCoefficient": {
          "description": "DragCoefficient of the vehicle chassis. Good values [0.4, 0.8].",
          "type": "number"
        },
        "mChassisWidth": {
          "description": "Chassis width used for drag force computation. [cm]",
          "type": "number"
        },
        "mChassisHeight": {
          "description": "Chassis height used for drag force computation. [cm]",
          "type": "number"
        },
        "mRollingResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along the track. Good values [0.0010, 0.0024].",
          "type": "number"
        },
        "mCurvatureResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along a curved track. Good values [0.0001, 0.0004].",
          "type": "number"
        },
        "mMaxAirBrakingEffort": {
          "description": "The maximum air braking force that can be delivered. [kN] [kg m/s^2\n  1000]",
          "type": "number"
        }
      },
      "required": [
        "mChassisHeight",
        "mChassisWidth",
        "mCouplerSetups",
        "mCurvatureResistanceCoefficient",
        "mDragCoefficient",
        "mMass",
        "mMaxAirBrakingEffort",
        "mMaxVelocity",
        "mPayloadMass",
        "mRollingResistanceCoefficient",
        "mWheelRadius",
        "mWheelsetSetups"
      ]
    },
    "FWheelsetSetup": {
      "type": "object",
      "properties": {
        "BoneName": {
          "description": "Bone name on mesh where the wheelset/bogie is located.",
          "type": "string"
        },
        "CanSwivel": {
          "description": "Is this wheel set a bogie.",
          "type": "boolean"
        }
      },
      "required": [
        "BoneName",
        "CanSwivel"
      ]
    },
    "FCouplerSetup": {
      "type": "object",
      "properties": {
        "BoneName": {
          "description": "Bone name on mesh where the coupler's base is attached.",
          "type": "string"
        },
        "Length": {
          "description": "How long is the couplers arm, from the bone to the point where is attaches to the other coupler.",
          "type": "number"
        }
      },
      "required": [
        "BoneName",
        "Length"
      ]
    },
    "UFGLocomotiveMovementComponent": {
      "type": "object",
      "properties": {
        "mReplicatedState": {
          "$ref": "#/definitions/FReplicatedRailroadVehicleState",
          "description": "replicated state of vehicle"
        },
        "mRawReverserInput": {
          "description": "What the player has the reverser set to. Values -1, 0, 1",
          "type": "number"
        },
        "mRawSteeringInput": {
          "description": "What the player has the steering set to. Range -1...1",
          "type": "number"
        },
        "mRawThrottleInput": {
          "description": "What the player has the accelerator set to. Range -1...1",
          "type": "number"
        },
        "mRawDynamicBrakeInput": {
          "description": "What the dynamic brake input is set to.",
          "type": "number"
        },
        "mRawAirBrakeInput": {
          "description": "What the air brake input is set to.",
          "type": "number"
        },
        "mThrottleInputRate": {
          "$ref": "#/definitions/FRailroadVehicleInputRate",
          "description": "Rate at which input throttle can rise and fall."
        },
        "mDynamicBrakeInputRate": {
          "$ref": "#/definitions/FRailroadVehicleInputRate",
          "description": "Rate at which input dynamic brake can rise and fall."
        },
        "mDynamicBrakeVelocityThreshold": {
          "description": "Velocity at which the dynamic brake can be engaged.",
          "type": "number"
        },
        "mAirBrakeInputRate": {
          "$ref": "#/definitions/FRailroadVehicleInputRate",
          "description": "Rate at which input air brake can rise and fall."
        },
        "mReverserInput": {
          "description": "Reversing control output to physics system. -1, 0, 1",
          "type": "number"
        },
        "mSteeringInput": {
          "description": "Steering output to physics system. Range -1...1",
          "type": "number"
        },
        "mThrottleInput": {
          "description": "Accelerator output to physics system. Range 0...1",
          "type": "number"
        },
        "mAirBrakeInput": {
          "description": "Air brake output to physics system. Range 0...1",
          "type": "number"
        },
        "mDynamicBrakeInput": {
          "description": "Dynamic brake output to physics system. Range 0...1",
          "type": "number"
        },
        "mTractiveEffortCurve": {
          "description": "The maximum tractive force [kN] [kg m/s^2\n  1000] that can be delivered at a given speed [km/h]."
        },
        "mDynamicBrakingEffortCurve": {
          "description": "The maximum dynamic braking force [kN] [kg m/s^2\n  1000] that can be delivered at a given speed [km/h]."
        },
        "mWheelsetSetups": {
          "description": "Wheelsets for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FWheelsetSetup"
          }
        },
        "mWheelRadius": {
          "description": "The radius of the wheels. [cm]",
          "type": "number"
        },
        "mCouplerSetups": {
          "description": "Couplers for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FCouplerSetup"
          }
        },
        "mMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxVelocity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPayloadMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mDragCoefficient": {
          "description": "DragCoefficient of the vehicle chassis. Good values [0.4, 0.8].",
          "type": "number"
        },
        "mChassisWidth": {
          "description": "Chassis width used for drag force computation. [cm]",
          "type": "number"
        },
        "mChassisHeight": {
          "description": "Chassis height used for drag force computation. [cm]",
          "type": "number"
        },
        "mRollingResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along the track. Good values [0.0010, 0.0024].",
          "type": "number"
        },
        "mCurvatureResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along a curved track. Good values [0.0001, 0.0004].",
          "type": "number"
        },
        "mMaxAirBrakingEffort": {
          "description": "The maximum air braking force that can be delivered. [kN] [kg m/s^2\n  1000]",
          "type": "number"
        }
      },
      "required": [
        "mAirBrakeInput",
        "mAirBrakeInputRate",
        "mChassisHeight",
        "mChassisWidth",
        "mCouplerSetups",
        "mCurvatureResistanceCoefficient",
        "mDragCoefficient",
        "mDynamicBrakeInput",
        "mDynamicBrakeInputRate",
        "mDynamicBrakeVelocityThreshold",
        "mDynamicBrakingEffortCurve",
        "mMass",
        "mMaxAirBrakingEffort",
        "mMaxVelocity",
        "mPayloadMass",
        "mRawAirBrakeInput",
        "mRawDynamicBrakeInput",
        "mRawReverserInput",
        "mRawSteeringInput",
        "mRawThrottleInput",
        "mReplicatedState",
        "mReverserInput",
        "mRollingResistanceCoefficient",
        "mSteeringInput",
        "mThrottleInput",
        "mThrottleInputRate",
        "mTractiveEffortCurve",
        "mWheelRadius",
        "mWheelsetSetups"
      ]
    },
    "FReplicatedRailroadVehicleState": {
      "type": "object",
      "properties": {
        "ReverserInput": {
          "description": "input replication: steering",
          "type": "number"
        },
        "SteeringInput": {
          "description": "input replication: steering",
          "type": "number"
        },
        "ThrottleInput": {
          "description": "input replication: throttle",
          "type": "number"
        },
        "DynamicBrakeInput": {
          "description": "input replication: dynamic brakes",
          "type": "number"
        },
        "AirBrakeInput": {
          "description": "input replication: air brakes",
          "type": "number"
        }
      },
      "required": [
        "AirBrakeInput",
        "DynamicBrakeInput",
        "ReverserInput",
        "SteeringInput",
        "ThrottleInput"
      ]
    },
    "FRailroadVehicleInputRate": {
      "type": "object",
      "properties": {
        "RiseRate": {
          "description": "Rate at which the input value rises",
          "type": "number"
        },
        "FallRate": {
          "description": "Rate at which the input value falls",
          "type": "number"
        }
      },
      "required": [
        "FallRate",
        "RiseRate"
      ]
    },
    "AFGLocomotive": {
      "type": "object",
      "properties": {
        "mPowerConsumption": {
          "description": "The power consumption of this electric locomotive, min is idle power consumption and max is power consumption at maximum torque."
        },
        "mSlidingShoe": {
          "$ref": "#/definitions/UFGPowerConnectionComponent",
          "description": "The sliding shoe making contact with the third rail."
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "The power info for this train, draw power from the circuit."
        },
        "mReplicatedMovementTransform": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mVehicleMovement": {
          "$ref": "#/definitions/UFGLocomotiveMovementComponent",
          "description": "vehicle simulation component"
        },
        "mTrain": {
          "$ref": "#/definitions/AFGTrain",
          "description": "The train this vehicle is part of, updated from the railroad subsystem"
        },
        "mLength": {
          "description": "How long is this vehicle.",
          "type": "number"
        },
        "mIsOrientationReversed": {
          "description": "If this vehicle is reversed in the train formation.",
          "type": "boolean"
        },
        "mTrackPosition": {
          "$ref": "#/definitions/FRailroadTrackPosition",
          "description": "Where along the track is the train."
        },
        "mDisplayName": {
          "description": "The human readable name for this vehicle.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description for this vehicle.",
          "type": "string"
        },
        "mHologramClass": {
          "description": "Hologram to build this class with.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh": {
          "description": "The main skeletal mesh associated with this Vehicle"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mDisabledByWaterLocations": {
          "description": "If any of these locations enters water, then we are unusable",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this vehicle was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mIsSelfDriving": {
          "description": "If this vehicle is self driving.",
          "type": "boolean"
        },
        "mSelfDrivingController": {
          "description": "The AI that controls this vehicle when self-driving is activated."
        },
        "mStoredPhysicsData": {
          "description": "Saved like this, as we can't store it in serialize, as it will be killed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehiclePhysicsData"
          }
        },
        "mConstructSound": {
          "description": "Sound played when this vehicle is created"
        },
        "mIsDestructible": {
          "description": "Can this vehicle be destroyed by damage?",
          "type": "number"
        },
        "mIsSubmergedInWater": {
          "description": "If true, then we are submerged in water",
          "type": "number"
        },
        "mSubmergedAngularDamping": {
          "description": "increased angular damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedLinearDamping": {
          "description": "increased linear damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedBouyantForce": {
          "description": "upwards force applied to vehicles when underwater",
          "type": "number"
        },
        "mGasDamageType": {
          "description": "Gas damage typ that should be redirected to the driver",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the vehicle should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this vehicle should be significant within",
          "type": "number"
        },
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mAddToSignificanceManager",
        "mBuiltWithRecipe",
        "mConstructSound",
        "mDescription",
        "mDisabledByWaterLocations",
        "mDisplayName",
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mGasDamageType",
        "mHealthComponent",
        "mHologramClass",
        "mIsDestructible",
        "mIsDriverVisible",
        "mIsDriving",
        "mIsOrientationReversed",
        "mIsSelfDriving",
        "mIsSubmergedInWater",
        "mLength",
        "mMesh",
        "mNetConstructionID",
        "mPowerConsumption",
        "mPowerInfo",
        "mPrimaryColor",
        "mReplicatedMovementTransform",
        "mSecondaryColor",
        "mSelfDrivingController",
        "mShouldAttachDriver",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSlidingShoe",
        "mStoredPhysicsData",
        "mSubmergedAngularDamping",
        "mSubmergedBouyantForce",
        "mSubmergedLinearDamping",
        "mTrackPosition",
        "mTrain",
        "mVehicleMovement"
      ]
    },
    "FRailroadTrackPosition": {
      "type": "object",
      "properties": {
        "Track": {
          "description": "Reference to an instance of a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Offset": {
          "description": "Offset along the track.",
          "type": "number"
        },
        "Forward": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "Forward",
        "Offset",
        "Track"
      ]
    },
    "FVehiclePhysicsData": {
      "description": "Physics data we want to be able to restore, we store the bone name to be able to change the bone structure in updates",
      "type": "object"
    },
    "AFGRailroadTimeTable": {
      "type": "object",
      "properties": {
        "mStops": {
          "description": "Array of destinations this train will visit.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTimeTableStop"
          }
        },
        "mCurrentStop": {
          "description": "Current stop the train is at or heading to.",
          "type": "number"
        }
      },
      "required": [
        "mCurrentStop",
        "mStops"
      ]
    },
    "FTimeTableStop": {
      "type": "object",
      "properties": {
        "Station": {
          "$ref": "#/definitions/AFGTrainStationIdentifier",
          "description": "Where to stop."
        },
        "Duration": {
          "description": "Time to stay.",
          "type": "number"
        }
      },
      "required": [
        "Duration",
        "Station"
      ]
    },
    "ESelfDrivingLocomotiveError": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "ETrainDockingState": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "UFGRailroadVehicleSoundComponent": {
      "type": "object",
      "properties": {
        "mVehicleMovementComponent": {
          "$ref": "#/definitions/UFGRailroadVehicleMovementComponent",
          "description": "Movement component of the first vehicle in the train."
        },
        "mLocomotiveMovementComponent": {
          "$ref": "#/definitions/UFGLocomotiveMovementComponent",
          "description": "Movement component of the first locomotive in the train, may be none."
        },
        "mTrainOwner": {
          "$ref": "#/definitions/AFGTrain",
          "description": "train that owns this component"
        },
        "mWheelsetsAkComponent": {
          "description": "Component to play events on the wheelsets. Location is the bogie bone."
        },
        "mEnginesAkComponent": {
          "description": "Component to play events on the locomotives. Location is the center of the actor bounds (colliding)."
        },
        "mAllVehicleCentersAkComponent": {
          "description": "Component to play events on all the locomotives and wagons. Location is the center of the actor bounds (colliding)."
        }
      },
      "required": [
        "mAllVehicleCentersAkComponent",
        "mEnginesAkComponent",
        "mLocomotiveMovementComponent",
        "mTrainOwner",
        "mVehicleMovementComponent",
        "mWheelsetsAkComponent"
      ]
    },
    "ETrainPlatformDockingStatus": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "AFGResourceSinkSubsystem": {
      "type": "object",
      "properties": {
        "mSchematicManager": {
          "$ref": "#/definitions/AFGSchematicManager",
          "description": "The cached schematic manager"
        },
        "mCouponClass": {
          "description": "The coupon class that we use for buying resource sink schematics",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mTotalResourceSinkPoints": {
          "description": "The total number of resource sink points we have accumulated in total"
        },
        "mCurrentPointLevel": {
          "description": "The current point level we have reached, this value only increases and isn't not affected by printing coupons",
          "type": "number"
        },
        "mNumResourceSinkCoupons": {
          "description": "The number of coupons we have to our disposal to print and use",
          "type": "number"
        },
        "mGlobalPointHistory": {
          "description": "The data for the global points history of the resource sink subsystem",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mResourceSinkPoints": {
          "$ref": "#/definitions/Map<packageReference<UFGItemDescriptor>,number>",
          "description": "Cached points per itemdescriptor"
        },
        "mFailedItemSinkMessages": {
          "$ref": "#/definitions/Map<packageReference<UFGItemDescriptor>,packageReference<UFGMessageBase>>",
          "description": "The messages that should play if the player tries to sink a item that you can't sink"
        },
        "mItemsFailedToSink": {
          "description": "The items that the player tried to sink that you can't sink that is also present in mFailedItemSinkMessages",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mAnyGenericItemsFailedToSink": {
          "description": "Have we ever tried to sink any item that you can't sink that is not present in mFailedItemSinkMessages",
          "type": "boolean"
        },
        "mIsCouponEverSunk": {
          "description": "Have we sunken a item of the coupon class, Used to give a schematic",
          "type": "boolean"
        }
      },
      "required": [
        "mAnyGenericItemsFailedToSink",
        "mCouponClass",
        "mCurrentPointLevel",
        "mFailedItemSinkMessages",
        "mGlobalPointHistory",
        "mIsCouponEverSunk",
        "mItemsFailedToSink",
        "mNumResourceSinkCoupons",
        "mResourceSinkPoints",
        "mSchematicManager",
        "mTotalResourceSinkPoints"
      ]
    },
    "Map<packageReference<UFGItemDescriptor>,number>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<packageReference<UFGItemDescriptor>,packageReference<UFGMessageBase>>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGRoadConnectionComponent": {
      "type": "object"
    },
    "FSignWallData": {
      "type": "object",
      "properties": {
        "TextColorIndex": {
          "description": "Index of the selected color for the text from the FGSignSettings color data array",
          "type": "number"
        },
        "BackgroundColorIndex": {
          "description": "Index of the selected color for the background from the FGSignSettings color data array",
          "type": "number"
        },
        "SignText": {
          "description": "Text to be displayed on the sign",
          "type": "string"
        }
      },
      "required": [
        "BackgroundColorIndex",
        "SignText",
        "TextColorIndex"
      ]
    },
    "AFGGamePhaseManager": {
      "type": "object",
      "properties": {
        "mGamePhase": {
          "$ref": "#/definitions/EGamePhase",
          "description": "Current GamePhase"
        },
        "mGamePhaseTierInfo": {
          "description": "Specifies what game phases are connected to what tiers",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPhaseTierInfo"
          }
        },
        "mGamePhaseCosts": {
          "description": "Speciefies what the different tiers cost",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPhaseCost"
          }
        },
        "mOnGamePhaseChanged": {
          "description": "Called when the game phase is updated"
        }
      },
      "required": [
        "mGamePhase",
        "mGamePhaseCosts",
        "mGamePhaseTierInfo",
        "mOnGamePhaseChanged"
      ]
    },
    "EGamePhase": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "FPhaseTierInfo": {
      "type": "object",
      "properties": {
        "GamePhase": {
          "$ref": "#/definitions/EGamePhase",
          "description": "The phase to specify tier for"
        },
        "LastTierOfPhase": {
          "description": "What is the last tier of the phase specified previously.",
          "type": "number"
        },
        "Name": {
          "description": "Name of this phase.",
          "type": "string"
        },
        "PhaseUnlockedMessage": {
          "description": "Message sent when this phase is unlocked",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "GamePhase",
        "LastTierOfPhase",
        "Name",
        "PhaseUnlockedMessage"
      ]
    },
    "FPhaseCost": {
      "type": "object",
      "properties": {
        "GamePhase": {
          "$ref": "#/definitions/EGamePhase",
          "description": "The phase to specify the cost for"
        },
        "Cost": {
          "description": "Cost of this tier",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        }
      },
      "required": [
        "Cost",
        "GamePhase"
      ]
    },
    "FSplitterSortRule": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "This is the item class to filter out.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "OutputIndex": {
          "description": "Which output to send this to.",
          "type": "number"
        }
      },
      "required": [
        "ItemClass",
        "OutputIndex"
      ]
    },
    "Map<number,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "FSignElementConstraints": {
      "type": "object",
      "properties": {
        "MinTranslationOffset": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "MaxTranslationOffset": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "MinScale": {
          "description": "A floating point number.",
          "type": "number"
        },
        "MaxScale": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "MaxScale",
        "MaxTranslationOffset",
        "MinScale",
        "MinTranslationOffset"
      ]
    },
    "FSignData": {
      "type": "object",
      "properties": {
        "SignLayers": {
          "description": "All additional layers in this sign. Each layer holds an array of all elements in that layer",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignLayer"
          }
        },
        "SignElementData": {
          "description": "All sign elements in this sign",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignElementData"
          }
        },
        "BackgroundColorIndex": {
          "description": "Index of the selected color for the background from the FGSignSettings color data array",
          "type": "number"
        }
      },
      "required": [
        "BackgroundColorIndex",
        "SignElementData",
        "SignLayers"
      ]
    },
    "UFGSignLayer": {
      "type": "object",
      "properties": {
        "mLayerID": {
          "description": "Layer index, used to determine sorting. Layer 0 is the background layer",
          "type": "number"
        },
        "mPixelColumns": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSignPixelColumn"
          }
        },
        "mLayerElements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignElementData"
          }
        },
        "mPixelDimensions": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "mLayerElements",
        "mLayerID",
        "mPixelColumns",
        "mPixelDimensions"
      ]
    },
    "FSignPixelColumn": {
      "type": "object",
      "properties": {
        "Column": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignPixelData"
          }
        }
      },
      "required": [
        "Column"
      ]
    },
    "UFGSignPixelData": {
      "type": "object",
      "properties": {
        "mDimensions": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mSignElementID": {
          "description": "unique id to identify this element by buildable signs",
          "type": "number"
        },
        "mColorIndex": {
          "description": "Index pointing to a location in the FGSignSettings Color Array",
          "type": "number"
        },
        "mTranslationOffset": {
          "description": "Position offset from center"
        },
        "mRotation": {
          "description": "Roll Rotation",
          "type": "number"
        },
        "mScale": {
          "description": "Global uniform scale factor",
          "type": "number"
        },
        "mEmbeddedInLayer": {
          "description": "If embedded, this indicates that the element should not be given its own element list widget ( tex. the background pixels in layers )",
          "type": "boolean"
        },
        "mIsElementStatic": {
          "type": "boolean"
        }
      },
      "required": [
        "mColorIndex",
        "mDimensions",
        "mEmbeddedInLayer",
        "mIsElementStatic",
        "mRotation",
        "mScale",
        "mSignElementID",
        "mTranslationOffset"
      ]
    },
    "UFGSignElementData": {
      "type": "object",
      "properties": {
        "mSignElementID": {
          "description": "unique id to identify this element by buildable signs",
          "type": "number"
        },
        "mColorIndex": {
          "description": "Index pointing to a location in the FGSignSettings Color Array",
          "type": "number"
        },
        "mTranslationOffset": {
          "description": "Position offset from center"
        },
        "mRotation": {
          "description": "Roll Rotation",
          "type": "number"
        },
        "mScale": {
          "description": "Global uniform scale factor",
          "type": "number"
        },
        "mEmbeddedInLayer": {
          "description": "If embedded, this indicates that the element should not be given its own element list widget ( tex. the background pixels in layers )",
          "type": "boolean"
        },
        "mIsElementStatic": {
          "type": "boolean"
        }
      },
      "required": [
        "mColorIndex",
        "mEmbeddedInLayer",
        "mIsElementStatic",
        "mRotation",
        "mScale",
        "mSignElementID",
        "mTranslationOffset"
      ]
    },
    "AFGBuildableConveyorAttachment": {
      "type": "object",
      "properties": {
        "mBufferInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBufferInventory",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "Map<packageReference<any>,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<packageReference<any>,UFGColoredInstanceManager>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Color": {
      "description": "[FColor](API\\Runtime\\Core\\Math\\FColor) Stores a color with 8 bits of precision per channel.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FColor/index.html",
      "type": "object",
      "properties": {
        "R": {
          "description": "The color's red intensity.",
          "type": "number"
        },
        "G": {
          "description": "The color's green intensity.",
          "type": "number"
        },
        "B": {
          "description": "The color's blue intensity.",
          "type": "number"
        },
        "A": {
          "description": "The color's opacity.",
          "type": "number"
        }
      },
      "required": [
        "A",
        "B",
        "G",
        "R"
      ]
    },
    "FDistanceBasedTickRate": {
      "description": "Distances where we switch tick rate",
      "type": "object",
      "properties": {
        "Distance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "TickRate": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "Distance",
        "TickRate"
      ]
    },
    "EFreightCargoType": {
      "description": "Enum to track the two types of cargo (Standard and Liquid)",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "AFGPipeBuilderTrail": {
      "type": "object",
      "properties": {
        "mPipesToTraverse": {
          "description": "Saved pipelines we have to traverse",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildablePipeline"
          }
        },
        "mCurrentPipeline": {
          "$ref": "#/definitions/AFGBuildablePipeline",
          "description": "Pipeline we are currently traversing"
        },
        "mSpline": {
          "description": "Cached spline to traverse"
        },
        "mSpeed": {
          "description": "How long it should take for trail to complete the spline movement in seconds",
          "type": "number"
        }
      },
      "required": [
        "mCurrentPipeline",
        "mPipesToTraverse",
        "mSpeed",
        "mSpline"
      ]
    },
    "AFGBuildablePipeline": {
      "type": "object",
      "properties": {
        "mRadius": {
          "description": "Inner Radius of this pipe. Used for flow calculations. [cm]",
          "type": "number"
        },
        "mFlowLimit": {
          "description": "Maximum flow through this pipe in cubic meters. [m^3/s]",
          "type": "number"
        },
        "mFlowIndicatorClass": {
          "description": "Type of indicator to spawn on this pipe.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFlowIndicatorMinimumPipeLength": {
          "description": "Smaller pipes than this will not get a flow indicator. [cm]",
          "type": "number"
        },
        "mSoundSplineComponent": {
          "$ref": "#/definitions/UFGSoundSplineComponent"
        },
        "mSplineAudioEvent": {
          "description": "The ak event to post for the sound spline"
        },
        "mPipeConnections": {
          "description": "Cached array of pipe connections.",
          "type": "array",
          "items": {}
        },
        "mFluidBox": {
          "$ref": "#/definitions/FFluidBox",
          "description": "Simulation data."
        },
        "mIndicatorData": {
          "$ref": "#/definitions/FQuantizedPipelineIndicatorData",
          "description": "Quantized data used by the indicators."
        },
        "mMaxIndicatorTurnAngle": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mCachedFluidDescriptor": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mIgnoreActorsForIndicator": {
          "description": "Array of objects to ignore when performing the collision check in the indicator placement. This is needed during merge / split creation of new pipelines",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mFluidNames": {
          "description": "struct with both wwise safe names and their item names",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FStringPair"
          }
        },
        "mCurrentFluid": {
          "description": "current fluid that is in the pipe",
          "type": "string"
        },
        "mQuantiziedContent": {
          "description": "how filled is the pipe",
          "type": "number"
        },
        "mQuantiziedFlow": {
          "description": "flow rate in the pipe",
          "type": "number"
        },
        "mRattleLimit": {
          "description": "at what flow should we play rattle",
          "type": "number"
        },
        "mIsRattling": {
          "description": "are we playing rattling sound?",
          "type": "boolean"
        },
        "mStartRattleSoundEvent": {
          "description": "Start rattle sound"
        },
        "mStopRattleSoundEvent": {
          "description": "Stop rattle sound"
        },
        "mMesh": {
          "description": "Mesh to use for his conveyor.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this conveyor.",
          "type": "number"
        },
        "mConnection0": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mConnection1": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mSplineData": {
          "description": "Compact representation of mSplineComponent, used for replication and save game",
          "type": "array",
          "items": {}
        },
        "mSplineComponent": {
          "description": "The spline component for this splined factory."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedFluidDescriptor",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mCurrentFluid",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mFlowIndicatorClass",
        "mFlowIndicatorMinimumPipeLength",
        "mFlowLimit",
        "mFluidBox",
        "mFluidNames",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mIgnoreActorsForIndicator",
        "mIndicatorData",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsRattling",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxIndicatorTurnAngle",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPipeConnections",
        "mPrimaryColor",
        "mQuantiziedContent",
        "mQuantiziedFlow",
        "mRadius",
        "mRattleLimit",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSoundSplineComponent",
        "mSplineAudioEvent",
        "mSplineComponent",
        "mSplineData",
        "mStartRattleSoundEvent",
        "mStopRattleSoundEvent"
      ]
    },
    "EGuideLineType": {
      "enum": [
        0,
        1
      ],
      "type": "number"
    },
    "AFGC4Explosive": {
      "type": "object",
      "properties": {
        "mBaseDamage": {
          "description": "Base damage used for the radial apply damage",
          "type": "number"
        },
        "mDamageRadius": {
          "description": "Damage radius used for the radial apply damage",
          "type": "number"
        },
        "mDamageType": {
          "description": "Damage type used for the radial apply damage",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mIsDetonated": {
          "description": "Tells client to blow this shit up",
          "type": "boolean"
        }
      },
      "required": [
        "mBaseDamage",
        "mDamageRadius",
        "mDamageType",
        "mIsDetonated"
      ]
    },
    "AFGHUD": {
      "type": "object",
      "properties": {
        "mGameUIClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRespawnUIClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPickupCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mVehicleCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mWeaponCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mWorkbenchCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCustomCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mGeneralCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRespawnInputComponent": {
          "description": "Input component for blocking input during respawn"
        },
        "mRespawnUI": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mGameUI": {
          "$ref": "#/definitions/UFGGameUI"
        },
        "mPreviewBuildingWorld": {
          "description": "A world for previewing the current building"
        },
        "mPreviewStageClass": {
          "description": "Class that stages the preview building item",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPreviewActorClass": {
          "description": "The actor class we want to preview, we don't use buildable as we want to support vehicles too",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPawnHUD": {
          "description": "The latest created pawn HUD widget"
        },
        "mBaseUI": {
          "$ref": "#/definitions/UFGBaseUI",
          "description": "Reference to the UI widget"
        }
      },
      "required": [
        "mBaseUI",
        "mBuildCrosshair",
        "mCustomCrosshair",
        "mDefaultCrosshair",
        "mDismantleCrosshair",
        "mGameUI",
        "mGameUIClass",
        "mGeneralCrosshair",
        "mPawnHUD",
        "mPickupCrosshair",
        "mPreviewActorClass",
        "mPreviewBuildingWorld",
        "mPreviewStageClass",
        "mRespawnInputComponent",
        "mRespawnUI",
        "mRespawnUIClass",
        "mVehicleCrosshair",
        "mWeaponCrosshair",
        "mWorkbenchCrosshair"
      ]
    },
    "UFGGameUI": {
      "type": "object",
      "properties": {
        "mOnMouseButtonDown": {
          "description": "so if you already are listening for mouse input you might get this and your own event"
        },
        "mInteractWidgetStack": {
          "description": "A stack with widgets that are currently open",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGInteractWidget"
          }
        },
        "mCurrentAudioMessage": {
          "$ref": "#/definitions/UFGAudioMessage",
          "description": "Message that is being played now ( can be null )"
        },
        "mMinTimeBetweenAudioMessage": {
          "description": "How much time must pass between receiving audio messages at least?",
          "type": "number"
        },
        "mActivePopup": {
          "$ref": "#/definitions/UFGPopupWidget",
          "description": "Current active popup"
        }
      },
      "required": [
        "mActivePopup",
        "mCurrentAudioMessage",
        "mInteractWidgetStack",
        "mMinTimeBetweenAudioMessage",
        "mOnMouseButtonDown"
      ]
    },
    "UFGInteractWidget": {
      "type": "object",
      "properties": {
        "mUseKeyboard": {
          "description": "If we should take the keyboard input from the player. The player won't be able to move around.",
          "type": "boolean"
        },
        "mUseMouse": {
          "description": "If we should take the mouse input from the player. The player won't be able to look around.",
          "type": "boolean"
        },
        "mCaptureInput": {
          "description": "Decides if we should share input with game or capture it completely",
          "type": "boolean"
        },
        "mRestoreFocusWhenLost": {
          "description": "Decides if the widget should restore focus when it looses it. (e.g. when the user clicks outside of the widget)",
          "type": "boolean"
        },
        "mInputToPassThrough": {
          "description": "There need to be a clear hierarchy of how input is handled and what to pass and not pass and if the default is pass all or pass none.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDesiredHorizontalAlignment": {
          "description": "Our desired horizontal alignment"
        },
        "mDesiredVerticalAlignment": {
          "description": "Our desired vetical alignment"
        },
        "mDesiredAlignmentSize": {
          "description": "Our desired horizontal size"
        },
        "mInteractObject": {
          "$ref": "#/definitions/UObject",
          "description": "Object that we interacted with in order to show this widget ( can be nullPeter )"
        },
        "mDefaultFocusWidgetClass": {
          "description": "Class of the default widget we want to give focus to",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseGamepadCursor": {
          "description": "Should gamepad act as cursor when using this widget?",
          "type": "boolean"
        },
        "mCustomTickRate": {
          "description": "The rate for the timer that triggers the custom tick. If <= 0.f no timer will be started",
          "type": "number"
        },
        "mCallCustomTickOnConstruct": {
          "description": "True if the custom tick event be called on construct. If <= 0.f no event will be triggered",
          "type": "boolean"
        },
        "mDefaultFocusWidget": {
          "description": "Used to give focus to an object when nothing else has focus"
        },
        "mSupportsStacking": {
          "description": "Does this widget support stacking widgets on top?",
          "type": "boolean"
        }
      },
      "required": [
        "mCallCustomTickOnConstruct",
        "mCaptureInput",
        "mCustomTickRate",
        "mDefaultFocusWidget",
        "mDefaultFocusWidgetClass",
        "mDesiredAlignmentSize",
        "mDesiredHorizontalAlignment",
        "mDesiredVerticalAlignment",
        "mInputToPassThrough",
        "mInteractObject",
        "mRestoreFocusWhenLost",
        "mSupportsStacking",
        "mUseGamepadCursor",
        "mUseKeyboard",
        "mUseMouse"
      ]
    },
    "UFGAudioMessage": {
      "type": "object",
      "properties": {
        "mAkAudioComponent": {
          "description": "The Ak component"
        },
        "mAudioEvents": {
          "description": "The AK audio to play when \"showing\" this message",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FAudioSubtitlePair"
          }
        },
        "mCurrentDialogue": {
          "$ref": "#/definitions/FAudioSubtitlePair",
          "description": "Current dialogue that is displayed"
        },
        "mSubtitleTimeMultiplier": {
          "description": "Multiplier for time per character to display",
          "type": "number"
        },
        "mAudioMessageConcluded": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mAudioMessageInputComponent": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mTitle": {
          "description": "I think this may be the title",
          "type": "string"
        },
        "mPreviewText": {
          "description": "Preview text when a message is added",
          "type": "string"
        },
        "mIsPopup": {
          "description": "Should the message be displayed in a popup?",
          "type": "boolean"
        },
        "mSenderClass": {
          "description": "Who sent the message",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mType": {
          "$ref": "#/definitions/EMessageType",
          "description": "What type is it"
        },
        "mImages": {
          "description": "Images to display in the codex",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        }
      },
      "required": [
        "mAkAudioComponent",
        "mAudioEvents",
        "mAudioMessageConcluded",
        "mAudioMessageInputComponent",
        "mCurrentDialogue",
        "mImages",
        "mIsPopup",
        "mPreviewText",
        "mSenderClass",
        "mSubtitleTimeMultiplier",
        "mTitle",
        "mType"
      ]
    },
    "FAudioSubtitlePair": {
      "type": "object",
      "properties": {
        "AudioEvent": {
          "description": "Audio to play"
        },
        "Subtitle": {
          "description": "Subtitle to display",
          "type": "string"
        },
        "SenderClass": {
          "description": "Sender for this part of message",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "AudioEvent",
        "SenderClass",
        "Subtitle"
      ]
    },
    "EMessageType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "UFGPopupWidget": {
      "type": "object",
      "properties": {
        "mPopupConfirmClickedDelegate_DEPRECATED": {
          "description": "Delegate for when pressing the confirm button in popup"
        },
        "mPopupClosedDelegate": {
          "description": "Delegate for when pressing the confirm button in popup"
        },
        "mInstigator": {
          "$ref": "#/definitions/UObject"
        },
        "mUseKeyboard": {
          "description": "If we should take the keyboard input from the player. The player won't be able to move around.",
          "type": "boolean"
        },
        "mUseMouse": {
          "description": "If we should take the mouse input from the player. The player won't be able to look around.",
          "type": "boolean"
        },
        "mCaptureInput": {
          "description": "Decides if we should share input with game or capture it completely",
          "type": "boolean"
        },
        "mRestoreFocusWhenLost": {
          "description": "Decides if the widget should restore focus when it looses it. (e.g. when the user clicks outside of the widget)",
          "type": "boolean"
        },
        "mInputToPassThrough": {
          "description": "There need to be a clear hierarchy of how input is handled and what to pass and not pass and if the default is pass all or pass none.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDesiredHorizontalAlignment": {
          "description": "Our desired horizontal alignment"
        },
        "mDesiredVerticalAlignment": {
          "description": "Our desired vetical alignment"
        },
        "mDesiredAlignmentSize": {
          "description": "Our desired horizontal size"
        },
        "mInteractObject": {
          "$ref": "#/definitions/UObject",
          "description": "Object that we interacted with in order to show this widget ( can be nullPeter )"
        },
        "mDefaultFocusWidgetClass": {
          "description": "Class of the default widget we want to give focus to",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseGamepadCursor": {
          "description": "Should gamepad act as cursor when using this widget?",
          "type": "boolean"
        },
        "mCustomTickRate": {
          "description": "The rate for the timer that triggers the custom tick. If <= 0.f no timer will be started",
          "type": "number"
        },
        "mCallCustomTickOnConstruct": {
          "description": "True if the custom tick event be called on construct. If <= 0.f no event will be triggered",
          "type": "boolean"
        },
        "mDefaultFocusWidget": {
          "description": "Used to give focus to an object when nothing else has focus"
        },
        "mSupportsStacking": {
          "description": "Does this widget support stacking widgets on top?",
          "type": "boolean"
        }
      },
      "required": [
        "mCallCustomTickOnConstruct",
        "mCaptureInput",
        "mCustomTickRate",
        "mDefaultFocusWidget",
        "mDefaultFocusWidgetClass",
        "mDesiredAlignmentSize",
        "mDesiredHorizontalAlignment",
        "mDesiredVerticalAlignment",
        "mInputToPassThrough",
        "mInstigator",
        "mInteractObject",
        "mPopupClosedDelegate",
        "mPopupConfirmClickedDelegate_DEPRECATED",
        "mRestoreFocusWhenLost",
        "mSupportsStacking",
        "mUseGamepadCursor",
        "mUseKeyboard",
        "mUseMouse"
      ]
    },
    "UFGBaseUI": {
      "type": "object",
      "properties": {
        "mActivePopup": {
          "$ref": "#/definitions/UFGPopupWidget",
          "description": "Current active popup"
        }
      },
      "required": [
        "mActivePopup"
      ]
    },
    "AFGCentralStorageContainer": {
      "type": "object",
      "properties": {
        "mStackingHeight": {
          "description": "How far apart in Z do multiple storages stack.",
          "type": "number"
        },
        "mDefaultResources": {
          "description": "Default resources in a storage @todo Why this special case here, add the stuff in blueprint instead first time we're being built... I guess this is only used for the tutorial?",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mInventorySizeX": {
          "description": "The size of the inventory for this storage.",
          "type": "number"
        },
        "mInventorySizeY": {
          "description": "The size of the inventory for this storage.",
          "type": "number"
        },
        "mStorageInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDefaultResources",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mInventorySizeX",
        "mInventorySizeY",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mStackingHeight",
        "mStorageInventory",
        "mTimeSinceStartStopProducing"
      ]
    }
  },
  "$schema": "http://json-schema.org/draft-07/schema#"
}