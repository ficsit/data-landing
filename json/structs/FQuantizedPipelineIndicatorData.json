{
  "type": "object",
  "properties": {
    "PackedFlow": {
      "description": "See setters for how this data is packed.",
      "type": "number"
    },
    "PackedContent": {
      "description": "An 8-bit unsigned integer.",
      "type": "number"
    }
  },
  "required": [
    "PackedContent",
    "PackedFlow"
  ],
  "definitions": {
    "UFGActorRepresentation": {
      "type": "object",
      "properties": {
        "mRealActor": {
          "$ref": "#/definitions/AActor",
          "description": "This is the real actor that this representation represents"
        },
        "mActorLocation": {
          "description": "This is the actor location"
        },
        "mActorRotation": {
          "description": "This is the actor rotation"
        },
        "mIsStatic": {
          "description": "If the actor is static or can be moved",
          "type": "boolean"
        },
        "mRepresentationTexture": {
          "description": "This is the texture to show for this actor representation",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRepresentationText": {
          "description": "This is the text to show for this actor representation",
          "type": "string"
        },
        "mRepresentationColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "This is the color used for the representation of this actor"
        },
        "mRepresentationType": {
          "$ref": "#/definitions/ERepresentationType",
          "description": "This helps define how this actor representation should be presented"
        },
        "mFogOfWarRevealType": {
          "$ref": "#/definitions/EFogOfWarRevealType"
        },
        "mFogOfWarRevealRadius": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mShouldShowInCompass": {
          "description": "If this should be shown in the compass or not",
          "type": "boolean"
        },
        "mShouldShowOnMap": {
          "description": "If this should be shown on the map or not",
          "type": "boolean"
        },
        "mCompassViewDistance": {
          "$ref": "#/definitions/ECompassViewDistance",
          "description": "How far away this representation should be shown in the compass"
        }
      },
      "required": [
        "mActorLocation",
        "mActorRotation",
        "mCompassViewDistance",
        "mFogOfWarRevealRadius",
        "mFogOfWarRevealType",
        "mIsStatic",
        "mRealActor",
        "mRepresentationColor",
        "mRepresentationText",
        "mRepresentationTexture",
        "mRepresentationType",
        "mShouldShowInCompass",
        "mShouldShowOnMap"
      ]
    },
    "AActor": {
      "description": "Actor is the base class for an Object that can be placed or spawned in a level.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Engine/GameFramework/AActor/index.html",
      "type": "object"
    },
    "LinearColor": {
      "description": "A linear, 32-bit/component floating point RGBA color.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FLinearColor/index.html",
      "type": "object",
      "properties": {
        "R": {
          "description": "The color's red intensity.",
          "type": "number"
        },
        "G": {
          "description": "The color's green intensity.",
          "type": "number"
        },
        "B": {
          "description": "The color's blue intensity.",
          "type": "number"
        },
        "A": {
          "description": "The color's opacity.",
          "type": "number"
        }
      },
      "required": [
        "A",
        "B",
        "G",
        "R"
      ]
    },
    "ERepresentationType": {
      "enum": [
        0,
        1,
        10,
        11,
        12,
        13,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "EFogOfWarRevealType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "ECompassViewDistance": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "UFGSoundSplineComponent": {
      "type": "object",
      "properties": {
        "mEmitterInterval": {
          "description": "Distance beween each emitter on our parent spline, this might be scaled slightly so that we get a point on both start and end",
          "type": "number"
        }
      },
      "required": [
        "mEmitterInterval"
      ]
    },
    "FExponentialFogSettings": {
      "type": "object",
      "properties": {
        "FogHeight": {
          "description": "The ZValue of the fog",
          "type": "number"
        },
        "FogDensity": {
          "description": "Density of the fog",
          "type": "number"
        },
        "FogInscatteringColor": {
          "$ref": "#/definitions/LinearColor"
        },
        "FullyDirectionalInscatteringColorDistance": {
          "description": "Distance at which InscatteringColorCubemap should be used directly for the Inscattering Color.",
          "type": "number"
        },
        "NonDirectionalInscatteringColorDistance": {
          "description": "Distance at which only the average color of InscatteringColorCubemap should be used as Inscattering Color.",
          "type": "number"
        },
        "DirectionalInscatteringExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DirectionalInscatteringStartDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DirectionalInscatteringColor": {
          "$ref": "#/definitions/LinearColor"
        },
        "FogHeightFalloff": {
          "description": "A floating point number.",
          "type": "number"
        },
        "FogMaxOpacity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "StartDistance": {
          "description": "Distance from the camera that the fog will start, in world units.",
          "type": "number"
        },
        "FogCutoffDistance": {
          "description": "Scene elements past this distance will not have fog applied.  This is useful for excluding skyboxes which already have fog baked in.",
          "type": "number"
        }
      },
      "required": [
        "DirectionalInscatteringColor",
        "DirectionalInscatteringExponent",
        "DirectionalInscatteringStartDistance",
        "FogCutoffDistance",
        "FogDensity",
        "FogHeight",
        "FogHeightFalloff",
        "FogInscatteringColor",
        "FogMaxOpacity",
        "FullyDirectionalInscatteringColorDistance",
        "NonDirectionalInscatteringColorDistance",
        "StartDistance"
      ]
    },
    "AFGBuildableAttachmentSplitter": {
      "type": "object",
      "properties": {
        "mCurrentOutputIndex": {
          "description": "Cycles through the outputs, stores the output we want to put mItem on. Index is for the mOutputs array.",
          "type": "number"
        },
        "mCurrentInventoryIndex": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mDistributionTable": {
          "description": "Table of all items in the inventory mapped to a desired output. The array is filled from a call to FillDistributionTable which runs in factory tick",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FConnectionItemStruct"
          }
        },
        "mConveyorSpaceData": {
          "$ref": "#/definitions/Map<any,FConveyorSpaceData>",
          "description": "Store last cached available space and if an item have been grabbed by the connected components"
        },
        "mBufferInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBufferInventory",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mConveyorSpaceData",
        "mCurrentInventoryIndex",
        "mCurrentOutputIndex",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDistributionTable",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "FConnectionItemStruct": {
      "type": "object",
      "properties": {
        "Connection": {
          "description": "The connection to put the item on"
        },
        "Item": {
          "$ref": "#/definitions/FInventoryItem",
          "description": "The item to put on the connection"
        }
      },
      "required": [
        "Connection",
        "Item"
      ]
    },
    "FInventoryItem": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "The type of item",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ItemState": {
          "$ref": "#/definitions/FSharedInventoryStatePtr",
          "description": "Optionally store an actor, e.g. an equipment, so we can remember it's state."
        }
      },
      "required": [
        "ItemClass",
        "ItemState"
      ]
    },
    "FSharedInventoryStatePtr": {
      "type": "object",
      "properties": {
        "ActorPtr": {
          "$ref": "#/definitions/AActor",
          "description": "The actor we've shared ownership over."
        }
      },
      "required": [
        "ActorPtr"
      ]
    },
    "Map<any,FConveyorSpaceData>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGInventoryComponent": {
      "type": "object",
      "properties": {
        "ResizeInventoryDelegate": {
          "description": "Called when this inventory has been resized"
        },
        "OnItemAddedDelegate": {
          "description": "Called when this inventory has something added to it, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "OnItemRemovedDelegate": {
          "description": "Called when something has been removed from the inventory, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "mDefaultInventorySize": {
          "description": "When we make an inventory by adding the component to an actor we use this to specify its size",
          "type": "number"
        },
        "mAdjustedSizeDiff": {
          "description": "When we resize the inventory we save how much bigger or smaller the inventory was made",
          "type": "number"
        },
        "mInventoryStacks": {
          "description": "All items in the inventory",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mArbitrarySlotSizes": {
          "description": "In some rare cases we don't want to use the StackSize to limit the slot, so this way we can have larger or smaller slots",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mAllowedItemDescriptors": {
          "description": "This are the allowed inventory items, this we we can \"filter\" in BluePrint as well.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCanBeRearrange": {
          "description": "Can stuff in this inventory be rearranged, that is moved from one slot to the other?",
          "type": "boolean"
        }
      },
      "required": [
        "OnItemAddedDelegate",
        "OnItemRemovedDelegate",
        "ResizeInventoryDelegate",
        "mAdjustedSizeDiff",
        "mAllowedItemDescriptors",
        "mArbitrarySlotSizes",
        "mCanBeRearrange",
        "mDefaultInventorySize",
        "mInventoryStacks"
      ]
    },
    "FInventoryStack": {
      "type": "object",
      "properties": {
        "Item": {
          "$ref": "#/definitions/FInventoryItem",
          "description": "Type of item in this stack."
        },
        "NumItems": {
          "description": "Number of items in this stack.",
          "type": "number"
        }
      },
      "required": [
        "Item",
        "NumItems"
      ]
    },
    "UFGPowerInfoComponent": {
      "type": "object",
      "properties": {
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mTargetConsumption": {
          "description": "Power to draw from the circuit.",
          "type": "number"
        },
        "mActualConsumption": {
          "description": "The actual power we got from the circuit (updated each frame).",
          "type": "number"
        },
        "mBaseProduction": {
          "description": "Power to always provide to the circuit.",
          "type": "number"
        },
        "mDynamicProductionCapacity": {
          "description": "Power to optionally provide to the circuit.",
          "type": "number"
        },
        "mDynamicProductionDemandFactor": {
          "description": "The demand for dynamic power (updated each frame).",
          "type": "number"
        },
        "mIsFuseTriggered": {
          "description": "true if the circuit is overloaded and the fuse has been triggered.",
          "type": "number"
        }
      },
      "required": [
        "mActualConsumption",
        "mBaseProduction",
        "mCircuitID",
        "mDynamicProductionCapacity",
        "mDynamicProductionDemandFactor",
        "mIsFuseTriggered",
        "mTargetConsumption"
      ]
    },
    "EStackSize": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5,
        6
      ],
      "type": "number"
    },
    "AFGReplicationDetailActor": {
      "type": "object",
      "properties": {
        "mOwningBuildable": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "Owning AFGBuildable to this replication detail actor object. Should never be null."
        }
      },
      "required": [
        "mOwningBuildable"
      ]
    },
    "AFGBuildable": {
      "type": "object",
      "properties": {
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect"
      ]
    },
    "Vector": {
      "description": "A vector in 3-D space composed of components (X, Y, Z) with floating point precision.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FVector/index.html",
      "type": "object",
      "properties": {
        "X": {
          "description": "The vector's X component.",
          "type": "number"
        },
        "Y": {
          "description": "The vector's Y component.",
          "type": "number"
        },
        "Z": {
          "description": "The vector's Z component.",
          "type": "number"
        }
      },
      "required": [
        "X",
        "Y",
        "Z"
      ]
    },
    "FFactoryTickFunction": {
      "type": "object"
    },
    "Map<string,UFGFactoryMaterialInstanceManager>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "AFGCharacterPlayer": {
      "type": "object",
      "properties": {
        "mBaseTurnRate": {
          "description": "Base turn rate, in deg/sec. Other scaling may affect final turn rate.",
          "type": "number"
        },
        "mBaseLookUpRate": {
          "description": "Base look up/down rate, in deg/sec. Other scaling may affect final rate.",
          "type": "number"
        },
        "mMesh1PAnimClass": {
          "description": "The default arms animation when we're idle.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh3P": {
          "description": "Pawn mesh: 3rd person view"
        },
        "mFoliagePickupProxyClass": {
          "description": "As we have no foliage actor to actually put pickup code in, we use this actor as a proxy",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFoliagePickupProxy": {
          "$ref": "#/definitions/AFGFoliagePickup",
          "description": "Actor that's used when trying to pickup foliage"
        },
        "mBuildGun": {
          "$ref": "#/definitions/AFGBuildGun",
          "description": "This is the infamous build gun."
        },
        "mResourceScanner": {
          "$ref": "#/definitions/AFGResourceScanner",
          "description": "Reference to the resource scanner"
        },
        "mResourceMiner": {
          "$ref": "#/definitions/AFGResourceMiner",
          "description": "Reference to the resource miner"
        },
        "mBestUsableActor": {
          "$ref": "#/definitions/AActor",
          "description": "The best usable actor nearby."
        },
        "mCachedUseState": {
          "$ref": "#/definitions/FUseState",
          "description": "Of the usable actor we are looking at, UPROPERTY to prevent the AdditionalData to be garbage collected"
        },
        "mAnimInstanceClass": {
          "description": "Anim instance class to use in third person",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAnimInstanceClass1P": {
          "description": "Anim instance class to use in first person",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mReviveDuration": {
          "description": "time (in seconds) it takes to revive a fellow player",
          "type": "number"
        },
        "mStartingResources": {
          "description": "The starting resources for the player",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mStartingResourceForTesting": {
          "description": "The starting resources for the player if we are NOT in shipping",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mDrownDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDrownDamage": {
          "description": "The amount of damage to receive when drowning.",
          "type": "number"
        },
        "mDrownDamageInterval": {
          "description": "Time between each application of drowning damage (in seconds)",
          "type": "number"
        },
        "mPlayerToRevive": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player that we are reviving"
        },
        "mPickupToCollect": {
          "$ref": "#/definitions/AFGItemPickup",
          "description": "The pickup we are collecting"
        },
        "m1PDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in m1PFootstepEffect"
        },
        "m1PFootstepEffect": {
          "description": "Effects to play when a foot hits the ground in first person",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "m1PFootstepEvent": {
          "description": "Effects to play when a foot hits the ground in first person",
          "type": "array",
          "items": {}
        },
        "mLastSafeGroundPositions": {
          "$ref": "#/definitions/Vector",
          "description": "latest safe ground location positions"
        },
        "mLastSafeGroundPositionLoopHead": {
          "description": "used for knowing which is the latest written safe ground position",
          "type": "number"
        },
        "mCameraComponent": {
          "description": "Player camera"
        },
        "mSpringArmComponent": {
          "description": "Spring arm for camera"
        },
        "mActiveEquipments": {
          "description": "This is the equipment we hold in our hands.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipment"
          }
        },
        "mClientActiveEquipments": {
          "description": "Simulated on the client so they know what to unequip.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipment"
          }
        },
        "mAllAttachments": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipmentAttachment"
          }
        },
        "mActiveAttachments": {
          "description": "Remote client representation of the equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGEquipmentAttachment"
          }
        },
        "mCurrentCameraMode": {
          "$ref": "#/definitions/ECameraMode",
          "description": "Current camera mode for the character"
        },
        "mPlayerPreferredCameraMode": {
          "$ref": "#/definitions/ECameraMode",
          "description": "What camera mode were we in before we opened the"
        },
        "mInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The players inventory."
        },
        "mAllowedResourceFormsInInventory": {
          "description": "The resource forms that are allowed in players inventory.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/EResourceForm"
          }
        },
        "mBeltSlot": {
          "$ref": "#/definitions/UFGInventoryComponentBeltSlot",
          "description": "The belt slot inventory."
        },
        "mTrashSlot": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The players inventory."
        },
        "mAllowCameraToggling": {
          "description": "Allow toggling of camera modes",
          "type": "boolean"
        },
        "mUseDistance": {
          "description": "Maximum distance we use objects on",
          "type": "number"
        },
        "mPickupCounter": {
          "description": "Counter used for replicating to remote clients when something is picked up",
          "type": "number"
        },
        "mReviver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player that is reviving me"
        },
        "mDefaultWalkHeadBobShake": {
          "description": "Reference to the default walk head bob shake",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultSprintHeadBobShake": {
          "description": "Reference to the default sprint head bob shake",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDrivenVehicle": {
          "$ref": "#/definitions/AFGDriveablePawn",
          "description": "Vehicle currently driven by pawn."
        },
        "mSavedDrivenVehicle": {
          "$ref": "#/definitions/AFGDriveablePawn"
        },
        "mOutlineComponent": {
          "$ref": "#/definitions/UFGOutlineComponent"
        },
        "mHealthGenerationThreshold": {
          "description": "Health Generation",
          "type": "number"
        },
        "mHealthGenerationAmount": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHealthGenerationInterval": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHealthGenerationWaitTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mRadiationIntensity": {
          "description": "The accumulated normalized radiation intensity of the players current location",
          "type": "number"
        },
        "mRadiationDamageAngle": {
          "description": "The angle from the players view to the accumulated radiation damage",
          "type": "number"
        },
        "mRadiationImmunity": {
          "description": "How much immunity do we have for radiation",
          "type": "number"
        },
        "mInRadioactiveZone": {
          "description": "Are we in a radioactive zone",
          "type": "boolean"
        },
        "mCameraOffsetBlendSpeed": {
          "description": "How fast the blend is",
          "type": "number"
        },
        "mReplicatedIsSliding": {
          "description": "Replicated value of sliding status. Used to let non owning player know whats happening",
          "type": "boolean"
        },
        "mCrouchSpeed": {
          "description": "How fast the blend is for crouch and slide",
          "type": "number"
        },
        "mStandSpeed": {
          "description": "How fast the blend is from crouch/slide to stand",
          "type": "number"
        },
        "mSlideToCrouchSpeed": {
          "description": "How fast the blend is from slide to crouch",
          "type": "number"
        },
        "mNoUpdate": {
          "type": "boolean"
        },
        "mFeetNames": {
          "description": "When receiving FootDown on index 2, then we will trace from mFeetNames[2] socket for ground",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in mFootstepEffects"
        },
        "mFootstepEffect": {
          "description": "Effects to play when a foot hits the ground",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "mFootstepAudioEvents": {
          "description": "Audio event to play (where index in array is the feet index passed from AnimNotify_FootDown)",
          "type": "array",
          "items": {}
        },
        "mMaxFootstepParticleSpawnDistance": {
          "description": "Maximum distance we want to play footstep particles at",
          "type": "number"
        },
        "mMaxFootstepDecalSpawnDistance": {
          "description": "Maximum distance we want to spawn footsteps decals at",
          "type": "number"
        },
        "mFootstepDecalSize": {
          "description": "Size of footstep decals",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mFootstepDecalLifetime": {
          "description": "Lifetime of footstep decals",
          "type": "number"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mFallDamageCurve": {
          "description": "How much damage to take falling with a given velocity"
        },
        "mFallDamageCurveOverride": {
          "description": "Overrides the default fall damage curve, utilized by Equipment"
        },
        "mFallDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxDeathStayTime": {
          "description": "The maximum time after death (in seconds) the pawn will stay in the world, so it will be removed even if it's in sight after this time",
          "type": "number"
        },
        "mDeathRemoveCheckTime": {
          "description": "How often will we check if the pawn is in sight of any player",
          "type": "number"
        },
        "mEnemyTargetDesirability": {
          "description": "Multiplier for targeting desirability",
          "type": "number"
        },
        "mTakeDamageSound": {
          "description": "Sound played when pawn takes damage"
        },
        "mDeathSound": {
          "description": "Sound played when pawn dies"
        },
        "mLandEvent": {
          "description": "Event posted when landing"
        },
        "mTakeDamageParticle": {
          "description": "Particle for when pawn takes damage"
        },
        "mMinVehiclePushVelocityForRagdoll": {
          "description": "Min push velocity required to start ragdoll",
          "type": "number"
        },
        "mTimeToGetUpFromRagdoll": {
          "description": "time in seconds until character gets up from ragdoll if alive",
          "type": "number"
        },
        "mMaxDistanceMovedToGetUp": {
          "description": "the furthest distance we can move during ragdoll before we are considered still enough to stand up from ragdoll",
          "type": "number"
        },
        "mIsRagdolled": {
          "description": "true if ragdolled",
          "type": "boolean"
        },
        "mRagdollMeshLoc": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshVelocity": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshLocBoneName": {
          "description": "Name of the bone we take mesh location from",
          "type": "string"
        },
        "mRagdollMeshPhysicsBoneName": {
          "description": "Name of the bone we take physics velocity from",
          "type": "string"
        },
        "mSyncBodyMaxDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mApplyDamageMomentum": {
          "description": "Should the auto momentum be applied when taking damage?",
          "type": "boolean"
        },
        "mIgnoredDamageTypes": {
          "description": "Damage types that this character is immune to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mWeakspotMultiplier": {
          "description": "How much more damage should be dealt when taking a weakspot hit",
          "type": "number"
        },
        "mWeakspotBoneNames": {
          "description": "Bone names that result in a weakspot hit",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mNormalDamageMultiplier": {
          "description": "Multiplier for this creature and normal damage taken",
          "type": "number"
        },
        "mIsPossessed": {
          "description": "Used to let client know when a pawn gets possessed/unpossessed",
          "type": "boolean"
        }
      },
      "required": [
        "m1PDefaultFootstepEffect",
        "m1PFootstepEffect",
        "m1PFootstepEvent",
        "mActiveAttachments",
        "mActiveEquipments",
        "mAllAttachments",
        "mAllowCameraToggling",
        "mAllowedResourceFormsInInventory",
        "mAnimInstanceClass",
        "mAnimInstanceClass1P",
        "mApplyDamageMomentum",
        "mBaseLookUpRate",
        "mBaseTurnRate",
        "mBeltSlot",
        "mBestUsableActor",
        "mBuildGun",
        "mCachedUseState",
        "mCameraComponent",
        "mCameraOffsetBlendSpeed",
        "mClientActiveEquipments",
        "mCrouchSpeed",
        "mCurrentCameraMode",
        "mDeathRemoveCheckTime",
        "mDeathSound",
        "mDefaultFootstepEffect",
        "mDefaultSprintHeadBobShake",
        "mDefaultWalkHeadBobShake",
        "mDrivenVehicle",
        "mDrownDamage",
        "mDrownDamageDamageType",
        "mDrownDamageInterval",
        "mEnemyTargetDesirability",
        "mFallDamageCurve",
        "mFallDamageCurveOverride",
        "mFallDamageDamageType",
        "mFeetNames",
        "mFoliagePickupProxy",
        "mFoliagePickupProxyClass",
        "mFootstepAudioEvents",
        "mFootstepDecalLifetime",
        "mFootstepDecalSize",
        "mFootstepEffect",
        "mHealthComponent",
        "mHealthGenerationAmount",
        "mHealthGenerationInterval",
        "mHealthGenerationThreshold",
        "mHealthGenerationWaitTime",
        "mIgnoredDamageTypes",
        "mInRadioactiveZone",
        "mInventory",
        "mIsPossessed",
        "mIsRagdolled",
        "mLandEvent",
        "mLastSafeGroundPositionLoopHead",
        "mLastSafeGroundPositions",
        "mMaxDeathStayTime",
        "mMaxDistanceMovedToGetUp",
        "mMaxFootstepDecalSpawnDistance",
        "mMaxFootstepParticleSpawnDistance",
        "mMesh1PAnimClass",
        "mMesh3P",
        "mMinVehiclePushVelocityForRagdoll",
        "mNoUpdate",
        "mNormalDamageMultiplier",
        "mOutlineComponent",
        "mPickupCounter",
        "mPickupToCollect",
        "mPlayerPreferredCameraMode",
        "mPlayerToRevive",
        "mRadiationDamageAngle",
        "mRadiationImmunity",
        "mRadiationIntensity",
        "mRagdollMeshLoc",
        "mRagdollMeshLocBoneName",
        "mRagdollMeshPhysicsBoneName",
        "mRagdollMeshVelocity",
        "mReplicatedIsSliding",
        "mResourceMiner",
        "mResourceScanner",
        "mReviveDuration",
        "mReviver",
        "mSavedDrivenVehicle",
        "mSlideToCrouchSpeed",
        "mSpringArmComponent",
        "mStandSpeed",
        "mStartingResourceForTesting",
        "mStartingResources",
        "mSyncBodyMaxDistance",
        "mTakeDamageParticle",
        "mTakeDamageSound",
        "mTimeToGetUpFromRagdoll",
        "mTrashSlot",
        "mUseDistance",
        "mWeakspotBoneNames",
        "mWeakspotMultiplier"
      ]
    },
    "AFGFoliagePickup": {
      "type": "object",
      "properties": {
        "mPickupMesh": {
          "description": "The mesh that should be outlining",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "mPickupMesh"
      ]
    },
    "AFGBuildGun": {
      "type": "object",
      "properties": {
        "mOnStateChanged": {
          "description": "Called when the build gun state changes."
        },
        "mOnRecipeChanged": {
          "description": "Called when the build gun build state receives a new recipe. This May be called prior to OnStateChanged."
        },
        "mBuildDistanceMax": {
          "description": "Trace distance for this build gun when building and dismantling.",
          "type": "number"
        },
        "mMenuStateClass": {
          "description": "The state to use when operating the menus.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildStateClass": {
          "description": "The state to use when building.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleStateClass": {
          "description": "The state to use when dismantling.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStates": {
          "$ref": "#/definitions/UFGBuildGunState",
          "description": "All the states."
        },
        "mHitResult": {
          "description": "Result of the latest trace."
        },
        "mCurrentStateEnum": {
          "$ref": "#/definitions/EBuildGunState"
        },
        "mCurrentState": {
          "$ref": "#/definitions/UFGBuildGunState"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mBuildDistanceMax",
        "mBuildStateClass",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mCurrentState",
        "mCurrentStateEnum",
        "mDismantleStateClass",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHitResult",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mMenuStateClass",
        "mOnRecipeChanged",
        "mOnStateChanged",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mStates",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "UFGBuildGunState": {
      "type": "object",
      "properties": {
        "mActionDelay": {
          "description": "Time (in seconds) it takes for the action (eg. Build, dismantle)",
          "type": "number"
        },
        "mActionMessage": {
          "description": "Text to show while action is in progress",
          "type": "string"
        }
      },
      "required": [
        "mActionDelay",
        "mActionMessage"
      ]
    },
    "EBuildGunState": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "EEquipmentSlot": {
      "description": "Equipments are equip on different slots on the player. One EQ per slot. These are the slots.",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "AFGEquipmentChild": {
      "type": "object",
      "properties": {
        "mParentEquipment": {
          "$ref": "#/definitions/AFGEquipment",
          "description": "stores a reference to the FGEquipment that spawned this class"
        },
        "mAttachSocket": {
          "description": "The socket to attach any child equipment to",
          "type": "string"
        }
      },
      "required": [
        "mAttachSocket",
        "mParentEquipment"
      ]
    },
    "AFGEquipment": {
      "type": "object",
      "properties": {
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FItemAmount": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "The item.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Amount": {
          "description": "The amount of this item.",
          "type": "number"
        }
      },
      "required": [
        "Amount",
        "ItemClass"
      ]
    },
    "EArmEquipment": {
      "enum": [
        0,
        1,
        10,
        11,
        12,
        13,
        14,
        15,
        16,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "EBackEquipment": {
      "enum": [
        0,
        1
      ],
      "type": "number"
    },
    "AFGEquipmentAttachment": {
      "type": "object",
      "properties": {
        "mEquipmentClass": {
          "description": "The class of the equipment that spawned this attachment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseLocation": {
          "$ref": "#/definitions/Vector",
          "description": "This value get replicated to clients so they can play effect"
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mAttachedTo": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The character this is attached to."
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this attachment attached"
        },
        "mAnimationState": {
          "description": "integer used for animation states",
          "type": "number"
        }
      },
      "required": [
        "mAnimationState",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachedTo",
        "mBackAnimation",
        "mEquipmentClass",
        "mEquipmentSlot",
        "mUseLocation"
      ]
    },
    "AFGResourceScanner": {
      "type": "object",
      "properties": {
        "mResourceDescriptorToScanFor": {
          "description": "This is the resource class to scan for",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mNrOfClosestClustersToMark": {
          "description": "How many node clusters should be marked",
          "type": "number"
        },
        "mLastPressedTimeStamp": {
          "description": "Keeps track of the last time we pressed Scan",
          "type": "number"
        },
        "mHoldDownDurationForUI": {
          "description": "Time needed to hold down the key to show the selection UI",
          "type": "number"
        },
        "mIsPressingScan": {
          "description": "True in between OnScanPressed and OnScanReleased",
          "type": "boolean"
        },
        "mIsWaitingForSelectionUI": {
          "description": "True if we are waiting for the selection UI",
          "type": "boolean"
        },
        "mDistBetweenNodesInCluster": {
          "description": "If nodes are closer that dist they are considered within the cluster",
          "type": "number"
        },
        "mNodeClusters": {
          "description": "A list of all the clusters of nodes non the level",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FNodeClusterData"
          }
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mDistBetweenNodesInCluster",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHoldDownDurationForUI",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mIsPressingScan",
        "mIsWaitingForSelectionUI",
        "mLastPressedTimeStamp",
        "mNodeClusters",
        "mNrOfClosestClustersToMark",
        "mResourceDescriptorToScanFor",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FNodeClusterData": {
      "description": "Holds information about resource node clusters. This could be saved in actors on the level for optimization.",
      "type": "object",
      "properties": {
        "Nodes": {
          "description": "Cost of schematic if there are more than once item in this array the true cost will be randomly selected.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGResourceNode"
          }
        },
        "MidPoint": {
          "$ref": "#/definitions/Vector",
          "description": "The average location of all the nodes"
        },
        "ResourceDescriptor": {
          "description": "The resource descriptor of this cluster",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "MidPoint",
        "Nodes",
        "ResourceDescriptor"
      ]
    },
    "AFGResourceNode": {
      "type": "object",
      "properties": {
        "mResourceClass": {
          "description": "Type of resource",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPurity": {
          "$ref": "#/definitions/EResourcePurity",
          "description": "How pure the resource is"
        },
        "mAmount": {
          "$ref": "#/definitions/EResourceAmount",
          "description": "How pure the resource is"
        },
        "mDecalComponent": {
          "description": "the decal that used for displaying the resource"
        },
        "mBoxComponent": {
          "description": "If we have no static mesh but a decal, then we use this for collision"
        },
        "mResourcesLeft": {
          "description": "How much resources is left in this node",
          "type": "number"
        },
        "mIsOccupied": {
          "description": "If true, then we are occupied by something // [Dylan 3/2/2020] - Removed savegame meta",
          "type": "boolean"
        },
        "mRevealedOnMapBy": {
          "description": "Radar tower modifies this to show this resource node in the map",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UObject"
          }
        },
        "mIsLonerNode": {
          "description": "If true, this node will NEVER join another cluster of nodes, regardless of proximity.",
          "type": "boolean"
        },
        "mCanPlaceResourceExtractor": {
          "description": "Can this resource node be used for placing resource extractors on",
          "type": "boolean"
        },
        "mExtractMultiplier": {
          "description": "Multiplier that is applied in the end of extraction calculations. Is used for making deposits extract more than regular nodes",
          "type": "number"
        },
        "mPurityTextArray": {
          "description": "Text mapped to resource purity",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPurityTextPair"
          }
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDoSpawnParticle": {
          "description": "Bool for is we should spawn particle - @todo Do we really need to save this? //[Dylan 3/2/2020]",
          "type": "boolean"
        }
      },
      "required": [
        "mAmount",
        "mBoxComponent",
        "mCanPlaceResourceExtractor",
        "mDecalComponent",
        "mDoSpawnParticle",
        "mExtractMultiplier",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mIsLonerNode",
        "mIsOccupied",
        "mPurity",
        "mPurityTextArray",
        "mResourceClass",
        "mResourcesLeft",
        "mRevealedOnMapBy"
      ]
    },
    "EResourcePurity": {
      "description": "How how fast it is to mine the resource",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "EResourceAmount": {
      "description": "How much resources this node contains, a rich vein will deplete later",
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "UObject": {
      "description": "The base class of all UE4 objects.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/UObject/index.html",
      "type": "object"
    },
    "FPurityTextPair": {
      "type": "object",
      "properties": {
        "Text": {
          "description": "Localizable text",
          "type": "string"
        },
        "Purity": {
          "$ref": "#/definitions/EResourcePurity",
          "description": "Enum to localize"
        }
      },
      "required": [
        "Purity",
        "Text"
      ]
    },
    "AFGResourceMiner": {
      "type": "object",
      "properties": {
        "mPickParticleSystem": {
          "description": "The effect the spawn when picking."
        },
        "mPickArmsAnim": {
          "description": "Animation to play when picking."
        },
        "mCachedResouceNode": {
          "$ref": "#/definitions/AFGResourceNode",
          "description": "The node we want to pick from"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mCachedResouceNode",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mPickArmsAnim",
        "mPickParticleSystem",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "FUseState": {
      "type": "object",
      "properties": {
        "AdditionalData": {
          "$ref": "#/definitions/UFGUseState",
          "description": "Additional data that might be heavy to calculate several times the same frame, the reason it's cached here and not in the object, is that several players might want to cache different things"
        },
        "UseLocation": {
          "$ref": "#/definitions/Vector",
          "description": "Location of where the use happens"
        },
        "UseComponent": {
          "description": "Component that triggered the use"
        },
        "State": {
          "description": "Contains the usable state of the object, might be a error code",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "AdditionalData",
        "State",
        "UseComponent",
        "UseLocation"
      ]
    },
    "UFGUseState": {
      "type": "object",
      "properties": {
        "mWantAdditonalData": {
          "description": "If true, we will allocate a instance of the state, so we can store information in the state",
          "type": "boolean"
        },
        "mIsUsableState": {
          "description": "If true, we will allocate a instance of the state, so we can store information in the state",
          "type": "boolean"
        }
      },
      "required": [
        "mIsUsableState",
        "mWantAdditonalData"
      ]
    },
    "AFGItemPickup": {
      "type": "object",
      "properties": {
        "mTimeToPickUp": {
          "description": "The amount of time required to pickup < 0 == instant",
          "type": "number"
        },
        "mCollector": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The player collecting the item"
        },
        "mCollectingTimerHandle": {
          "description": "Timer handler for item being picked up"
        },
        "mPickupItems": {
          "$ref": "#/definitions/FInventoryStack",
          "description": "The items we want to be able to pickup"
        },
        "mDestroyOnPickup": {
          "description": "If set to true, then we destroy the item when it's pickup:ed",
          "type": "boolean"
        },
        "mSoundComponent": {
          "description": "ak component that plays sound"
        },
        "mAudioEvent": {
          "description": "The ak event to post for the sound"
        }
      },
      "required": [
        "mAudioEvent",
        "mCollectingTimerHandle",
        "mCollector",
        "mDestroyOnPickup",
        "mPickupItems",
        "mSoundComponent",
        "mTimeToPickUp"
      ]
    },
    "FFootstepEffect": {
      "type": "object",
      "properties": {
        "Particle": {
          "description": "The particle to use when hitting the ground"
        },
        "GroundDecals": {
          "description": "The decal to place on the ground when walking around",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "GroundDecals",
        "Particle"
      ]
    },
    "FFootstepEffectSurface": {
      "type": "object",
      "properties": {
        "Surface": {
          "description": "The surface the foot hit"
        },
        "Effect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "The effect we want to play when hitting the surface"
        }
      },
      "required": [
        "Effect",
        "Surface"
      ]
    },
    "ECameraMode": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "EResourceForm": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "UFGInventoryComponentBeltSlot": {
      "type": "object",
      "properties": {
        "ResizeInventoryDelegate": {
          "description": "Called when this inventory has been resized"
        },
        "OnItemAddedDelegate": {
          "description": "Called when this inventory has something added to it, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "OnItemRemovedDelegate": {
          "description": "Called when something has been removed from the inventory, @note: Client doesn't garantuee order of Added/Remove delegate"
        },
        "mDefaultInventorySize": {
          "description": "When we make an inventory by adding the component to an actor we use this to specify its size",
          "type": "number"
        },
        "mAdjustedSizeDiff": {
          "description": "When we resize the inventory we save how much bigger or smaller the inventory was made",
          "type": "number"
        },
        "mInventoryStacks": {
          "description": "All items in the inventory",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mArbitrarySlotSizes": {
          "description": "In some rare cases we don't want to use the StackSize to limit the slot, so this way we can have larger or smaller slots",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mAllowedItemDescriptors": {
          "description": "This are the allowed inventory items, this we we can \"filter\" in BluePrint as well.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCanBeRearrange": {
          "description": "Can stuff in this inventory be rearranged, that is moved from one slot to the other?",
          "type": "boolean"
        }
      },
      "required": [
        "OnItemAddedDelegate",
        "OnItemRemovedDelegate",
        "ResizeInventoryDelegate",
        "mAdjustedSizeDiff",
        "mAllowedItemDescriptors",
        "mArbitrarySlotSizes",
        "mCanBeRearrange",
        "mDefaultInventorySize",
        "mInventoryStacks"
      ]
    },
    "AFGDriveablePawn": {
      "type": "object",
      "properties": {
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mIsDriverVisible",
        "mIsDriving",
        "mShouldAttachDriver"
      ]
    },
    "UFGOutlineComponent": {
      "type": "object",
      "properties": {
        "mOutlineProxy": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mActiveOutlineActor": {
          "$ref": "#/definitions/AActor"
        },
        "mActiveMultiOutlineActors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AActor"
          }
        },
        "mCachedActorMaterials": {
          "$ref": "#/definitions/Map<AActor,FCachedMeshToMaterialObject>"
        },
        "mCachedSplineComponentMaterials": {
          "$ref": "#/definitions/Map<UFGSplineComponent,FCachedSplineMeshToMaterialObject>"
        },
        "mCachedProxyMeshMaterials": {
          "$ref": "#/definitions/Map<any,FCachedMaterialInterfaceArray>"
        }
      },
      "required": [
        "mActiveMultiOutlineActors",
        "mActiveOutlineActor",
        "mCachedActorMaterials",
        "mCachedProxyMeshMaterials",
        "mCachedSplineComponentMaterials",
        "mOutlineProxy"
      ]
    },
    "Map<AActor,FCachedMeshToMaterialObject>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<UFGSplineComponent,FCachedSplineMeshToMaterialObject>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<any,FCachedMaterialInterfaceArray>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGHealthComponent": {
      "type": "object",
      "properties": {
        "OnTakeAnyDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "OnTakePointDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "OnTakeRadialDamageDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "DeathDelegate": {
          "description": "SERVER ONLY: Called when we die"
        },
        "HealDelegate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mOnAdjustDamage": {
          "description": "Interested listeners for the adjust damage delegates",
          "type": "array",
          "items": {}
        },
        "mMaxHealth": {
          "description": "Our maximum health",
          "type": "number"
        },
        "mCurrentHealth": {
          "description": "Our current health",
          "type": "number"
        },
        "mRespawnHealthFactor": {
          "description": "Scale of max health to use when respawning",
          "type": "number"
        },
        "mIsDead": {
          "description": "If true, then we are dead. This is replicated to clients and they get the death event based on this.",
          "type": "number"
        },
        "mReplicateDamageEvents": {
          "description": "If true, then the client will trigger the following events: OnTakeAnyDamageDelegate, OnTakePointDamageDelegate, OnTakeRadialDamageDelegate",
          "type": "number"
        },
        "mReplicateDeathEvents": {
          "description": "If true, then the client will trigger the following event: DeathDelegate",
          "type": "number"
        }
      },
      "required": [
        "DeathDelegate",
        "HealDelegate",
        "OnTakeAnyDamageDelegate",
        "OnTakePointDamageDelegate",
        "OnTakeRadialDamageDelegate",
        "mCurrentHealth",
        "mIsDead",
        "mMaxHealth",
        "mOnAdjustDamage",
        "mReplicateDamageEvents",
        "mReplicateDeathEvents",
        "mRespawnHealthFactor"
      ]
    },
    "FNetConstructionID": {
      "description": "Used to track constructed (spawned) buildables matched with their holograms between client and server",
      "type": "object",
      "properties": {
        "NetPlayerID": {
          "description": "An 8-bit signed integer.",
          "type": "number"
        },
        "Server_ID": {
          "description": "An 16-bit unsigned integer.",
          "type": "number"
        },
        "Client_ID": {
          "description": "An 16-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "Client_ID",
        "NetPlayerID",
        "Server_ID"
      ]
    },
    "AFGBuildableConveyorBelt": {
      "type": "object",
      "properties": {
        "mMesh": {
          "description": "Mesh to use for his conveyor.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this conveyor.",
          "type": "number"
        },
        "mItemMeshMap": {
          "$ref": "#/definitions/Map<string,any>",
          "description": "Meshes for items."
        },
        "mSplineData": {
          "description": "Compact representation of mSplineComponent, used for replication and save game",
          "type": "array",
          "items": {}
        },
        "mSplineComponent": {
          "description": "The spline component for this conveyor. Note that this is only the spline."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mSoundSplineComponent": {
          "$ref": "#/definitions/UFGSoundSplineComponent",
          "description": "Wwise multiple position playback for the conveyor spline."
        },
        "mSplineAudioEvent": {
          "description": "The ak event to post for the sound spline"
        },
        "PresistentConveyorPackagingDataObject": {
          "$ref": "#/definitions/UPresistentConveyorPackagingData",
          "description": "held here, but created by conveyors when replicated, as we don't want to create it unless it's used."
        },
        "mSpeed": {
          "description": "Speed of this conveyor.",
          "type": "number"
        },
        "mItems": {
          "$ref": "#/definitions/FConveyorBeltItems",
          "description": "All the locally simulated resource offsets on the conveyor belt."
        },
        "mConnection0": {
          "description": "First connection on conveyor belt, Connections are always in the same order, mConnection0 is the input, mConnection1 is the output."
        },
        "mConnection1": {
          "description": "Second connection on conveyor belt"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "PresistentConveyorPackagingDataObject",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mItemMeshMap",
        "mItems",
        "mMaterialNameToInstanceManager",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSoundSplineComponent",
        "mSpeed",
        "mSplineAudioEvent",
        "mSplineComponent",
        "mSplineData"
      ]
    },
    "Map<string,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UPresistentConveyorPackagingData": {
      "type": "object"
    },
    "FConveyorBeltItems": {
      "type": "object"
    },
    "UFGFactoryLegsComponent": {
      "type": "object",
      "properties": {
        "mLegSocketNames": {
          "description": "Socket names on the parent mesh",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mLegMeshOverride": {
          "description": "The mesh to be used as legs on factories",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFootMeshOverride": {
          "description": "The mesh to be used as foots on factories",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxLegLengthOverride": {
          "description": "The maximum length the legs can be.",
          "type": "number"
        },
        "mLegMeshComponents": {
          "description": "The created leg components for this building",
          "type": "array",
          "items": {}
        },
        "mFootMeshComponents": {
          "description": "The created foot components for this building",
          "type": "array",
          "items": {}
        },
        "mCachedFeetOffset": {
          "description": "Stored so that we know the offset of the feet",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFeetOffset"
          }
        }
      },
      "required": [
        "mCachedFeetOffset",
        "mFootMeshComponents",
        "mFootMeshOverride",
        "mLegMeshComponents",
        "mLegMeshOverride",
        "mLegSocketNames",
        "mMaxLegLengthOverride"
      ]
    },
    "FFeetOffset": {
      "type": "object",
      "properties": {
        "FeetIndex": {
          "description": "The name of the foot's socket.",
          "type": "number"
        },
        "OffsetZ": {
          "description": "The offset along the Z axis from the parent mesh origo.",
          "type": "number"
        },
        "IsValidOffset": {
          "description": "Does this foot have a valid offset, only used during hologram placement.",
          "type": "boolean"
        }
      },
      "required": [
        "FeetIndex",
        "IsValidOffset",
        "OffsetZ"
      ]
    },
    "AFGHologram": {
      "type": "object",
      "properties": {
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceDetector",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLoopSound",
        "mPlacementMaterial",
        "mRecipe",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGPlayerState": {
      "type": "object",
      "properties": {
        "BuildableConstructedDelegate": {
          "description": "Broadcast when a buildable or decor has been constructed."
        },
        "mHotbarShortcuts": {
          "description": "All hotbar actions assigned",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGHotbarShortcut"
          }
        },
        "mDefaultRecipeShortcuts": {
          "description": "Default recipes to have shortcuts to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mNewRecipes": {
          "description": "Recipes that are new to the player. This is only for UI feedback and doesn't affect the players ability to use the recipe",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mSlotNum": {
          "description": "The slot num of this player state",
          "type": "number"
        },
        "mSlotData": {
          "$ref": "#/definitions/FSlotData",
          "description": "This players color container"
        },
        "mOwnedPawn": {
          "description": "Pawn we should take control of when rejoining game/loading game"
        },
        "mHasReceivedInitialItems": {
          "description": "Set to true after we have received our initial items",
          "type": "number"
        },
        "mHasSetupDefaultShortcuts": {
          "description": "Set to true after we have setup our initial shortcuts",
          "type": "number"
        },
        "mIsServerAdmin": {
          "description": "If true, then we are server admin",
          "type": "number"
        },
        "mTutorialSubsystem": {
          "$ref": "#/definitions/UFGTutorialSubsystem",
          "description": "Each local player has their own tutorial subsystem"
        },
        "mTutorialSubsystemClass": {
          "description": "Class of tutorial subsystem to spawn",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMessageData": {
          "description": "Data about all messages that can be displayed in the codex",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FMessageData"
          }
        },
        "mRememberedFirstTimeEquipmentClasses": {
          "description": "List of equipment classes that have been equipped at least once.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mNumArmSlots": {
          "description": "Total number of arm equipment slots for this player",
          "type": "number"
        },
        "mOnlyShowAffordableRecipes": {
          "description": "True if we only should show affordable recipes in manufacturing widgets",
          "type": "boolean"
        },
        "mCollapsedItemCategories": {
          "description": "The item categories that the user have collapsed in manufacturing widgets",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mFilteredOutMapTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ERepresentationType"
          }
        },
        "mFilteredOutCompassTypes": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/ERepresentationType"
          }
        },
        "mLastSelectedResourceSinkShopCategory": {
          "description": "The last selected category in the resource sink shop so we can open the shop at the same category later",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "BuildableConstructedDelegate",
        "mCollapsedItemCategories",
        "mDefaultRecipeShortcuts",
        "mFilteredOutCompassTypes",
        "mFilteredOutMapTypes",
        "mHasReceivedInitialItems",
        "mHasSetupDefaultShortcuts",
        "mHotbarShortcuts",
        "mIsServerAdmin",
        "mLastSelectedResourceSinkShopCategory",
        "mMessageData",
        "mNewRecipes",
        "mNumArmSlots",
        "mOnlyShowAffordableRecipes",
        "mOwnedPawn",
        "mRememberedFirstTimeEquipmentClasses",
        "mSlotData",
        "mSlotNum",
        "mTutorialSubsystem",
        "mTutorialSubsystemClass"
      ]
    },
    "UFGHotbarShortcut": {
      "type": "object"
    },
    "FSlotData": {
      "type": "object",
      "properties": {
        "PingColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The color of the players ping"
        },
        "NametagColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The color of the players nametag above their head, and in the UI"
        }
      },
      "required": [
        "NametagColor",
        "PingColor"
      ]
    },
    "UFGTutorialSubsystem": {
      "type": "object",
      "properties": {
        "mBuildingsBuilt": {
          "description": "classes of things we have build",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mHasSeenIntroTutorial": {
          "description": "Used to indicate if we should push the intro messages",
          "type": "boolean"
        },
        "mIntroTutorialMessages": {
          "description": "Messages to display when first starting the game",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mTutorialData": {
          "description": "In this array we specify what buildings we want in-game tutorial for",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTutorialData"
          }
        },
        "mOwningPlayerState": {
          "$ref": "#/definitions/AFGPlayerState",
          "description": "Needed to set up delegates"
        }
      },
      "required": [
        "mBuildingsBuilt",
        "mHasSeenIntroTutorial",
        "mIntroTutorialMessages",
        "mOwningPlayerState",
        "mTutorialData"
      ]
    },
    "FTutorialData": {
      "type": "object",
      "properties": {
        "ClassBuilt": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "MessageID": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "ClassBuilt",
        "MessageID"
      ]
    },
    "FMessageData": {
      "type": "object",
      "properties": {
        "WasRead": {
          "description": "Has message been read",
          "type": "boolean"
        },
        "MessageClass": {
          "description": "What class is the message",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "MessageClass",
        "WasRead"
      ]
    },
    "FFluidBox": {
      "type": "object"
    },
    "UFGReplicationDetailInventoryComponent": {
      "type": "object"
    },
    "UFGColoredInstanceMeshProxy": {
      "type": "object",
      "properties": {
        "mCanBecolored": {
          "type": "boolean"
        },
        "mBlockInstancing": {
          "type": "boolean"
        }
      },
      "required": [
        "mBlockInstancing",
        "mCanBecolored"
      ]
    },
    "FFoundationSideSelectionFlags": {
      "description": "Disable snapping on specific sides.",
      "type": "object",
      "properties": {
        "Front": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Right": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Back": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Left": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Top": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "Bottom": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "Back",
        "Bottom",
        "Front",
        "Left",
        "Right",
        "Top"
      ]
    },
    "AFGBuildableTradingPost": {
      "type": "object",
      "properties": {
        "mDefaultGeneratorRecipe": {
          "description": "Class of generators to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mGenerators": {
          "description": "References to the created generators",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableGenerator"
          }
        },
        "mDefaultStorageRecipe": {
          "description": "Class of storage to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultHubTerminalRecipe": {
          "description": "Class of hub terminal to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultWorkBenchRecipe": {
          "description": "Class of work bench to create with the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStorage": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "References to the created storage"
        },
        "mHubTerminal": {
          "$ref": "#/definitions/AFGBuildableHubTerminal",
          "description": "References to the created Hub Terminal"
        },
        "mWorkBench": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "References to the created work bench"
        },
        "mGeneratorVisibilityLevels": {
          "description": "Arrays containing ints for what level  we should activate/show the generator",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mStorageInventorySize": {
          "description": "Size of the storage box",
          "type": "number"
        },
        "mStorageVisibilityLevel": {
          "description": "At what trading post level should the storage be visible",
          "type": "number"
        },
        "mInputInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "Our input inventory where items are stored before put on ship"
        },
        "mSpawningGroundZOffset": {
          "description": "How far above the ground the spawn-points should be adjusted",
          "type": "number"
        },
        "mGroundSearchZDistance": {
          "description": "How much up and down we should search for the ground around all child actors that's spawning AFGPlayerStartTradingPost",
          "type": "number"
        },
        "mSchematicManager": {
          "$ref": "#/definitions/AFGSchematicManager",
          "description": "A cached schematic manager"
        },
        "mStorageInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in."
        },
        "mDefaultResources": {
          "description": "The starting resources in the tradingpost storage",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mGenerator1Location": {
          "description": "Component used to determine generators location"
        },
        "mGenerator2Location": {
          "description": "Component used to determine generators location"
        },
        "mStorageLocation": {
          "description": "Component used to determine storage location"
        },
        "mHubTerminalLocation": {
          "description": "Component used to determine Hub terminal location"
        },
        "mWorkBenchLocation": {
          "description": "Component used to determine work bench terminal location"
        },
        "mNeedPlayingBuildEffectNotification": {
          "description": "Bool to sync playing of build and upgrade effects",
          "type": "boolean"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDefaultGeneratorRecipe",
        "mDefaultHubTerminalRecipe",
        "mDefaultResources",
        "mDefaultStorageRecipe",
        "mDefaultWorkBenchRecipe",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mGenerator1Location",
        "mGenerator2Location",
        "mGeneratorVisibilityLevels",
        "mGenerators",
        "mGroundSearchZDistance",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mHubTerminal",
        "mHubTerminalLocation",
        "mInputInventory",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNeedPlayingBuildEffectNotification",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSchematicManager",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mSpawningGroundZOffset",
        "mStorage",
        "mStorageInventory",
        "mStorageInventorySize",
        "mStorageLocation",
        "mStorageVisibilityLevel",
        "mTimeSinceStartStopProducing",
        "mWorkBench",
        "mWorkBenchLocation"
      ]
    },
    "AFGBuildableGenerator": {
      "type": "object",
      "properties": {
        "mPowerProduction": {
          "description": "Amount of power this generator produces in MW.",
          "type": "number"
        },
        "mPowerProductionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mLoadPercentage": {
          "description": "Current load of this generator in the range [0,1].",
          "type": "number"
        },
        "mIsFuseTriggered": {
          "description": "Is the fuse triggered.",
          "type": "boolean"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsFuseTriggered",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mLoadPercentage",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPowerProduction",
        "mPowerProductionExponent",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableHubTerminal": {
      "type": "object",
      "properties": {
        "mTradingPost": {
          "$ref": "#/definitions/AFGBuildableTradingPost"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mTradingPost"
      ]
    },
    "AFGSchematicManager": {
      "type": "object",
      "properties": {
        "PurchasedSchematicDelegate": {
          "description": "Called when we players are granted a schematic."
        },
        "PaidOffOnSchematicDelegate": {
          "description": "Called when a payment on a schematic occurs"
        },
        "mAllSchematics": {
          "description": "All schematic assets that have been sucked up in the PopulateSchematicsList function. Contains cheats and all sort of schematic.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mAvailableSchematics": {
          "description": "All schematics that are available to the player",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mPurchasedSchematics": {
          "description": "Once schematic is purchased it ends up here",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mPaidOffSchematic": {
          "description": "This keeps track of what players have paid off on different schematics",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSchematicCost"
          }
        },
        "mActiveSchematic": {
          "description": "The active schematic the resources is being sold towards.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mOnActiveSchematicChanged": {
          "description": "Called when we the schematic has been changed ."
        },
        "mShipLandTimeStamp": {
          "description": "Time stamp for when the ship is gonna land back at the Trading Post.",
          "type": "number"
        },
        "mShipLandTimeStampSave": {
          "description": "Used to save the ship land timestamp",
          "type": "number"
        },
        "mHasTechTierLimit": {
          "type": "boolean"
        },
        "mMaxAllowedTechTier": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mShipReturnedMessage": {
          "description": "Message sent when trading post ship has returned",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "PaidOffOnSchematicDelegate",
        "PurchasedSchematicDelegate",
        "mActiveSchematic",
        "mAllSchematics",
        "mAvailableSchematics",
        "mHasTechTierLimit",
        "mMaxAllowedTechTier",
        "mOnActiveSchematicChanged",
        "mPaidOffSchematic",
        "mPurchasedSchematics",
        "mShipLandTimeStamp",
        "mShipLandTimeStampSave",
        "mShipReturnedMessage"
      ]
    },
    "FSchematicCost": {
      "description": "Holds info about a schematic and How much has been paid of on it.",
      "type": "object",
      "properties": {
        "Schematic": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ItemCost": {
          "description": "Amount paid off",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        }
      },
      "required": [
        "ItemCost",
        "Schematic"
      ]
    },
    "FQuantizedPipelineIndicatorData": {
      "type": "object",
      "properties": {
        "PackedFlow": {
          "description": "See setters for how this data is packed.",
          "type": "number"
        },
        "PackedContent": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "PackedContent",
        "PackedFlow"
      ]
    },
    "FStringPair": {
      "type": "object",
      "properties": {
        "WwiseSafeName": {
          "type": "string"
        },
        "ActualName": {
          "type": "string"
        }
      },
      "required": [
        "ActualName",
        "WwiseSafeName"
      ]
    },
    "FQuantizedPumpIndicatorData": {
      "type": "object",
      "properties": {
        "PackedFlow": {
          "description": "See setters for how this data is packed.",
          "type": "number"
        },
        "PackedPressure": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "PackedFlow",
        "PackedPressure"
      ]
    },
    "FQuantizedReservoirIndicatorData": {
      "type": "object",
      "properties": {
        "PackedFlowFill": {
          "description": "See setters for how this data is packed.",
          "type": "number"
        },
        "PackedFlowDrain": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "PackedContent": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        }
      },
      "required": [
        "PackedContent",
        "PackedFlowDrain",
        "PackedFlowFill"
      ]
    },
    "UFGPowerConnectionComponent": {
      "type": "object",
      "properties": {
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent"
        },
        "mMaxNumConnectionLinks": {
          "description": "How many connections this component can have connected.",
          "type": "number"
        },
        "mIsHiddenConnection": {
          "description": "This connection is hidden and can only be connected through the code. E.g. powered walls have a hidden connection all machines connect to.",
          "type": "boolean"
        },
        "mWires": {
          "description": "The wired connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableWire"
          }
        },
        "mNbWiresConnected": {
          "description": "The wired connections to this.",
          "type": "number"
        },
        "mHiddenConnections": {
          "description": "The non-wired (if this or the other is hidden) connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuitConnectionComponent"
          }
        },
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        }
      },
      "required": [
        "mCircuitID",
        "mHiddenConnections",
        "mIsHiddenConnection",
        "mMaxNumConnectionLinks",
        "mNbWiresConnected",
        "mPowerInfo",
        "mWires"
      ]
    },
    "AFGBuildableWire": {
      "type": "object",
      "properties": {
        "mMaxLength": {
          "description": "Maximum length a wire may be. [cm]",
          "type": "number"
        },
        "mLengthPerCost": {
          "description": "How much length we get per unit cost, 0 to disable per length cost. [cm]",
          "type": "number"
        },
        "mWireMesh": {
          "description": "Mesh used to visualize the power line"
        },
        "mConnections": {
          "description": "Reference to an instance of a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLocations": {
          "$ref": "#/definitions/Vector",
          "description": "The two locations this wire span."
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnections",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mLengthPerCost",
        "mLocations",
        "mMaterialNameToInstanceManager",
        "mMaxLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mWireMesh"
      ]
    },
    "UFGCircuitConnectionComponent": {
      "type": "object",
      "properties": {
        "mMaxNumConnectionLinks": {
          "description": "How many connections this component can have connected.",
          "type": "number"
        },
        "mIsHiddenConnection": {
          "description": "This connection is hidden and can only be connected through the code. E.g. powered walls have a hidden connection all machines connect to.",
          "type": "boolean"
        },
        "mWires": {
          "description": "The wired connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableWire"
          }
        },
        "mNbWiresConnected": {
          "description": "The wired connections to this.",
          "type": "number"
        },
        "mHiddenConnections": {
          "description": "The non-wired (if this or the other is hidden) connections to this.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuitConnectionComponent"
          }
        },
        "mCircuitID": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        }
      },
      "required": [
        "mCircuitID",
        "mHiddenConnections",
        "mIsHiddenConnection",
        "mMaxNumConnectionLinks",
        "mNbWiresConnected",
        "mWires"
      ]
    },
    "UFGSplineComponent": {
      "type": "object",
      "properties": {
        "mSplineMesh": {
          "description": "The mesh to repeat on curved sections.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSplineMeshLength": {
          "description": "The size of each spline mesh.",
          "type": "number"
        },
        "mGenerateCollisions": {
          "description": "Spacing between the collision components.",
          "type": "boolean"
        },
        "mCollisionSpacing": {
          "description": "Spacing between the collision components.",
          "type": "number"
        },
        "mCollisionExtent": {
          "$ref": "#/definitions/Vector",
          "description": "Extent of the collision components. X is forward."
        },
        "mCollisionOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Offset of the collision components. X is forward."
        },
        "mOverrideMaterial": {
          "description": "The cached material, we cache this as the number of meshes grow/shrink as we drag the conveyor belt."
        },
        "mUseInstancing": {
          "description": "Whether to use instancing or not.",
          "type": "boolean"
        },
        "mSplineMeshComponents": {
          "description": "The meshes that make up the spline.",
          "type": "array",
          "items": {}
        },
        "mCustomDepthSplineMeshComponents": {
          "description": "If we have enabled custom depth pass, then we store the custom depth spline meshes here",
          "type": "array",
          "items": {}
        },
        "mSplineMeshInstances": {
          "description": "The meshes that make up the spline when instanced."
        },
        "mCustomDepthSplineMeshInstances": {
          "description": "If we have enabled custom depth pass, this will be non-null"
        },
        "mSplineCollisionComponents": {
          "description": "The collisions that make up the spline.",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "mCollisionExtent",
        "mCollisionOffset",
        "mCollisionSpacing",
        "mCustomDepthSplineMeshComponents",
        "mCustomDepthSplineMeshInstances",
        "mGenerateCollisions",
        "mOverrideMaterial",
        "mSplineCollisionComponents",
        "mSplineMesh",
        "mSplineMeshComponents",
        "mSplineMeshInstances",
        "mSplineMeshLength",
        "mUseInstancing"
      ]
    },
    "AFGTrainStationIdentifier": {
      "type": "object",
      "properties": {
        "mStation": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "The station this info represents."
        },
        "mTrackGraphID": {
          "description": "The track this station is on.",
          "type": "number"
        },
        "mStationName": {
          "description": "Cached here for clients.",
          "type": "string"
        }
      },
      "required": [
        "mStation",
        "mStationName",
        "mTrackGraphID"
      ]
    },
    "AFGBuildableRailroadStation": {
      "type": "object",
      "properties": {
        "mStationIdentifier": {
          "$ref": "#/definitions/AFGTrainStationIdentifier",
          "description": "Light weight representation about this station, the railroad subsystem is responsible for this."
        },
        "mDockedPlatformList": {
          "description": "When docked, this station will fill this array with every potential platform in its tail. 1 for each train segment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableTrainPlatform"
          }
        },
        "mDockingLocomotive": {
          "$ref": "#/definitions/AFGLocomotive",
          "description": "Reference to the docked locomotive."
        },
        "mRailroadTrack": {
          "$ref": "#/definitions/AFGBuildableRailroadTrack"
        },
        "mPlatformConnections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGTrainPlatformConnection"
          }
        },
        "mPlatformConnection0": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mPlatformConnection1": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mDockedRailroadVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle"
        },
        "mStationDockingMaster": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "Stores a reference to the station that initiated a docking sequence. Used to notify the station that we have completed"
        },
        "mIsOrientationReversed": {
          "description": "Is this platform reversed from its attached station?",
          "type": "boolean"
        },
        "mPlatformDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "Where are we in the docking status. Updated by the mDockingSequenceTimer which is set by NotifyTrainDocked"
        },
        "mSavedDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "However since it also drives the anim blueprint undesired anim starts are triggered if we save / modify the actually used mPlatformDockingStatus"
        },
        "mDockingSequenceTimerHandle": {
          "description": "Timer handle that is set and retriggered over the course of a docking sequence"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDockedPlatformList",
        "mDockedRailroadVehicle",
        "mDockingLocomotive",
        "mDockingSequenceTimerHandle",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsOrientationReversed",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPlatformConnection0",
        "mPlatformConnection1",
        "mPlatformConnections",
        "mPlatformDockingStatus",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mRailroadTrack",
        "mReplicationDetailActor",
        "mSavedDockingStatus",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mStationDockingMaster",
        "mStationIdentifier",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableTrainPlatform": {
      "type": "object",
      "properties": {
        "mRailroadTrack": {
          "$ref": "#/definitions/AFGBuildableRailroadTrack"
        },
        "mPlatformConnections": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGTrainPlatformConnection"
          }
        },
        "mPlatformConnection0": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mPlatformConnection1": {
          "$ref": "#/definitions/UFGTrainPlatformConnection"
        },
        "mDockedRailroadVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle"
        },
        "mStationDockingMaster": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "Stores a reference to the station that initiated a docking sequence. Used to notify the station that we have completed"
        },
        "mIsOrientationReversed": {
          "description": "Is this platform reversed from its attached station?",
          "type": "boolean"
        },
        "mPlatformDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "Where are we in the docking status. Updated by the mDockingSequenceTimer which is set by NotifyTrainDocked"
        },
        "mSavedDockingStatus": {
          "$ref": "#/definitions/ETrainPlatformDockingStatus",
          "description": "However since it also drives the anim blueprint undesired anim starts are triggered if we save / modify the actually used mPlatformDockingStatus"
        },
        "mDockingSequenceTimerHandle": {
          "description": "Timer handle that is set and retriggered over the course of a docking sequence"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mDockedRailroadVehicle",
        "mDockingSequenceTimerHandle",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsOrientationReversed",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPlatformConnection0",
        "mPlatformConnection1",
        "mPlatformConnections",
        "mPlatformDockingStatus",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mRailroadTrack",
        "mReplicationDetailActor",
        "mSavedDockingStatus",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mStationDockingMaster",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableRailroadTrack": {
      "type": "object",
      "properties": {
        "mMesh": {
          "description": "Mesh to use for his track.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this track",
          "type": "number"
        },
        "mSplineComponent": {
          "description": "The spline component for this train track."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mSplineData": {
          "description": "Spline data saved in a compact form for saving and replicating. All the vectors are in local space.",
          "type": "array",
          "items": {}
        },
        "mConnections": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "This tracks connection component."
        },
        "mIsOwnedByPlatform": {
          "description": "Was this track created and is owned by a platform.",
          "type": "boolean"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnections",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsOwnedByPlatform",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSplineComponent",
        "mSplineData"
      ]
    },
    "UFGRailroadTrackConnectionComponent": {
      "type": "object",
      "properties": {
        "mRailRoadSwitchDelegate": {
          "description": "Delegate to fire when changing switch on a track"
        },
        "mConnectedComponents": {
          "description": "The components we're connected to. If >1 this is a switch.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGRailroadTrackConnectionComponent"
          }
        },
        "mSwitchPosition": {
          "description": "If this is a switch, this is the switch position.",
          "type": "number"
        },
        "mSwitchControl": {
          "$ref": "#/definitions/AFGBuildableRailroadSwitchControl",
          "description": "The switch control associated with this connection, if any."
        },
        "mStation": {
          "$ref": "#/definitions/AFGBuildableRailroadStation",
          "description": "The station associated with this connection, if any."
        },
        "mSignal": {
          "$ref": "#/definitions/AFGBuildableRailroadSignal",
          "description": "The signal associated with this connection, if any."
        }
      },
      "required": [
        "mConnectedComponents",
        "mRailRoadSwitchDelegate",
        "mSignal",
        "mStation",
        "mSwitchControl",
        "mSwitchPosition"
      ]
    },
    "AFGBuildableRailroadSwitchControl": {
      "type": "object",
      "properties": {
        "mControlledConnection": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "Connection we control."
        },
        "mSwitchPosition": {
          "description": "Current switch position read from the controlled connection, polled each tick.",
          "type": "number"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mControlledConnection",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mSwitchPosition",
        "mTimeSinceStartStopProducing"
      ]
    },
    "AFGBuildableRailroadSignal": {
      "type": "object",
      "properties": {
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect"
      ]
    },
    "UFGTrainPlatformConnection": {
      "type": "object",
      "properties": {
        "mComponentDirection": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mPlatformConnectionStatus": {
          "$ref": "#/definitions/ETrainPlatformConnectionType",
          "description": "Enum indicating the status of this connection"
        },
        "platformOwner": {
          "$ref": "#/definitions/AFGBuildableTrainPlatform",
          "description": "store a reference to the owner of this connection as a FGBuildableTrainPlatform, not a UProperty as this is our Owning actor cached so we don't need to keep casting"
        },
        "mRailroadTrackConnection": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "Stores a reference to the track connection (Not a Uproperty because the reference exists in the railroad track)"
        },
        "mConnectedTo": {
          "$ref": "#/definitions/UFGTrainPlatformConnection",
          "description": "Stores a reference to the connected platform component, if there is one (Not a UProperty as this is just a reference to an external component)"
        }
      },
      "required": [
        "mComponentDirection",
        "mConnectedTo",
        "mPlatformConnectionStatus",
        "mRailroadTrackConnection",
        "platformOwner"
      ]
    },
    "ETrainPlatformConnectionType": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "AFGRailroadVehicle": {
      "type": "object",
      "properties": {
        "mTrain": {
          "$ref": "#/definitions/AFGTrain",
          "description": "The train this vehicle is part of, updated from the railroad subsystem"
        },
        "mLength": {
          "description": "How long is this vehicle.",
          "type": "number"
        },
        "mIsOrientationReversed": {
          "description": "If this vehicle is reversed in the train formation.",
          "type": "boolean"
        },
        "mTrackPosition": {
          "$ref": "#/definitions/FRailroadTrackPosition",
          "description": "Where along the track is the train."
        },
        "mDisplayName": {
          "description": "The human readable name for this vehicle.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description for this vehicle.",
          "type": "string"
        },
        "mHologramClass": {
          "description": "Hologram to build this class with.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh": {
          "description": "The main skeletal mesh associated with this Vehicle"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mDisabledByWaterLocations": {
          "description": "If any of these locations enters water, then we are unusable",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this vehicle was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mIsSelfDriving": {
          "description": "If this vehicle is self driving.",
          "type": "boolean"
        },
        "mSelfDrivingController": {
          "description": "The AI that controls this vehicle when self-driving is activated."
        },
        "mStoredPhysicsData": {
          "description": "Saved like this, as we can't store it in serialize, as it will be killed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehiclePhysicsData"
          }
        },
        "mConstructSound": {
          "description": "Sound played when this vehicle is created"
        },
        "mIsDestructible": {
          "description": "Can this vehicle be destroyed by damage?",
          "type": "number"
        },
        "mIsSubmergedInWater": {
          "description": "If true, then we are submerged in water",
          "type": "number"
        },
        "mSubmergedAngularDamping": {
          "description": "increased angular damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedLinearDamping": {
          "description": "increased linear damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedBouyantForce": {
          "description": "upwards force applied to vehicles when underwater",
          "type": "number"
        },
        "mGasDamageType": {
          "description": "Gas damage typ that should be redirected to the driver",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the vehicle should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this vehicle should be significant within",
          "type": "number"
        },
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mAddToSignificanceManager",
        "mBuiltWithRecipe",
        "mConstructSound",
        "mDescription",
        "mDisabledByWaterLocations",
        "mDisplayName",
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mGasDamageType",
        "mHealthComponent",
        "mHologramClass",
        "mIsDestructible",
        "mIsDriverVisible",
        "mIsDriving",
        "mIsOrientationReversed",
        "mIsSelfDriving",
        "mIsSubmergedInWater",
        "mLength",
        "mMesh",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mSelfDrivingController",
        "mShouldAttachDriver",
        "mSignificanceBias",
        "mSignificanceRange",
        "mStoredPhysicsData",
        "mSubmergedAngularDamping",
        "mSubmergedBouyantForce",
        "mSubmergedLinearDamping",
        "mTrackPosition",
        "mTrain"
      ]
    },
    "AFGTrain": {
      "type": "object",
      "properties": {
        "mOnSelfDrivingChanged": {
          "description": "Called when the self driving is turn on or off."
        },
        "mOnDockingStateChanged": {
          "description": "Called when the docking state changes."
        },
        "mConsistData": {
          "$ref": "#/definitions/FTrainConsist",
          "description": "Static information about the consist, it changes when rolling stock is added/removed or a container is loaded/unloaded."
        },
        "mAtcData": {
          "$ref": "#/definitions/FTrainAtcData",
          "description": "Runtime data for the automatic train control. See struct for more info."
        },
        "mSimulationData": {
          "$ref": "#/definitions/FTrainSimulationData",
          "description": "Physics simulation for the train"
        },
        "mTrainName": {
          "description": "The name of this train.",
          "type": "string"
        },
        "mTrackGraphID": {
          "description": "The track this train is on.",
          "type": "number"
        },
        "FirstVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle",
          "description": "Train are a doubly linked list, use TTrainIterator to iterate over a train."
        },
        "LastVehicle": {
          "$ref": "#/definitions/AFGRailroadVehicle"
        },
        "mMultipleUnitMaster": {
          "$ref": "#/definitions/AFGLocomotive",
          "description": "This is the master locomotives that sends its input (throttle/brake/etc) to all other locomotives in the train."
        },
        "TimeTable": {
          "$ref": "#/definitions/AFGRailroadTimeTable",
          "description": "This trains time table."
        },
        "mIsSelfDrivingEnabled": {
          "description": "Is this train self driving",
          "type": "boolean"
        },
        "mSelfDrivingError": {
          "$ref": "#/definitions/ESelfDrivingLocomotiveError",
          "description": "Error reported by the AI."
        },
        "mDockingState": {
          "$ref": "#/definitions/ETrainDockingState",
          "description": "The status for an ongoing dock, this is not saved, it's updated from the station we're docked to on load."
        },
        "mSoundComponent": {
          "$ref": "#/definitions/UFGRailroadVehicleSoundComponent",
          "description": "Sound component controlling all the moving/idle sounds for the train"
        }
      },
      "required": [
        "FirstVehicle",
        "LastVehicle",
        "TimeTable",
        "mAtcData",
        "mConsistData",
        "mDockingState",
        "mIsSelfDrivingEnabled",
        "mMultipleUnitMaster",
        "mOnDockingStateChanged",
        "mOnSelfDrivingChanged",
        "mSelfDrivingError",
        "mSimulationData",
        "mSoundComponent",
        "mTrackGraphID",
        "mTrainName"
      ]
    },
    "FTrainConsist": {
      "type": "object",
      "properties": {
        "Vehicles": {
          "description": "The vehicles in this consist.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "Length": {
          "description": "Length of the consist, [cm]",
          "type": "number"
        },
        "Mass": {
          "description": "Mass of the consist, [kg]",
          "type": "number"
        },
        "MaxSpeed": {
          "description": "Maximum speed for the slowest vehicle in the consist. [cm/s]",
          "type": "number"
        }
      },
      "required": [
        "Length",
        "Mass",
        "MaxSpeed",
        "Vehicles"
      ]
    },
    "FTrainAtcData": {
      "type": "object"
    },
    "FTrainSimulationData": {
      "type": "object",
      "properties": {
        "SimulatedVehicles": {
          "description": "Cached vehicles in the direction of travel.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGRailroadVehicle"
          }
        },
        "SimulatedMovements": {
          "description": "Cached movements in the same order as the vehicles.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGRailroadVehicleMovementComponent"
          }
        },
        "MasterMovement": {
          "$ref": "#/definitions/UFGLocomotiveMovementComponent",
          "description": "Cached master locomotive."
        },
        "Velocity": {
          "description": "Velocity of this train [directional] [cm/s]",
          "type": "number"
        }
      },
      "required": [
        "MasterMovement",
        "SimulatedMovements",
        "SimulatedVehicles",
        "Velocity"
      ]
    },
    "UFGRailroadVehicleMovementComponent": {
      "type": "object",
      "properties": {
        "mWheelsetSetups": {
          "description": "Wheelsets for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FWheelsetSetup"
          }
        },
        "mWheelRadius": {
          "description": "The radius of the wheels. [cm]",
          "type": "number"
        },
        "mCouplerSetups": {
          "description": "Couplers for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FCouplerSetup"
          }
        },
        "mMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxVelocity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPayloadMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mDragCoefficient": {
          "description": "DragCoefficient of the vehicle chassis. Good values [0.4, 0.8].",
          "type": "number"
        },
        "mChassisWidth": {
          "description": "Chassis width used for drag force computation. [cm]",
          "type": "number"
        },
        "mChassisHeight": {
          "description": "Chassis height used for drag force computation. [cm]",
          "type": "number"
        },
        "mRollingResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along the track. Good values [0.0010, 0.0024].",
          "type": "number"
        },
        "mCurvatureResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along a curved track. Good values [0.0001, 0.0004].",
          "type": "number"
        },
        "mMaxAirBrakingEffort": {
          "description": "The maximum air braking force that can be delivered. [kN] [kg m/s^2\n  1000]",
          "type": "number"
        }
      },
      "required": [
        "mChassisHeight",
        "mChassisWidth",
        "mCouplerSetups",
        "mCurvatureResistanceCoefficient",
        "mDragCoefficient",
        "mMass",
        "mMaxAirBrakingEffort",
        "mMaxVelocity",
        "mPayloadMass",
        "mRollingResistanceCoefficient",
        "mWheelRadius",
        "mWheelsetSetups"
      ]
    },
    "FWheelsetSetup": {
      "type": "object",
      "properties": {
        "BoneName": {
          "description": "Bone name on mesh where the wheelset/bogie is located.",
          "type": "string"
        },
        "CanSwivel": {
          "description": "Is this wheel set a bogie.",
          "type": "boolean"
        }
      },
      "required": [
        "BoneName",
        "CanSwivel"
      ]
    },
    "FCouplerSetup": {
      "type": "object",
      "properties": {
        "BoneName": {
          "description": "Bone name on mesh where the coupler's base is attached.",
          "type": "string"
        },
        "Length": {
          "description": "How long is the couplers arm, from the bone to the point where is attaches to the other coupler.",
          "type": "number"
        }
      },
      "required": [
        "BoneName",
        "Length"
      ]
    },
    "UFGLocomotiveMovementComponent": {
      "type": "object",
      "properties": {
        "mReplicatedState": {
          "$ref": "#/definitions/FReplicatedRailroadVehicleState",
          "description": "replicated state of vehicle"
        },
        "mRawReverserInput": {
          "description": "What the player has the reverser set to. Values -1, 0, 1",
          "type": "number"
        },
        "mRawSteeringInput": {
          "description": "What the player has the steering set to. Range -1...1",
          "type": "number"
        },
        "mRawThrottleInput": {
          "description": "What the player has the accelerator set to. Range -1...1",
          "type": "number"
        },
        "mRawDynamicBrakeInput": {
          "description": "What the dynamic brake input is set to.",
          "type": "number"
        },
        "mRawAirBrakeInput": {
          "description": "What the air brake input is set to.",
          "type": "number"
        },
        "mThrottleInputRate": {
          "$ref": "#/definitions/FRailroadVehicleInputRate",
          "description": "Rate at which input throttle can rise and fall."
        },
        "mDynamicBrakeInputRate": {
          "$ref": "#/definitions/FRailroadVehicleInputRate",
          "description": "Rate at which input dynamic brake can rise and fall."
        },
        "mDynamicBrakeVelocityThreshold": {
          "description": "Velocity at which the dynamic brake can be engaged.",
          "type": "number"
        },
        "mAirBrakeInputRate": {
          "$ref": "#/definitions/FRailroadVehicleInputRate",
          "description": "Rate at which input air brake can rise and fall."
        },
        "mReverserInput": {
          "description": "Reversing control output to physics system. -1, 0, 1",
          "type": "number"
        },
        "mSteeringInput": {
          "description": "Steering output to physics system. Range -1...1",
          "type": "number"
        },
        "mThrottleInput": {
          "description": "Accelerator output to physics system. Range 0...1",
          "type": "number"
        },
        "mAirBrakeInput": {
          "description": "Air brake output to physics system. Range 0...1",
          "type": "number"
        },
        "mDynamicBrakeInput": {
          "description": "Dynamic brake output to physics system. Range 0...1",
          "type": "number"
        },
        "mTractiveEffortCurve": {
          "description": "The maximum tractive force [kN] [kg m/s^2\n  1000] that can be delivered at a given speed [km/h]."
        },
        "mDynamicBrakingEffortCurve": {
          "description": "The maximum dynamic braking force [kN] [kg m/s^2\n  1000] that can be delivered at a given speed [km/h]."
        },
        "mWheelsetSetups": {
          "description": "Wheelsets for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FWheelsetSetup"
          }
        },
        "mWheelRadius": {
          "description": "The radius of the wheels. [cm]",
          "type": "number"
        },
        "mCouplerSetups": {
          "description": "Couplers for this train. Front is 0 and back is 1.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FCouplerSetup"
          }
        },
        "mMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxVelocity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPayloadMass": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mDragCoefficient": {
          "description": "DragCoefficient of the vehicle chassis. Good values [0.4, 0.8].",
          "type": "number"
        },
        "mChassisWidth": {
          "description": "Chassis width used for drag force computation. [cm]",
          "type": "number"
        },
        "mChassisHeight": {
          "description": "Chassis height used for drag force computation. [cm]",
          "type": "number"
        },
        "mRollingResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along the track. Good values [0.0010, 0.0024].",
          "type": "number"
        },
        "mCurvatureResistanceCoefficient": {
          "description": "The rolling resistance coefficient for rolling the wheels along a curved track. Good values [0.0001, 0.0004].",
          "type": "number"
        },
        "mMaxAirBrakingEffort": {
          "description": "The maximum air braking force that can be delivered. [kN] [kg m/s^2\n  1000]",
          "type": "number"
        }
      },
      "required": [
        "mAirBrakeInput",
        "mAirBrakeInputRate",
        "mChassisHeight",
        "mChassisWidth",
        "mCouplerSetups",
        "mCurvatureResistanceCoefficient",
        "mDragCoefficient",
        "mDynamicBrakeInput",
        "mDynamicBrakeInputRate",
        "mDynamicBrakeVelocityThreshold",
        "mDynamicBrakingEffortCurve",
        "mMass",
        "mMaxAirBrakingEffort",
        "mMaxVelocity",
        "mPayloadMass",
        "mRawAirBrakeInput",
        "mRawDynamicBrakeInput",
        "mRawReverserInput",
        "mRawSteeringInput",
        "mRawThrottleInput",
        "mReplicatedState",
        "mReverserInput",
        "mRollingResistanceCoefficient",
        "mSteeringInput",
        "mThrottleInput",
        "mThrottleInputRate",
        "mTractiveEffortCurve",
        "mWheelRadius",
        "mWheelsetSetups"
      ]
    },
    "FReplicatedRailroadVehicleState": {
      "type": "object",
      "properties": {
        "ReverserInput": {
          "description": "input replication: steering",
          "type": "number"
        },
        "SteeringInput": {
          "description": "input replication: steering",
          "type": "number"
        },
        "ThrottleInput": {
          "description": "input replication: throttle",
          "type": "number"
        },
        "DynamicBrakeInput": {
          "description": "input replication: dynamic brakes",
          "type": "number"
        },
        "AirBrakeInput": {
          "description": "input replication: air brakes",
          "type": "number"
        }
      },
      "required": [
        "AirBrakeInput",
        "DynamicBrakeInput",
        "ReverserInput",
        "SteeringInput",
        "ThrottleInput"
      ]
    },
    "FRailroadVehicleInputRate": {
      "type": "object",
      "properties": {
        "RiseRate": {
          "description": "Rate at which the input value rises",
          "type": "number"
        },
        "FallRate": {
          "description": "Rate at which the input value falls",
          "type": "number"
        }
      },
      "required": [
        "FallRate",
        "RiseRate"
      ]
    },
    "AFGLocomotive": {
      "type": "object",
      "properties": {
        "mPowerConsumption": {
          "description": "The power consumption of this electric locomotive, min is idle power consumption and max is power consumption at maximum torque."
        },
        "mSlidingShoe": {
          "$ref": "#/definitions/UFGPowerConnectionComponent",
          "description": "The sliding shoe making contact with the third rail."
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "The power info for this train, draw power from the circuit."
        },
        "mReplicatedMovementTransform": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mVehicleMovement": {
          "$ref": "#/definitions/UFGLocomotiveMovementComponent",
          "description": "vehicle simulation component"
        },
        "mTrain": {
          "$ref": "#/definitions/AFGTrain",
          "description": "The train this vehicle is part of, updated from the railroad subsystem"
        },
        "mLength": {
          "description": "How long is this vehicle.",
          "type": "number"
        },
        "mIsOrientationReversed": {
          "description": "If this vehicle is reversed in the train formation.",
          "type": "boolean"
        },
        "mTrackPosition": {
          "$ref": "#/definitions/FRailroadTrackPosition",
          "description": "Where along the track is the train."
        },
        "mDisplayName": {
          "description": "The human readable name for this vehicle.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description for this vehicle.",
          "type": "string"
        },
        "mHologramClass": {
          "description": "Hologram to build this class with.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh": {
          "description": "The main skeletal mesh associated with this Vehicle"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mDisabledByWaterLocations": {
          "description": "If any of these locations enters water, then we are unusable",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this vehicle was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mIsSelfDriving": {
          "description": "If this vehicle is self driving.",
          "type": "boolean"
        },
        "mSelfDrivingController": {
          "description": "The AI that controls this vehicle when self-driving is activated."
        },
        "mStoredPhysicsData": {
          "description": "Saved like this, as we can't store it in serialize, as it will be killed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehiclePhysicsData"
          }
        },
        "mConstructSound": {
          "description": "Sound played when this vehicle is created"
        },
        "mIsDestructible": {
          "description": "Can this vehicle be destroyed by damage?",
          "type": "number"
        },
        "mIsSubmergedInWater": {
          "description": "If true, then we are submerged in water",
          "type": "number"
        },
        "mSubmergedAngularDamping": {
          "description": "increased angular damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedLinearDamping": {
          "description": "increased linear damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedBouyantForce": {
          "description": "upwards force applied to vehicles when underwater",
          "type": "number"
        },
        "mGasDamageType": {
          "description": "Gas damage typ that should be redirected to the driver",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the vehicle should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this vehicle should be significant within",
          "type": "number"
        },
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mAddToSignificanceManager",
        "mBuiltWithRecipe",
        "mConstructSound",
        "mDescription",
        "mDisabledByWaterLocations",
        "mDisplayName",
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mGasDamageType",
        "mHealthComponent",
        "mHologramClass",
        "mIsDestructible",
        "mIsDriverVisible",
        "mIsDriving",
        "mIsOrientationReversed",
        "mIsSelfDriving",
        "mIsSubmergedInWater",
        "mLength",
        "mMesh",
        "mNetConstructionID",
        "mPowerConsumption",
        "mPowerInfo",
        "mPrimaryColor",
        "mReplicatedMovementTransform",
        "mSecondaryColor",
        "mSelfDrivingController",
        "mShouldAttachDriver",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSlidingShoe",
        "mStoredPhysicsData",
        "mSubmergedAngularDamping",
        "mSubmergedBouyantForce",
        "mSubmergedLinearDamping",
        "mTrackPosition",
        "mTrain",
        "mVehicleMovement"
      ]
    },
    "FRailroadTrackPosition": {
      "type": "object",
      "properties": {
        "Track": {
          "description": "Reference to an instance of a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Offset": {
          "description": "Offset along the track.",
          "type": "number"
        },
        "Forward": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "Forward",
        "Offset",
        "Track"
      ]
    },
    "FVehiclePhysicsData": {
      "description": "Physics data we want to be able to restore, we store the bone name to be able to change the bone structure in updates",
      "type": "object"
    },
    "AFGRailroadTimeTable": {
      "type": "object",
      "properties": {
        "mStops": {
          "description": "Array of destinations this train will visit.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTimeTableStop"
          }
        },
        "mCurrentStop": {
          "description": "Current stop the train is at or heading to.",
          "type": "number"
        }
      },
      "required": [
        "mCurrentStop",
        "mStops"
      ]
    },
    "FTimeTableStop": {
      "type": "object",
      "properties": {
        "Station": {
          "$ref": "#/definitions/AFGTrainStationIdentifier",
          "description": "Where to stop."
        },
        "Duration": {
          "description": "Time to stay.",
          "type": "number"
        }
      },
      "required": [
        "Duration",
        "Station"
      ]
    },
    "ESelfDrivingLocomotiveError": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "ETrainDockingState": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "UFGRailroadVehicleSoundComponent": {
      "type": "object",
      "properties": {
        "mVehicleMovementComponent": {
          "$ref": "#/definitions/UFGRailroadVehicleMovementComponent",
          "description": "Movement component of the first vehicle in the train."
        },
        "mLocomotiveMovementComponent": {
          "$ref": "#/definitions/UFGLocomotiveMovementComponent",
          "description": "Movement component of the first locomotive in the train, may be none."
        },
        "mTrainOwner": {
          "$ref": "#/definitions/AFGTrain",
          "description": "train that owns this component"
        },
        "mWheelsetsAkComponent": {
          "description": "Component to play events on the wheelsets. Location is the bogie bone."
        },
        "mEnginesAkComponent": {
          "description": "Component to play events on the locomotives. Location is the center of the actor bounds (colliding)."
        },
        "mAllVehicleCentersAkComponent": {
          "description": "Component to play events on all the locomotives and wagons. Location is the center of the actor bounds (colliding)."
        }
      },
      "required": [
        "mAllVehicleCentersAkComponent",
        "mEnginesAkComponent",
        "mLocomotiveMovementComponent",
        "mTrainOwner",
        "mVehicleMovementComponent",
        "mWheelsetsAkComponent"
      ]
    },
    "ETrainPlatformDockingStatus": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "AFGResourceSinkSubsystem": {
      "type": "object",
      "properties": {
        "mSchematicManager": {
          "$ref": "#/definitions/AFGSchematicManager",
          "description": "The cached schematic manager"
        },
        "mCouponClass": {
          "description": "The coupon class that we use for buying resource sink schematics",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mTotalResourceSinkPoints": {
          "description": "The total number of resource sink points we have accumulated in total"
        },
        "mCurrentPointLevel": {
          "description": "The current point level we have reached, this value only increases and isn't not affected by printing coupons",
          "type": "number"
        },
        "mNumResourceSinkCoupons": {
          "description": "The number of coupons we have to our disposal to print and use",
          "type": "number"
        },
        "mGlobalPointHistory": {
          "description": "The data for the global points history of the resource sink subsystem",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mResourceSinkPoints": {
          "$ref": "#/definitions/Map<packageReference<UFGItemDescriptor>,number>",
          "description": "Cached points per itemdescriptor"
        },
        "mFailedItemSinkMessages": {
          "$ref": "#/definitions/Map<packageReference<UFGItemDescriptor>,packageReference<UFGMessageBase>>",
          "description": "The messages that should play if the player tries to sink a item that you can't sink"
        },
        "mItemsFailedToSink": {
          "description": "The items that the player tried to sink that you can't sink that is also present in mFailedItemSinkMessages",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mAnyGenericItemsFailedToSink": {
          "description": "Have we ever tried to sink any item that you can't sink that is not present in mFailedItemSinkMessages",
          "type": "boolean"
        },
        "mIsCouponEverSunk": {
          "description": "Have we sunken a item of the coupon class, Used to give a schematic",
          "type": "boolean"
        }
      },
      "required": [
        "mAnyGenericItemsFailedToSink",
        "mCouponClass",
        "mCurrentPointLevel",
        "mFailedItemSinkMessages",
        "mGlobalPointHistory",
        "mIsCouponEverSunk",
        "mItemsFailedToSink",
        "mNumResourceSinkCoupons",
        "mResourceSinkPoints",
        "mSchematicManager",
        "mTotalResourceSinkPoints"
      ]
    },
    "Map<packageReference<UFGItemDescriptor>,number>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<packageReference<UFGItemDescriptor>,packageReference<UFGMessageBase>>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGRoadConnectionComponent": {
      "type": "object"
    },
    "FSignWallData": {
      "type": "object",
      "properties": {
        "TextColorIndex": {
          "description": "Index of the selected color for the text from the FGSignSettings color data array",
          "type": "number"
        },
        "BackgroundColorIndex": {
          "description": "Index of the selected color for the background from the FGSignSettings color data array",
          "type": "number"
        },
        "SignText": {
          "description": "Text to be displayed on the sign",
          "type": "string"
        }
      },
      "required": [
        "BackgroundColorIndex",
        "SignText",
        "TextColorIndex"
      ]
    },
    "AFGGamePhaseManager": {
      "type": "object",
      "properties": {
        "mGamePhase": {
          "$ref": "#/definitions/EGamePhase",
          "description": "Current GamePhase"
        },
        "mGamePhaseTierInfo": {
          "description": "Specifies what game phases are connected to what tiers",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPhaseTierInfo"
          }
        },
        "mGamePhaseCosts": {
          "description": "Speciefies what the different tiers cost",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPhaseCost"
          }
        },
        "mOnGamePhaseChanged": {
          "description": "Called when the game phase is updated"
        }
      },
      "required": [
        "mGamePhase",
        "mGamePhaseCosts",
        "mGamePhaseTierInfo",
        "mOnGamePhaseChanged"
      ]
    },
    "EGamePhase": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5
      ],
      "type": "number"
    },
    "FPhaseTierInfo": {
      "type": "object",
      "properties": {
        "GamePhase": {
          "$ref": "#/definitions/EGamePhase",
          "description": "The phase to specify tier for"
        },
        "LastTierOfPhase": {
          "description": "What is the last tier of the phase specified previously.",
          "type": "number"
        },
        "Name": {
          "description": "Name of this phase.",
          "type": "string"
        },
        "PhaseUnlockedMessage": {
          "description": "Message sent when this phase is unlocked",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "GamePhase",
        "LastTierOfPhase",
        "Name",
        "PhaseUnlockedMessage"
      ]
    },
    "FPhaseCost": {
      "type": "object",
      "properties": {
        "GamePhase": {
          "$ref": "#/definitions/EGamePhase",
          "description": "The phase to specify the cost for"
        },
        "Cost": {
          "description": "Cost of this tier",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        }
      },
      "required": [
        "Cost",
        "GamePhase"
      ]
    },
    "FSplitterSortRule": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "This is the item class to filter out.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "OutputIndex": {
          "description": "Which output to send this to.",
          "type": "number"
        }
      },
      "required": [
        "ItemClass",
        "OutputIndex"
      ]
    },
    "Map<number,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "FSignElementConstraints": {
      "type": "object",
      "properties": {
        "MinTranslationOffset": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "MaxTranslationOffset": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "MinScale": {
          "description": "A floating point number.",
          "type": "number"
        },
        "MaxScale": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "MaxScale",
        "MaxTranslationOffset",
        "MinScale",
        "MinTranslationOffset"
      ]
    },
    "FSignData": {
      "type": "object",
      "properties": {
        "SignLayers": {
          "description": "All additional layers in this sign. Each layer holds an array of all elements in that layer",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignLayer"
          }
        },
        "SignElementData": {
          "description": "All sign elements in this sign",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignElementData"
          }
        },
        "BackgroundColorIndex": {
          "description": "Index of the selected color for the background from the FGSignSettings color data array",
          "type": "number"
        }
      },
      "required": [
        "BackgroundColorIndex",
        "SignElementData",
        "SignLayers"
      ]
    },
    "UFGSignLayer": {
      "type": "object",
      "properties": {
        "mLayerID": {
          "description": "Layer index, used to determine sorting. Layer 0 is the background layer",
          "type": "number"
        },
        "mPixelColumns": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSignPixelColumn"
          }
        },
        "mLayerElements": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignElementData"
          }
        },
        "mPixelDimensions": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "mLayerElements",
        "mLayerID",
        "mPixelColumns",
        "mPixelDimensions"
      ]
    },
    "FSignPixelColumn": {
      "type": "object",
      "properties": {
        "Column": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignPixelData"
          }
        }
      },
      "required": [
        "Column"
      ]
    },
    "UFGSignPixelData": {
      "type": "object",
      "properties": {
        "mDimensions": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mSignElementID": {
          "description": "unique id to identify this element by buildable signs",
          "type": "number"
        },
        "mColorIndex": {
          "description": "Index pointing to a location in the FGSignSettings Color Array",
          "type": "number"
        },
        "mTranslationOffset": {
          "description": "Position offset from center"
        },
        "mRotation": {
          "description": "Roll Rotation",
          "type": "number"
        },
        "mScale": {
          "description": "Global uniform scale factor",
          "type": "number"
        },
        "mEmbeddedInLayer": {
          "description": "If embedded, this indicates that the element should not be given its own element list widget ( tex. the background pixels in layers )",
          "type": "boolean"
        },
        "mIsElementStatic": {
          "type": "boolean"
        }
      },
      "required": [
        "mColorIndex",
        "mDimensions",
        "mEmbeddedInLayer",
        "mIsElementStatic",
        "mRotation",
        "mScale",
        "mSignElementID",
        "mTranslationOffset"
      ]
    },
    "UFGSignElementData": {
      "type": "object",
      "properties": {
        "mSignElementID": {
          "description": "unique id to identify this element by buildable signs",
          "type": "number"
        },
        "mColorIndex": {
          "description": "Index pointing to a location in the FGSignSettings Color Array",
          "type": "number"
        },
        "mTranslationOffset": {
          "description": "Position offset from center"
        },
        "mRotation": {
          "description": "Roll Rotation",
          "type": "number"
        },
        "mScale": {
          "description": "Global uniform scale factor",
          "type": "number"
        },
        "mEmbeddedInLayer": {
          "description": "If embedded, this indicates that the element should not be given its own element list widget ( tex. the background pixels in layers )",
          "type": "boolean"
        },
        "mIsElementStatic": {
          "type": "boolean"
        }
      },
      "required": [
        "mColorIndex",
        "mEmbeddedInLayer",
        "mIsElementStatic",
        "mRotation",
        "mScale",
        "mSignElementID",
        "mTranslationOffset"
      ]
    },
    "AFGBuildableConveyorAttachment": {
      "type": "object",
      "properties": {
        "mBufferInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBufferInventory",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "Map<packageReference<any>,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<packageReference<any>,UFGColoredInstanceManager>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Color": {
      "description": "[FColor](API\\Runtime\\Core\\Math\\FColor) Stores a color with 8 bits of precision per channel.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Core/Math/FColor/index.html",
      "type": "object",
      "properties": {
        "R": {
          "description": "The color's red intensity.",
          "type": "number"
        },
        "G": {
          "description": "The color's green intensity.",
          "type": "number"
        },
        "B": {
          "description": "The color's blue intensity.",
          "type": "number"
        },
        "A": {
          "description": "The color's opacity.",
          "type": "number"
        }
      },
      "required": [
        "A",
        "B",
        "G",
        "R"
      ]
    },
    "FDistanceBasedTickRate": {
      "description": "Distances where we switch tick rate",
      "type": "object",
      "properties": {
        "Distance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "TickRate": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "Distance",
        "TickRate"
      ]
    },
    "EFreightCargoType": {
      "description": "Enum to track the two types of cargo (Standard and Liquid)",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "AFGPipeBuilderTrail": {
      "type": "object",
      "properties": {
        "mPipesToTraverse": {
          "description": "Saved pipelines we have to traverse",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildablePipeline"
          }
        },
        "mCurrentPipeline": {
          "$ref": "#/definitions/AFGBuildablePipeline",
          "description": "Pipeline we are currently traversing"
        },
        "mSpline": {
          "description": "Cached spline to traverse"
        },
        "mSpeed": {
          "description": "How long it should take for trail to complete the spline movement in seconds",
          "type": "number"
        }
      },
      "required": [
        "mCurrentPipeline",
        "mPipesToTraverse",
        "mSpeed",
        "mSpline"
      ]
    },
    "AFGBuildablePipeline": {
      "type": "object",
      "properties": {
        "mRadius": {
          "description": "Inner Radius of this pipe. Used for flow calculations. [cm]",
          "type": "number"
        },
        "mFlowLimit": {
          "description": "Maximum flow through this pipe in cubic meters. [m^3/s]",
          "type": "number"
        },
        "mFlowIndicatorClass": {
          "description": "Type of indicator to spawn on this pipe.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFlowIndicatorMinimumPipeLength": {
          "description": "Smaller pipes than this will not get a flow indicator. [cm]",
          "type": "number"
        },
        "mSoundSplineComponent": {
          "$ref": "#/definitions/UFGSoundSplineComponent"
        },
        "mSplineAudioEvent": {
          "description": "The ak event to post for the sound spline"
        },
        "mPipeConnections": {
          "description": "Cached array of pipe connections.",
          "type": "array",
          "items": {}
        },
        "mFluidBox": {
          "$ref": "#/definitions/FFluidBox",
          "description": "Simulation data."
        },
        "mIndicatorData": {
          "$ref": "#/definitions/FQuantizedPipelineIndicatorData",
          "description": "Quantized data used by the indicators."
        },
        "mMaxIndicatorTurnAngle": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mCachedFluidDescriptor": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mIgnoreActorsForIndicator": {
          "description": "Array of objects to ignore when performing the collision check in the indicator placement. This is needed during merge / split creation of new pipelines",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mFluidNames": {
          "description": "struct with both wwise safe names and their item names",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FStringPair"
          }
        },
        "mCurrentFluid": {
          "description": "current fluid that is in the pipe",
          "type": "string"
        },
        "mQuantiziedContent": {
          "description": "how filled is the pipe",
          "type": "number"
        },
        "mQuantiziedFlow": {
          "description": "flow rate in the pipe",
          "type": "number"
        },
        "mRattleLimit": {
          "description": "at what flow should we play rattle",
          "type": "number"
        },
        "mIsRattling": {
          "description": "are we playing rattling sound?",
          "type": "boolean"
        },
        "mStartRattleSoundEvent": {
          "description": "Start rattle sound"
        },
        "mStopRattleSoundEvent": {
          "description": "Stop rattle sound"
        },
        "mMesh": {
          "description": "Mesh to use for his conveyor.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this conveyor.",
          "type": "number"
        },
        "mConnection0": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mConnection1": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mSplineData": {
          "description": "Compact representation of mSplineComponent, used for replication and save game",
          "type": "array",
          "items": {}
        },
        "mSplineComponent": {
          "description": "The spline component for this splined factory."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedFluidDescriptor",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mCurrentFluid",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mFlowIndicatorClass",
        "mFlowIndicatorMinimumPipeLength",
        "mFlowLimit",
        "mFluidBox",
        "mFluidNames",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mIgnoreActorsForIndicator",
        "mIndicatorData",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsRattling",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxIndicatorTurnAngle",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPipeConnections",
        "mPrimaryColor",
        "mQuantiziedContent",
        "mQuantiziedFlow",
        "mRadius",
        "mRattleLimit",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSoundSplineComponent",
        "mSplineAudioEvent",
        "mSplineComponent",
        "mSplineData",
        "mStartRattleSoundEvent",
        "mStopRattleSoundEvent"
      ]
    },
    "EGuideLineType": {
      "enum": [
        0,
        1
      ],
      "type": "number"
    },
    "AFGC4Explosive": {
      "type": "object",
      "properties": {
        "mBaseDamage": {
          "description": "Base damage used for the radial apply damage",
          "type": "number"
        },
        "mDamageRadius": {
          "description": "Damage radius used for the radial apply damage",
          "type": "number"
        },
        "mDamageType": {
          "description": "Damage type used for the radial apply damage",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mIsDetonated": {
          "description": "Tells client to blow this shit up",
          "type": "boolean"
        }
      },
      "required": [
        "mBaseDamage",
        "mDamageRadius",
        "mDamageType",
        "mIsDetonated"
      ]
    },
    "AFGHUD": {
      "type": "object",
      "properties": {
        "mGameUIClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRespawnUIClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPickupCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mVehicleCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mWeaponCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mWorkbenchCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCustomCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mGeneralCrosshair": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRespawnInputComponent": {
          "description": "Input component for blocking input during respawn"
        },
        "mRespawnUI": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mGameUI": {
          "$ref": "#/definitions/UFGGameUI"
        },
        "mPreviewBuildingWorld": {
          "description": "A world for previewing the current building"
        },
        "mPreviewStageClass": {
          "description": "Class that stages the preview building item",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPreviewActorClass": {
          "description": "The actor class we want to preview, we don't use buildable as we want to support vehicles too",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPawnHUD": {
          "description": "The latest created pawn HUD widget"
        },
        "mBaseUI": {
          "$ref": "#/definitions/UFGBaseUI",
          "description": "Reference to the UI widget"
        }
      },
      "required": [
        "mBaseUI",
        "mBuildCrosshair",
        "mCustomCrosshair",
        "mDefaultCrosshair",
        "mDismantleCrosshair",
        "mGameUI",
        "mGameUIClass",
        "mGeneralCrosshair",
        "mPawnHUD",
        "mPickupCrosshair",
        "mPreviewActorClass",
        "mPreviewBuildingWorld",
        "mPreviewStageClass",
        "mRespawnInputComponent",
        "mRespawnUI",
        "mRespawnUIClass",
        "mVehicleCrosshair",
        "mWeaponCrosshair",
        "mWorkbenchCrosshair"
      ]
    },
    "UFGGameUI": {
      "type": "object",
      "properties": {
        "mOnMouseButtonDown": {
          "description": "so if you already are listening for mouse input you might get this and your own event"
        },
        "mInteractWidgetStack": {
          "description": "A stack with widgets that are currently open",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGInteractWidget"
          }
        },
        "mCurrentAudioMessage": {
          "$ref": "#/definitions/UFGAudioMessage",
          "description": "Message that is being played now ( can be null )"
        },
        "mMinTimeBetweenAudioMessage": {
          "description": "How much time must pass between receiving audio messages at least?",
          "type": "number"
        },
        "mActivePopup": {
          "$ref": "#/definitions/UFGPopupWidget",
          "description": "Current active popup"
        }
      },
      "required": [
        "mActivePopup",
        "mCurrentAudioMessage",
        "mInteractWidgetStack",
        "mMinTimeBetweenAudioMessage",
        "mOnMouseButtonDown"
      ]
    },
    "UFGInteractWidget": {
      "type": "object",
      "properties": {
        "mUseKeyboard": {
          "description": "If we should take the keyboard input from the player. The player won't be able to move around.",
          "type": "boolean"
        },
        "mUseMouse": {
          "description": "If we should take the mouse input from the player. The player won't be able to look around.",
          "type": "boolean"
        },
        "mCaptureInput": {
          "description": "Decides if we should share input with game or capture it completely",
          "type": "boolean"
        },
        "mRestoreFocusWhenLost": {
          "description": "Decides if the widget should restore focus when it looses it. (e.g. when the user clicks outside of the widget)",
          "type": "boolean"
        },
        "mInputToPassThrough": {
          "description": "There need to be a clear hierarchy of how input is handled and what to pass and not pass and if the default is pass all or pass none.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDesiredHorizontalAlignment": {
          "description": "Our desired horizontal alignment"
        },
        "mDesiredVerticalAlignment": {
          "description": "Our desired vetical alignment"
        },
        "mDesiredAlignmentSize": {
          "description": "Our desired horizontal size"
        },
        "mInteractObject": {
          "$ref": "#/definitions/UObject",
          "description": "Object that we interacted with in order to show this widget ( can be nullPeter )"
        },
        "mDefaultFocusWidgetClass": {
          "description": "Class of the default widget we want to give focus to",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseGamepadCursor": {
          "description": "Should gamepad act as cursor when using this widget?",
          "type": "boolean"
        },
        "mCustomTickRate": {
          "description": "The rate for the timer that triggers the custom tick. If <= 0.f no timer will be started",
          "type": "number"
        },
        "mCallCustomTickOnConstruct": {
          "description": "True if the custom tick event be called on construct. If <= 0.f no event will be triggered",
          "type": "boolean"
        },
        "mDefaultFocusWidget": {
          "description": "Used to give focus to an object when nothing else has focus"
        },
        "mSupportsStacking": {
          "description": "Does this widget support stacking widgets on top?",
          "type": "boolean"
        }
      },
      "required": [
        "mCallCustomTickOnConstruct",
        "mCaptureInput",
        "mCustomTickRate",
        "mDefaultFocusWidget",
        "mDefaultFocusWidgetClass",
        "mDesiredAlignmentSize",
        "mDesiredHorizontalAlignment",
        "mDesiredVerticalAlignment",
        "mInputToPassThrough",
        "mInteractObject",
        "mRestoreFocusWhenLost",
        "mSupportsStacking",
        "mUseGamepadCursor",
        "mUseKeyboard",
        "mUseMouse"
      ]
    },
    "UFGAudioMessage": {
      "type": "object",
      "properties": {
        "mAkAudioComponent": {
          "description": "The Ak component"
        },
        "mAudioEvents": {
          "description": "The AK audio to play when \"showing\" this message",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FAudioSubtitlePair"
          }
        },
        "mCurrentDialogue": {
          "$ref": "#/definitions/FAudioSubtitlePair",
          "description": "Current dialogue that is displayed"
        },
        "mSubtitleTimeMultiplier": {
          "description": "Multiplier for time per character to display",
          "type": "number"
        },
        "mAudioMessageConcluded": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mAudioMessageInputComponent": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mTitle": {
          "description": "I think this may be the title",
          "type": "string"
        },
        "mPreviewText": {
          "description": "Preview text when a message is added",
          "type": "string"
        },
        "mIsPopup": {
          "description": "Should the message be displayed in a popup?",
          "type": "boolean"
        },
        "mSenderClass": {
          "description": "Who sent the message",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mType": {
          "$ref": "#/definitions/EMessageType",
          "description": "What type is it"
        },
        "mImages": {
          "description": "Images to display in the codex",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        }
      },
      "required": [
        "mAkAudioComponent",
        "mAudioEvents",
        "mAudioMessageConcluded",
        "mAudioMessageInputComponent",
        "mCurrentDialogue",
        "mImages",
        "mIsPopup",
        "mPreviewText",
        "mSenderClass",
        "mSubtitleTimeMultiplier",
        "mTitle",
        "mType"
      ]
    },
    "FAudioSubtitlePair": {
      "type": "object",
      "properties": {
        "AudioEvent": {
          "description": "Audio to play"
        },
        "Subtitle": {
          "description": "Subtitle to display",
          "type": "string"
        },
        "SenderClass": {
          "description": "Sender for this part of message",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "AudioEvent",
        "SenderClass",
        "Subtitle"
      ]
    },
    "EMessageType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "UFGPopupWidget": {
      "type": "object",
      "properties": {
        "mPopupConfirmClickedDelegate_DEPRECATED": {
          "description": "Delegate for when pressing the confirm button in popup"
        },
        "mPopupClosedDelegate": {
          "description": "Delegate for when pressing the confirm button in popup"
        },
        "mInstigator": {
          "$ref": "#/definitions/UObject"
        },
        "mUseKeyboard": {
          "description": "If we should take the keyboard input from the player. The player won't be able to move around.",
          "type": "boolean"
        },
        "mUseMouse": {
          "description": "If we should take the mouse input from the player. The player won't be able to look around.",
          "type": "boolean"
        },
        "mCaptureInput": {
          "description": "Decides if we should share input with game or capture it completely",
          "type": "boolean"
        },
        "mRestoreFocusWhenLost": {
          "description": "Decides if the widget should restore focus when it looses it. (e.g. when the user clicks outside of the widget)",
          "type": "boolean"
        },
        "mInputToPassThrough": {
          "description": "There need to be a clear hierarchy of how input is handled and what to pass and not pass and if the default is pass all or pass none.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDesiredHorizontalAlignment": {
          "description": "Our desired horizontal alignment"
        },
        "mDesiredVerticalAlignment": {
          "description": "Our desired vetical alignment"
        },
        "mDesiredAlignmentSize": {
          "description": "Our desired horizontal size"
        },
        "mInteractObject": {
          "$ref": "#/definitions/UObject",
          "description": "Object that we interacted with in order to show this widget ( can be nullPeter )"
        },
        "mDefaultFocusWidgetClass": {
          "description": "Class of the default widget we want to give focus to",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseGamepadCursor": {
          "description": "Should gamepad act as cursor when using this widget?",
          "type": "boolean"
        },
        "mCustomTickRate": {
          "description": "The rate for the timer that triggers the custom tick. If <= 0.f no timer will be started",
          "type": "number"
        },
        "mCallCustomTickOnConstruct": {
          "description": "True if the custom tick event be called on construct. If <= 0.f no event will be triggered",
          "type": "boolean"
        },
        "mDefaultFocusWidget": {
          "description": "Used to give focus to an object when nothing else has focus"
        },
        "mSupportsStacking": {
          "description": "Does this widget support stacking widgets on top?",
          "type": "boolean"
        }
      },
      "required": [
        "mCallCustomTickOnConstruct",
        "mCaptureInput",
        "mCustomTickRate",
        "mDefaultFocusWidget",
        "mDefaultFocusWidgetClass",
        "mDesiredAlignmentSize",
        "mDesiredHorizontalAlignment",
        "mDesiredVerticalAlignment",
        "mInputToPassThrough",
        "mInstigator",
        "mInteractObject",
        "mPopupClosedDelegate",
        "mPopupConfirmClickedDelegate_DEPRECATED",
        "mRestoreFocusWhenLost",
        "mSupportsStacking",
        "mUseGamepadCursor",
        "mUseKeyboard",
        "mUseMouse"
      ]
    },
    "UFGBaseUI": {
      "type": "object",
      "properties": {
        "mActivePopup": {
          "$ref": "#/definitions/UFGPopupWidget",
          "description": "Current active popup"
        }
      },
      "required": [
        "mActivePopup"
      ]
    },
    "AFGCentralStorageContainer": {
      "type": "object",
      "properties": {
        "mStackingHeight": {
          "description": "How far apart in Z do multiple storages stack.",
          "type": "number"
        },
        "mDefaultResources": {
          "description": "Default resources in a storage @todo Why this special case here, add the stuff in blueprint instead first time we're being built... I guess this is only used for the tutorial?",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mInventorySizeX": {
          "description": "The size of the inventory for this storage.",
          "type": "number"
        },
        "mInventorySizeY": {
          "description": "The size of the inventory for this storage.",
          "type": "number"
        },
        "mStorageInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory to store everything in. Don't use this directly, use mStorageInventoryHandler->GetActiveInventoryComponent()"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDefaultResources",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mInventorySizeX",
        "mInventorySizeY",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mStackingHeight",
        "mStorageInventory",
        "mTimeSinceStartStopProducing"
      ]
    },
    "FChatMessageStruct": {
      "type": "object",
      "properties": {
        "MessageString": {
          "description": "The message that was sent",
          "type": "string"
        },
        "ServerTimeStamp": {
          "description": "Synchronized time stamp of when the message was sent",
          "type": "number"
        },
        "Sender": {
          "$ref": "#/definitions/AFGPlayerState",
          "description": "The player who sent the message"
        },
        "MessageType": {
          "$ref": "#/definitions/EFGChatMessageType"
        }
      },
      "required": [
        "MessageString",
        "MessageType",
        "Sender",
        "ServerTimeStamp"
      ]
    },
    "EFGChatMessageType": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "Map<number,UFGCircuit>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGCircuit": {
      "type": "object",
      "properties": {
        "mCircuitID": {
          "description": "The id used to identify this circuit.",
          "type": "number"
        },
        "mComponents": {
          "description": "List of all the components (nodes) in this circuit.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuitConnectionComponent"
          }
        },
        "mNeedFullRebuild": {
          "description": "Do this circuit needs to be rebuilt, e.g. wires or components have been removed.",
          "type": "number"
        },
        "mHasChanged": {
          "description": "True if this circuit has changed.",
          "type": "number"
        },
        "mInteractingPlayers": {
          "description": "All players interacting with a building that's connected to this circuit",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        }
      },
      "required": [
        "mCircuitID",
        "mComponents",
        "mHasChanged",
        "mInteractingPlayers",
        "mNeedFullRebuild"
      ]
    },
    "AFGConveyorPoleHologram": {
      "type": "object",
      "properties": {
        "mSnapConnection": {
          "description": "The connection conveyors snap to, used when placing a pole automatically."
        },
        "mPoleMesh": {
          "$ref": "#/definitions/FPoleHeightMesh",
          "description": "The most fitting mesh for our aim height."
        },
        "mPoleMeshComponent": {
          "description": "The pole mesh."
        },
        "mPoleHeightComponent": {
          "description": "The scene component for adjusting the height of the pole."
        },
        "mPoleHeight": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mClearanceMeshComponent": {
          "description": "Mesh component used to display the clearance mesh"
        },
        "mClearanceMesh": {
          "description": "Mesh we want to use in the component",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mClearanceMaterial": {
          "description": "Material to use on the clearance component"
        },
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mClearanceMaterial",
        "mClearanceMesh",
        "mClearanceMeshComponent",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxPlacementFloorAngle",
        "mPlacementMaterial",
        "mPoleHeight",
        "mPoleHeightComponent",
        "mPoleMesh",
        "mPoleMeshComponent",
        "mRecipe",
        "mSnapConnection",
        "mSnappedBuilding",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "FPoleHeightMesh": {
      "type": "object",
      "properties": {
        "Mesh": {
          "description": "Mesh for the current pole height.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Height": {
          "description": "Pole height for the current mesh.",
          "type": "number"
        }
      },
      "required": [
        "Height",
        "Mesh"
      ]
    },
    "ESplineHologramBuildStep": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "AFGBuildableConveyorLift": {
      "description": "Base for conveyor lifts.",
      "type": "object",
      "properties": {
        "mMeshHeight": {
          "description": "What's the height of the meshes used.",
          "type": "number"
        },
        "mBottomMesh": {
          "description": "Mesh at the bottom of the lift.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMidMesh": {
          "description": "Mesh repeated for the mid section.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mTopMesh": {
          "description": "Mesh at the top of the lift.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBellowMesh": {
          "description": "Mesh placed on the input/output as a bellow between a wall or factory.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mJointMesh": {
          "description": "Mesh placed between two joined lift sections.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mShelfMesh": {
          "description": "Shelf placed under each item.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mTopTransform": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mIsReversed": {
          "type": "boolean"
        },
        "mItemMeshMap": {
          "$ref": "#/definitions/Map<string,any>",
          "description": "Meshes for items."
        },
        "PresistentConveyorPackagingDataObject": {
          "$ref": "#/definitions/UPresistentConveyorPackagingData",
          "description": "held here, but created by conveyors when replicated, as we don't want to create it unless it's used."
        },
        "mSpeed": {
          "description": "Speed of this conveyor.",
          "type": "number"
        },
        "mItems": {
          "$ref": "#/definitions/FConveyorBeltItems",
          "description": "All the locally simulated resource offsets on the conveyor belt."
        },
        "mConnection0": {
          "description": "First connection on conveyor belt, Connections are always in the same order, mConnection0 is the input, mConnection1 is the output."
        },
        "mConnection1": {
          "description": "Second connection on conveyor belt"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "PresistentConveyorPackagingDataObject",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBellowMesh",
        "mBottomMesh",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsReversed",
        "mIsUseable",
        "mItemMeshMap",
        "mItems",
        "mJointMesh",
        "mMaterialNameToInstanceManager",
        "mMeshHeight",
        "mMidMesh",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShelfMesh",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSpeed",
        "mTopMesh",
        "mTopTransform"
      ]
    },
    "UFGGameplayTask_Attack": {
      "type": "object",
      "properties": {
        "mAttackClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCachedPawn": {
          "$ref": "#/definitions/AFGEnemy",
          "description": "Cache the pawn that we have"
        }
      },
      "required": [
        "mAttackClass",
        "mCachedPawn"
      ]
    },
    "AFGEnemy": {
      "type": "object",
      "properties": {
        "mCurrentAttack": {
          "$ref": "#/definitions/UFGGameplayTask_Attack",
          "description": "The current attack that the pawn is issuing @todoai: Verify if clients need this replicated or if the task get a activate on clients too"
        },
        "mCurrentAggroTarget": {
          "$ref": "#/definitions/AActor"
        },
        "mNavigationGenerationRadius": {
          "description": "How big navmesh do we want to generate",
          "type": "number"
        },
        "mNavigationRemovalRadius": {
          "description": "Navigation outside this radius will be removed",
          "type": "number"
        },
        "mArachnophobiaModeMaterials": {
          "description": "Materials that may be used on arachnids",
          "type": "array",
          "items": {}
        },
        "mIsArachnid": {
          "description": "Is creature considered an arachnid",
          "type": "boolean"
        },
        "mIsEnabled": {
          "$ref": "#/definitions/EEnabled",
          "description": "True if optimized by the AI system"
        },
        "mItemToDrop": {
          "description": "Class of item to drop when dead",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSpline": {
          "$ref": "#/definitions/AFGSplinePath",
          "description": "Spline we are set to follow"
        },
        "mRotationDoneDelegate": {
          "description": "Called when we are done with rotation movement"
        },
        "mMoveSpeedData": {
          "description": "Array with information about different speeds that this creature can use",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FMoveSpeedPair"
          }
        },
        "mShouldOptimizeMeshWhenVisible": {
          "description": "Indicates if we should optimize this creatures mesh ( disable ticking ) when looking at it from a distance ( not good on large creatures )",
          "type": "boolean"
        },
        "mIsPersistent": {
          "description": "Should this creature be able to persist in the world",
          "type": "boolean"
        },
        "mActualAIControllerClass": {
          "description": "We specify our own controller class because we need to delay the spawning. Set this instead of \"AIControllerClass",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRotationTimerHandle": {
          "description": "Timer handle used when rotating the pawn with our custom rotate movement"
        },
        "mTargetRotation": {
          "description": "Target rotation for custom rotate movement"
        },
        "mCanSpawnDuringDay": {
          "description": "Can creatures spawn during day?",
          "type": "boolean"
        },
        "mCanSpawnDuringNight": {
          "description": "Can creatures spawn during night?",
          "type": "boolean"
        },
        "mMoveDuringRotation": {
          "description": "Used in combination with BTT_RotateToTarget if we need the creature to move while rotating",
          "type": "boolean"
        },
        "mRotationSpeedMultiplier": {
          "description": "Scale value for input vector when rotating and moving",
          "type": "number"
        },
        "mEyeLocationComponent": {
          "description": "Component used to determine eye location for a creature"
        },
        "mArachnophobia_Sprite": {
          "description": "Sprite for the arachnophobia mode"
        },
        "mArachnophobia_Material": {
          "description": "Material for the arachnophobia mode"
        },
        "mArachnophobia_Particle": {
          "description": "Particle for the arachnophobia mode"
        },
        "mDayTimePctCountAsNight": {
          "description": "How much of day time percentage ( 0.0 - 1.0 ) should count towards night time",
          "type": "number"
        },
        "mOwningSpawner": {
          "$ref": "#/definitions/AFGCreatureSpawner",
          "description": "Reference to the spawner that handles this creature"
        },
        "mFeetNames": {
          "description": "When receiving FootDown on index 2, then we will trace from mFeetNames[2] socket for ground",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in mFootstepEffects"
        },
        "mFootstepEffect": {
          "description": "Effects to play when a foot hits the ground",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "mFootstepAudioEvents": {
          "description": "Audio event to play (where index in array is the feet index passed from AnimNotify_FootDown)",
          "type": "array",
          "items": {}
        },
        "mMaxFootstepParticleSpawnDistance": {
          "description": "Maximum distance we want to play footstep particles at",
          "type": "number"
        },
        "mMaxFootstepDecalSpawnDistance": {
          "description": "Maximum distance we want to spawn footsteps decals at",
          "type": "number"
        },
        "mFootstepDecalSize": {
          "description": "Size of footstep decals",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mFootstepDecalLifetime": {
          "description": "Lifetime of footstep decals",
          "type": "number"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mFallDamageCurve": {
          "description": "How much damage to take falling with a given velocity"
        },
        "mFallDamageCurveOverride": {
          "description": "Overrides the default fall damage curve, utilized by Equipment"
        },
        "mFallDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxDeathStayTime": {
          "description": "The maximum time after death (in seconds) the pawn will stay in the world, so it will be removed even if it's in sight after this time",
          "type": "number"
        },
        "mDeathRemoveCheckTime": {
          "description": "How often will we check if the pawn is in sight of any player",
          "type": "number"
        },
        "mEnemyTargetDesirability": {
          "description": "Multiplier for targeting desirability",
          "type": "number"
        },
        "mTakeDamageSound": {
          "description": "Sound played when pawn takes damage"
        },
        "mDeathSound": {
          "description": "Sound played when pawn dies"
        },
        "mLandEvent": {
          "description": "Event posted when landing"
        },
        "mTakeDamageParticle": {
          "description": "Particle for when pawn takes damage"
        },
        "mMinVehiclePushVelocityForRagdoll": {
          "description": "Min push velocity required to start ragdoll",
          "type": "number"
        },
        "mTimeToGetUpFromRagdoll": {
          "description": "time in seconds until character gets up from ragdoll if alive",
          "type": "number"
        },
        "mMaxDistanceMovedToGetUp": {
          "description": "the furthest distance we can move during ragdoll before we are considered still enough to stand up from ragdoll",
          "type": "number"
        },
        "mIsRagdolled": {
          "description": "true if ragdolled",
          "type": "boolean"
        },
        "mRagdollMeshLoc": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshVelocity": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshLocBoneName": {
          "description": "Name of the bone we take mesh location from",
          "type": "string"
        },
        "mRagdollMeshPhysicsBoneName": {
          "description": "Name of the bone we take physics velocity from",
          "type": "string"
        },
        "mSyncBodyMaxDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mApplyDamageMomentum": {
          "description": "Should the auto momentum be applied when taking damage?",
          "type": "boolean"
        },
        "mIgnoredDamageTypes": {
          "description": "Damage types that this character is immune to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mWeakspotMultiplier": {
          "description": "How much more damage should be dealt when taking a weakspot hit",
          "type": "number"
        },
        "mWeakspotBoneNames": {
          "description": "Bone names that result in a weakspot hit",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mNormalDamageMultiplier": {
          "description": "Multiplier for this creature and normal damage taken",
          "type": "number"
        },
        "mIsPossessed": {
          "description": "Used to let client know when a pawn gets possessed/unpossessed",
          "type": "boolean"
        }
      },
      "required": [
        "mActualAIControllerClass",
        "mApplyDamageMomentum",
        "mArachnophobiaModeMaterials",
        "mArachnophobia_Material",
        "mArachnophobia_Particle",
        "mArachnophobia_Sprite",
        "mCanSpawnDuringDay",
        "mCanSpawnDuringNight",
        "mCurrentAggroTarget",
        "mCurrentAttack",
        "mDayTimePctCountAsNight",
        "mDeathRemoveCheckTime",
        "mDeathSound",
        "mDefaultFootstepEffect",
        "mEnemyTargetDesirability",
        "mEyeLocationComponent",
        "mFallDamageCurve",
        "mFallDamageCurveOverride",
        "mFallDamageDamageType",
        "mFeetNames",
        "mFootstepAudioEvents",
        "mFootstepDecalLifetime",
        "mFootstepDecalSize",
        "mFootstepEffect",
        "mHealthComponent",
        "mIgnoredDamageTypes",
        "mIsArachnid",
        "mIsEnabled",
        "mIsPersistent",
        "mIsPossessed",
        "mIsRagdolled",
        "mItemToDrop",
        "mLandEvent",
        "mMaxDeathStayTime",
        "mMaxDistanceMovedToGetUp",
        "mMaxFootstepDecalSpawnDistance",
        "mMaxFootstepParticleSpawnDistance",
        "mMinVehiclePushVelocityForRagdoll",
        "mMoveDuringRotation",
        "mMoveSpeedData",
        "mNavigationGenerationRadius",
        "mNavigationRemovalRadius",
        "mNormalDamageMultiplier",
        "mOwningSpawner",
        "mRagdollMeshLoc",
        "mRagdollMeshLocBoneName",
        "mRagdollMeshPhysicsBoneName",
        "mRagdollMeshVelocity",
        "mRotationDoneDelegate",
        "mRotationSpeedMultiplier",
        "mRotationTimerHandle",
        "mShouldOptimizeMeshWhenVisible",
        "mSpline",
        "mSyncBodyMaxDistance",
        "mTakeDamageParticle",
        "mTakeDamageSound",
        "mTargetRotation",
        "mTimeToGetUpFromRagdoll",
        "mWeakspotBoneNames",
        "mWeakspotMultiplier"
      ]
    },
    "EEnabled": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "AFGSplinePath": {
      "type": "object",
      "properties": {
        "mSpline": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "mSpline"
      ]
    },
    "FMoveSpeedPair": {
      "type": "object",
      "properties": {
        "MoveSpeedType": {
          "$ref": "#/definitions/EMoveSpeed"
        },
        "Speed": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "MoveSpeedType",
        "Speed"
      ]
    },
    "EMoveSpeed": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "AFGCreatureSpawner": {
      "type": "object",
      "properties": {
        "mDebugComponent": {
          "$ref": "#/definitions/UFGCreatureSpawnerDebugComponent",
          "description": "For showing a preview of what will happen in the editor"
        },
        "mEditorSprite": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mCapsuleComponent": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mCreatureClass": {
          "description": "The creature we should spawn",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mNumberOfCreatures": {
          "description": "The number of enemies to spawn, used offline"
        },
        "mSpawnRadius": {
          "description": "Within what radius do you want to spawn the enemies (the won't go outside of this radius)",
          "type": "number"
        },
        "mSpawnHalfHeight": {
          "description": "How much up/down our spawner tries to search for a placeable location",
          "type": "number"
        },
        "mIsActive": {
          "description": "Indicates if we have spawned our enemies",
          "type": "boolean"
        },
        "mSpawnData": {
          "description": "Structure for keeping all data saved about enemies spawned",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSpawnData"
          }
        },
        "mSplines": {
          "description": "Path splines that enemies in this spawner should set to follow",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGSplinePath"
          }
        },
        "mRandomSeed": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mRespawnTimeIndays": {
          "description": "How many days should pass before creatures start to respawn ( -1 means never )",
          "type": "number"
        }
      },
      "required": [
        "mCapsuleComponent",
        "mCreatureClass",
        "mDebugComponent",
        "mEditorSprite",
        "mIsActive",
        "mNumberOfCreatures",
        "mRandomSeed",
        "mRespawnTimeIndays",
        "mSpawnData",
        "mSpawnHalfHeight",
        "mSpawnRadius",
        "mSplines"
      ]
    },
    "UFGCreatureSpawnerDebugComponent": {
      "type": "object"
    },
    "FSpawnData": {
      "description": "Data we need to know/save about spawns in this spawner",
      "type": "object",
      "properties": {
        "SpawnLocation": {
          "$ref": "#/definitions/Vector",
          "description": "Location where we want to spawn"
        },
        "Creature": {
          "$ref": "#/definitions/AFGCreature",
          "description": "Reference to creature"
        },
        "WasKilled": {
          "description": "We save if the creature was killed so we know if we want to respawn the creature when in range of the spawner",
          "type": "boolean"
        },
        "KilledOnDayNr": {
          "description": "What day we were killed ( -1 if we haven't been killed yet )",
          "type": "number"
        },
        "CreatureClassOverride": {
          "description": "Overriden subclass of creature to spawn",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "Creature",
        "CreatureClassOverride",
        "KilledOnDayNr",
        "SpawnLocation",
        "WasKilled"
      ]
    },
    "AFGCreature": {
      "type": "object",
      "properties": {
        "mNavigationGenerationRadius": {
          "description": "How big navmesh do we want to generate",
          "type": "number"
        },
        "mNavigationRemovalRadius": {
          "description": "Navigation outside this radius will be removed",
          "type": "number"
        },
        "mArachnophobiaModeMaterials": {
          "description": "Materials that may be used on arachnids",
          "type": "array",
          "items": {}
        },
        "mIsArachnid": {
          "description": "Is creature considered an arachnid",
          "type": "boolean"
        },
        "mIsEnabled": {
          "$ref": "#/definitions/EEnabled",
          "description": "True if optimized by the AI system"
        },
        "mItemToDrop": {
          "description": "Class of item to drop when dead",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSpline": {
          "$ref": "#/definitions/AFGSplinePath",
          "description": "Spline we are set to follow"
        },
        "mRotationDoneDelegate": {
          "description": "Called when we are done with rotation movement"
        },
        "mMoveSpeedData": {
          "description": "Array with information about different speeds that this creature can use",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FMoveSpeedPair"
          }
        },
        "mShouldOptimizeMeshWhenVisible": {
          "description": "Indicates if we should optimize this creatures mesh ( disable ticking ) when looking at it from a distance ( not good on large creatures )",
          "type": "boolean"
        },
        "mIsPersistent": {
          "description": "Should this creature be able to persist in the world",
          "type": "boolean"
        },
        "mActualAIControllerClass": {
          "description": "We specify our own controller class because we need to delay the spawning. Set this instead of \"AIControllerClass",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mRotationTimerHandle": {
          "description": "Timer handle used when rotating the pawn with our custom rotate movement"
        },
        "mTargetRotation": {
          "description": "Target rotation for custom rotate movement"
        },
        "mCanSpawnDuringDay": {
          "description": "Can creatures spawn during day?",
          "type": "boolean"
        },
        "mCanSpawnDuringNight": {
          "description": "Can creatures spawn during night?",
          "type": "boolean"
        },
        "mMoveDuringRotation": {
          "description": "Used in combination with BTT_RotateToTarget if we need the creature to move while rotating",
          "type": "boolean"
        },
        "mRotationSpeedMultiplier": {
          "description": "Scale value for input vector when rotating and moving",
          "type": "number"
        },
        "mEyeLocationComponent": {
          "description": "Component used to determine eye location for a creature"
        },
        "mArachnophobia_Sprite": {
          "description": "Sprite for the arachnophobia mode"
        },
        "mArachnophobia_Material": {
          "description": "Material for the arachnophobia mode"
        },
        "mArachnophobia_Particle": {
          "description": "Particle for the arachnophobia mode"
        },
        "mDayTimePctCountAsNight": {
          "description": "How much of day time percentage ( 0.0 - 1.0 ) should count towards night time",
          "type": "number"
        },
        "mOwningSpawner": {
          "$ref": "#/definitions/AFGCreatureSpawner",
          "description": "Reference to the spawner that handles this creature"
        },
        "mFeetNames": {
          "description": "When receiving FootDown on index 2, then we will trace from mFeetNames[2] socket for ground",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in mFootstepEffects"
        },
        "mFootstepEffect": {
          "description": "Effects to play when a foot hits the ground",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "mFootstepAudioEvents": {
          "description": "Audio event to play (where index in array is the feet index passed from AnimNotify_FootDown)",
          "type": "array",
          "items": {}
        },
        "mMaxFootstepParticleSpawnDistance": {
          "description": "Maximum distance we want to play footstep particles at",
          "type": "number"
        },
        "mMaxFootstepDecalSpawnDistance": {
          "description": "Maximum distance we want to spawn footsteps decals at",
          "type": "number"
        },
        "mFootstepDecalSize": {
          "description": "Size of footstep decals",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mFootstepDecalLifetime": {
          "description": "Lifetime of footstep decals",
          "type": "number"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mFallDamageCurve": {
          "description": "How much damage to take falling with a given velocity"
        },
        "mFallDamageCurveOverride": {
          "description": "Overrides the default fall damage curve, utilized by Equipment"
        },
        "mFallDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxDeathStayTime": {
          "description": "The maximum time after death (in seconds) the pawn will stay in the world, so it will be removed even if it's in sight after this time",
          "type": "number"
        },
        "mDeathRemoveCheckTime": {
          "description": "How often will we check if the pawn is in sight of any player",
          "type": "number"
        },
        "mEnemyTargetDesirability": {
          "description": "Multiplier for targeting desirability",
          "type": "number"
        },
        "mTakeDamageSound": {
          "description": "Sound played when pawn takes damage"
        },
        "mDeathSound": {
          "description": "Sound played when pawn dies"
        },
        "mLandEvent": {
          "description": "Event posted when landing"
        },
        "mTakeDamageParticle": {
          "description": "Particle for when pawn takes damage"
        },
        "mMinVehiclePushVelocityForRagdoll": {
          "description": "Min push velocity required to start ragdoll",
          "type": "number"
        },
        "mTimeToGetUpFromRagdoll": {
          "description": "time in seconds until character gets up from ragdoll if alive",
          "type": "number"
        },
        "mMaxDistanceMovedToGetUp": {
          "description": "the furthest distance we can move during ragdoll before we are considered still enough to stand up from ragdoll",
          "type": "number"
        },
        "mIsRagdolled": {
          "description": "true if ragdolled",
          "type": "boolean"
        },
        "mRagdollMeshLoc": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshVelocity": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshLocBoneName": {
          "description": "Name of the bone we take mesh location from",
          "type": "string"
        },
        "mRagdollMeshPhysicsBoneName": {
          "description": "Name of the bone we take physics velocity from",
          "type": "string"
        },
        "mSyncBodyMaxDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mApplyDamageMomentum": {
          "description": "Should the auto momentum be applied when taking damage?",
          "type": "boolean"
        },
        "mIgnoredDamageTypes": {
          "description": "Damage types that this character is immune to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mWeakspotMultiplier": {
          "description": "How much more damage should be dealt when taking a weakspot hit",
          "type": "number"
        },
        "mWeakspotBoneNames": {
          "description": "Bone names that result in a weakspot hit",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mNormalDamageMultiplier": {
          "description": "Multiplier for this creature and normal damage taken",
          "type": "number"
        },
        "mIsPossessed": {
          "description": "Used to let client know when a pawn gets possessed/unpossessed",
          "type": "boolean"
        }
      },
      "required": [
        "mActualAIControllerClass",
        "mApplyDamageMomentum",
        "mArachnophobiaModeMaterials",
        "mArachnophobia_Material",
        "mArachnophobia_Particle",
        "mArachnophobia_Sprite",
        "mCanSpawnDuringDay",
        "mCanSpawnDuringNight",
        "mDayTimePctCountAsNight",
        "mDeathRemoveCheckTime",
        "mDeathSound",
        "mDefaultFootstepEffect",
        "mEnemyTargetDesirability",
        "mEyeLocationComponent",
        "mFallDamageCurve",
        "mFallDamageCurveOverride",
        "mFallDamageDamageType",
        "mFeetNames",
        "mFootstepAudioEvents",
        "mFootstepDecalLifetime",
        "mFootstepDecalSize",
        "mFootstepEffect",
        "mHealthComponent",
        "mIgnoredDamageTypes",
        "mIsArachnid",
        "mIsEnabled",
        "mIsPersistent",
        "mIsPossessed",
        "mIsRagdolled",
        "mItemToDrop",
        "mLandEvent",
        "mMaxDeathStayTime",
        "mMaxDistanceMovedToGetUp",
        "mMaxFootstepDecalSpawnDistance",
        "mMaxFootstepParticleSpawnDistance",
        "mMinVehiclePushVelocityForRagdoll",
        "mMoveDuringRotation",
        "mMoveSpeedData",
        "mNavigationGenerationRadius",
        "mNavigationRemovalRadius",
        "mNormalDamageMultiplier",
        "mOwningSpawner",
        "mRagdollMeshLoc",
        "mRagdollMeshLocBoneName",
        "mRagdollMeshPhysicsBoneName",
        "mRagdollMeshVelocity",
        "mRotationDoneDelegate",
        "mRotationSpeedMultiplier",
        "mRotationTimerHandle",
        "mShouldOptimizeMeshWhenVisible",
        "mSpline",
        "mSyncBodyMaxDistance",
        "mTakeDamageParticle",
        "mTakeDamageSound",
        "mTargetRotation",
        "mTimeToGetUpFromRagdoll",
        "mWeakspotBoneNames",
        "mWeakspotMultiplier"
      ]
    },
    "FDebrisMesh": {
      "type": "object",
      "properties": {
        "Mesh": {
          "description": "Mesh to spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Num": {
          "description": "How many to spawn, note that the upper limit is guaranteed while the lower limit is not."
        }
      },
      "required": [
        "Mesh",
        "Num"
      ]
    },
    "FDebrisActor": {
      "type": "object",
      "properties": {
        "ActorClass": {
          "description": "Mesh to spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Num": {
          "description": "How many to spawn, note that the upper limit is guaranteed while the lower limit is not."
        }
      },
      "required": [
        "ActorClass",
        "Num"
      ]
    },
    "FDebrisItemDrop": {
      "type": "object",
      "properties": {
        "NumItems": {
          "description": "How many items to spawn, note that the upper limit is guaranteed while the lower limit is not."
        },
        "ItemClass": {
          "description": "Item to create pickup for.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "ItemClass",
        "NumItems"
      ]
    },
    "FSimulatedMeshTransform": {
      "type": "object",
      "properties": {
        "StaticMesh": {
          "description": "A StaticMesh is a piece of geometry that consists of a static set of polygons.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UStaticMesh/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "MeshTransform": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "MeshTransform",
        "StaticMesh"
      ]
    },
    "FSimulatedActorTransform": {
      "type": "object",
      "properties": {
        "ActorClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ActorTransform": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "ActorClass",
        "ActorTransform"
      ]
    },
    "FSimulatedItemDropTransform": {
      "type": "object",
      "properties": {
        "ItemDropTransform": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "ItemDropTransform"
      ]
    },
    "EFGCrateIconType": {
      "type": "number",
      "enum": [
        0
      ]
    },
    "UFGDotComponent": {
      "type": "object",
      "properties": {
        "mDotClass": {
          "description": "The dot we should apply to things in the primitive component we are attached to",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mActorsToDamage": {
          "description": "The actors we want to damage",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AActor"
          }
        }
      },
      "required": [
        "mActorsToDamage",
        "mDotClass"
      ]
    },
    "FProjectileData": {
      "type": "object",
      "properties": {
        "ProjectileClass": {
          "description": "projectile class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ProjectileLifeSpan": {
          "description": "life time",
          "type": "number"
        },
        "ProjectileStickSpan": {
          "description": "How long the projectile will live after it has gotten stuck to something",
          "type": "number"
        },
        "ExplosionDamage": {
          "description": "damage at impact point",
          "type": "number"
        },
        "ExplosionRadius": {
          "description": "radius of damage",
          "type": "number"
        },
        "ImpactDamage": {
          "description": "Damage dealt to actor that get hit or impacted by this projectile",
          "type": "number"
        },
        "ShouldExplodeOnImpact": {
          "description": "If we impact something, should this projectile explode so that it deals radius damage?",
          "type": "boolean"
        },
        "CanTriggerExplodeBySameClass": {
          "description": "Indicates if we should explode if we are taking damage from same actor class as ourselves",
          "type": "boolean"
        },
        "ExplodeAtEndOfLife": {
          "description": "Should the projectile explode when it dies of lifespan?",
          "type": "boolean"
        },
        "DamageType": {
          "description": "type of damage used for impact damage",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "DamageTypeExplode": {
          "description": "type of damage used for detonation",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "CanTriggerExplodeBySameClass",
        "DamageType",
        "DamageTypeExplode",
        "ExplodeAtEndOfLife",
        "ExplosionDamage",
        "ExplosionRadius",
        "ImpactDamage",
        "ProjectileClass",
        "ProjectileLifeSpan",
        "ProjectileStickSpan",
        "ShouldExplodeOnImpact"
      ]
    },
    "AFGPlayerController": {
      "type": "object",
      "properties": {
        "OnShortcutsLayoutChanged": {
          "description": "Called when the shortcuts layout have changed, e.g. shortcut added."
        },
        "OnShortcutChanged": {
          "description": "Called when a shortcut has changed, e.g. activated or inactivated"
        },
        "OnToggleInventory": {
          "description": "Called when the player opens or closes the inventory"
        },
        "OnToggleInteractionUI": {
          "description": "Called when the player opens or closes the inventory"
        },
        "MapAreaEntered": {
          "description": "Called when the pawn this controller is controlling enters a map area"
        },
        "PawnChanged": {
          "description": "Called when the pawn this controller is controlling changes to other than nullPeter"
        },
        "mDisabledInputGateChanged": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mCanAffectAudioVolumes": {
          "description": "Indicates if this playercontroller should trigger sound volumes",
          "type": "boolean"
        },
        "mConsoleCommandManager": {
          "$ref": "#/definitions/UFGConsoleCommandManager",
          "description": "Object that manages non-cheat commands. Instantiated in shipping builds."
        },
        "mRemoteCallObjects": {
          "description": "The array of all remote call objects this player controller has",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGRemoteCallObject"
          }
        },
        "mInputComponentChords": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mAttentionPingActorClass": {
          "description": "The class of the attention ping actor we want to use",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMapAreaCheckInterval": {
          "description": "How often should we check which map area the pawn is in?",
          "type": "number"
        },
        "mCurrentMapArea": {
          "description": "In what map area is our pawn right now ?",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMovementWindComp": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mIsRespawning": {
          "description": "If we're currently in the state of respawning",
          "type": "boolean"
        },
        "mCachedMapAreaTexture": {
          "$ref": "#/definitions/UFGMapAreaTexture",
          "description": "Cached info about the map areas"
        },
        "mRespawnFromDeath": {
          "description": "Did we died",
          "type": "boolean"
        },
        "mRespawnFromJoin": {
          "description": "Did we died",
          "type": "boolean"
        },
        "mMinPhotoModeFOV": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mMaxPhotoModeFOV": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mPhotomodeInputComponent": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mProximitySubsystem": {
          "$ref": "#/definitions/AFGProximitySubsystem",
          "description": "Subsystem that keeps track of effects in proximity to the player"
        },
        "OnInputChanged": {
          "description": "Called when we rebind any key"
        },
        "mAdminInterface": {
          "$ref": "#/definitions/AFGAdminInterface",
          "description": "Admin interface if we have one available"
        },
        "mReplicatedCheatManager": {
          "$ref": "#/definitions/UFGCheatManager",
          "description": "If we are allowed to cheat, then we replicate the cheat manager"
        },
        "mDisableInputComponent": {
          "description": "The input component used when we want to disable our input"
        },
        "mEnableInputComponent": {
          "description": "The input component used when we want to enable our input"
        },
        "mAllowedInputWhenDead": {
          "description": "Input that's allowed when you are dead",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "MapAreaEntered",
        "OnInputChanged",
        "OnShortcutChanged",
        "OnShortcutsLayoutChanged",
        "OnToggleInteractionUI",
        "OnToggleInventory",
        "PawnChanged",
        "mAdminInterface",
        "mAllowedInputWhenDead",
        "mAttentionPingActorClass",
        "mCachedMapAreaTexture",
        "mCanAffectAudioVolumes",
        "mConsoleCommandManager",
        "mCurrentMapArea",
        "mDisableInputComponent",
        "mDisabledInputGateChanged",
        "mEnableInputComponent",
        "mInputComponentChords",
        "mIsRespawning",
        "mMapAreaCheckInterval",
        "mMaxPhotoModeFOV",
        "mMinPhotoModeFOV",
        "mMovementWindComp",
        "mPhotomodeInputComponent",
        "mProximitySubsystem",
        "mRemoteCallObjects",
        "mReplicatedCheatManager",
        "mRespawnFromDeath",
        "mRespawnFromJoin"
      ]
    },
    "UFGConsoleCommandManager": {
      "type": "object"
    },
    "UFGRemoteCallObject": {
      "type": "object"
    },
    "UFGMapAreaTexture": {
      "type": "object",
      "properties": {
        "mAreaTexture": {
          "description": "This is the texture that the level designers made to define areas on the map",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mFogOfWarTexture": {
          "description": "The current fog of war is generated to this texture",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAreaData": {
          "description": "This is where we store the raw data we generated from the texture",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mColorPalette": {
          "description": "This are all the unique colors found in the texture",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Color"
          }
        },
        "mColorToArea": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FColorMapAreaPair"
          }
        },
        "mCaptureActor": {
          "$ref": "#/definitions/AFGMinimapCaptureActor",
          "description": "A cached camera in the Skye"
        },
        "mDataWidth": {
          "description": "The width of the data and the texture",
          "type": "number"
        },
        "mCachedGameState": {
          "$ref": "#/definitions/AFGGameState"
        }
      },
      "required": [
        "mAreaData",
        "mAreaTexture",
        "mCachedGameState",
        "mCaptureActor",
        "mColorPalette",
        "mColorToArea",
        "mDataWidth",
        "mFogOfWarTexture"
      ]
    },
    "FColorMapAreaPair": {
      "type": "object",
      "properties": {
        "PaletteColor": {
          "$ref": "#/definitions/Color"
        },
        "MapArea": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "MinX": {
          "description": "A top left pixel that together with MaxX/MaxY encompasses the entire area",
          "type": "number"
        },
        "MinY": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "MaxX": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "MaxY": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        }
      },
      "required": [
        "MapArea",
        "MaxX",
        "MaxY",
        "MinX",
        "MinY",
        "PaletteColor"
      ]
    },
    "AFGMinimapCaptureActor": {
      "type": "object",
      "properties": {
        "mIncludeFoliage": {
          "description": "Do we want the foliage to be considered for the height data generation?",
          "type": "boolean"
        },
        "mIgnoreUserData": {
          "description": "Should we ignore the userdata set on static meshes, all static meshes will be considered for the height data",
          "type": "boolean"
        },
        "mLayersForTerrain": {
          "description": "Divides the terrain height map into the given amount of layers",
          "type": "number"
        },
        "mShowDepthOnWaterMap": {
          "description": "Show depth on the water map",
          "type": "boolean"
        },
        "mWaterMaxDepth": {
          "description": "The max water depth considered, everything deeper than this will be clamped to this value",
          "type": "number"
        },
        "mWaterDepthBufferMultiplier": {
          "description": "Decides how big the buffer between \"no water\"-areas and the deepest water-area is",
          "type": "number"
        },
        "mHeightDataResolution": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mMapAreaTexture": {
          "$ref": "#/definitions/UFGMapAreaTexture",
          "description": "The areas defined as by this texture"
        }
      },
      "required": [
        "mHeightDataResolution",
        "mIgnoreUserData",
        "mIncludeFoliage",
        "mLayersForTerrain",
        "mMapAreaTexture",
        "mShowDepthOnWaterMap",
        "mWaterDepthBufferMultiplier",
        "mWaterMaxDepth"
      ]
    },
    "AFGGameState": {
      "type": "object",
      "properties": {
        "MapAreaVisistedDelegate": {
          "description": "Called on all players when any player enters a new map area."
        },
        "mTurboModeMultiplier": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerCircuitFuseTriggeredMessage": {
          "description": "Message sent when a power fuse is triggered occurs.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAvailableRecipes": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mTimeSubsystem": {
          "$ref": "#/definitions/AFGTimeOfDaySubsystem",
          "description": "Spawned subsystems"
        },
        "mStorySubsystem": {
          "$ref": "#/definitions/AFGStorySubsystem"
        },
        "mRailroadSubsystem": {
          "$ref": "#/definitions/AFGRailroadSubsystem"
        },
        "mCircuitSubsystem": {
          "$ref": "#/definitions/AFGCircuitSubsystem"
        },
        "mRecipeManager": {
          "$ref": "#/definitions/AFGRecipeManager"
        },
        "mSchematicManager": {
          "$ref": "#/definitions/AFGSchematicManager"
        },
        "mGamePhaseManager": {
          "$ref": "#/definitions/AFGGamePhaseManager"
        },
        "mResearchManager": {
          "$ref": "#/definitions/AFGResearchManager"
        },
        "mTutorialIntroManager": {
          "$ref": "#/definitions/AFGTutorialIntroManager"
        },
        "mActorRepresentationManager": {
          "$ref": "#/definitions/AFGActorRepresentationManager"
        },
        "mMapManager": {
          "$ref": "#/definitions/AFGMapManager"
        },
        "mRadioactivitySubsystem": {
          "$ref": "#/definitions/AFGRadioactivitySubsystem"
        },
        "mChatManager": {
          "$ref": "#/definitions/AFGChatManager"
        },
        "mCentralStorageSubsystem": {
          "$ref": "#/definitions/AFGCentralStorageSubsystem"
        },
        "mPipeSubsystem": {
          "$ref": "#/definitions/AFGPipeSubsystem"
        },
        "mUnlockSubsystem": {
          "$ref": "#/definitions/AFGUnlockSubsystem"
        },
        "mResourceSinkSubsystem": {
          "$ref": "#/definitions/AFGResourceSinkSubsystem"
        },
        "mVisitedMapAreas": {
          "description": "This array keeps track of what map areas have been visited this game",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mPickedUpItems": {
          "description": "All items we have picked up that also are relevant to know if we picked up",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mPlayDurationWhenLoaded": {
          "description": "The total play time when loaded this save",
          "type": "number"
        },
        "mReplicatedSessionName": {
          "type": "string"
        },
        "mBuildingColorSlots": {
          "$ref": "#/definitions/FFGBuildingColorSlotStruct"
        },
        "mPlannedRestartTime": {
          "description": "Next time the server is planned to restart",
          "type": "number"
        },
        "mOnRestartTimeNotification": {
          "description": "Called at regular times when the restart time reaches specific thresholds"
        },
        "mHubPartClass": {
          "description": "Class used to construct the hub, this is used to guarantee players always have one if they don't have a hub",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mForceAddHubPartOnSpawn": {
          "description": "Track if a hub part is needed for adding to player inventory when they respawn",
          "type": "boolean"
        },
        "mCheatNoCost": {
          "description": "Cheat bool for having no cost for stuff",
          "type": "boolean"
        },
        "mCheatNoPower": {
          "description": "Cheat bool for not requiring power",
          "type": "boolean"
        },
        "mIsTradingPostBuilt": {
          "description": "There can only be one trading post in the game, so we keep track it here so that we also can replicate it to client",
          "type": "boolean"
        },
        "mHasInitalTradingPostLandAnimPlayed": {
          "description": "The first time you build a trading post we want the landing animation to play",
          "type": "boolean"
        },
        "mIsSpaceElevatorBuilt": {
          "description": "There can only be one tow truck in the game, so we keep track it here so that we also can replicate it to client",
          "type": "boolean"
        }
      },
      "required": [
        "MapAreaVisistedDelegate",
        "mActorRepresentationManager",
        "mAvailableRecipes",
        "mBuildingColorSlots",
        "mCentralStorageSubsystem",
        "mChatManager",
        "mCheatNoCost",
        "mCheatNoPower",
        "mCircuitSubsystem",
        "mForceAddHubPartOnSpawn",
        "mGamePhaseManager",
        "mHasInitalTradingPostLandAnimPlayed",
        "mHubPartClass",
        "mIsSpaceElevatorBuilt",
        "mIsTradingPostBuilt",
        "mMapManager",
        "mOnRestartTimeNotification",
        "mPickedUpItems",
        "mPipeSubsystem",
        "mPlannedRestartTime",
        "mPlayDurationWhenLoaded",
        "mPowerCircuitFuseTriggeredMessage",
        "mRadioactivitySubsystem",
        "mRailroadSubsystem",
        "mRecipeManager",
        "mReplicatedSessionName",
        "mResearchManager",
        "mResourceSinkSubsystem",
        "mSchematicManager",
        "mStorySubsystem",
        "mTimeSubsystem",
        "mTurboModeMultiplier",
        "mTutorialIntroManager",
        "mUnlockSubsystem",
        "mVisitedMapAreas"
      ]
    },
    "AFGTimeOfDaySubsystem": {
      "type": "object",
      "properties": {
        "mSyncronizeTimeOfDayInterval": {
          "description": "How often (in seconds) we should synchronize the time of day with the server",
          "type": "number"
        },
        "mDayLengthMinutes": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNightLengthMinutes": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mDayStartTime": {
          "description": "In hours, when does the day start (if you want 06.45, enter 06.75)",
          "type": "number"
        },
        "mNightStartTime": {
          "description": "In hours, when does the night start (if you want 19.10, enter 19.1666667)",
          "type": "number"
        },
        "mSpeedMultiplier": {
          "description": "Multiplier for speeding up the day/night cycle",
          "type": "number"
        },
        "mDaySeconds": {
          "description": "How many seconds that has passed into our current day",
          "type": "number"
        },
        "mReplicatedDaySeconds": {
          "description": "Written to by server, sends over the time that the server currently have",
          "type": "number"
        },
        "mNumberOfPassedDays": {
          "description": "The current day that has passed",
          "type": "number"
        },
        "mUpdateTime": {
          "description": "Will only update the time if we set this to true",
          "type": "boolean"
        },
        "mOnNewDayDelegate": {
          "description": "Server and Client | Called when a new day starts"
        }
      },
      "required": [
        "mDayLengthMinutes",
        "mDaySeconds",
        "mDayStartTime",
        "mNightLengthMinutes",
        "mNightStartTime",
        "mNumberOfPassedDays",
        "mOnNewDayDelegate",
        "mReplicatedDaySeconds",
        "mSpeedMultiplier",
        "mSyncronizeTimeOfDayInterval",
        "mUpdateTime"
      ]
    },
    "AFGStorySubsystem": {
      "type": "object",
      "properties": {
        "mActivePlayers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mSchematicMessageData": {
          "description": "array of schematic/message pairs",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSchematicMessagePair"
          }
        },
        "mItemFoundData": {
          "description": "array of item descriptor class/message and if they have been found already",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemFoundData"
          }
        },
        "mResearchTreeMessageData": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FResearchTreeMessageData"
          }
        },
        "mResearchTimerCompleteMessage": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "mActivePlayers",
        "mItemFoundData",
        "mResearchTimerCompleteMessage",
        "mResearchTreeMessageData",
        "mSchematicMessageData"
      ]
    },
    "FSchematicMessagePair": {
      "type": "object",
      "properties": {
        "Messages": {
          "description": "Message to display",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "SchematicUnlocked": {
          "description": "Associated schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "Messages",
        "SchematicUnlocked"
      ]
    },
    "FItemFoundData": {
      "type": "object",
      "properties": {
        "WasFound": {
          "description": "Already found or not?",
          "type": "boolean"
        },
        "Messages": {
          "description": "Message that should be added when Class is found for the first time",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "SchematicClass": {
          "description": "Schematic to unlock ( if any )",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "ItemClass": {
          "description": "Item descriptor we are looking for",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "ItemClass",
        "Messages",
        "SchematicClass",
        "WasFound"
      ]
    },
    "FResearchTreeMessageData": {
      "type": "object",
      "properties": {
        "Messages": {
          "description": "Message to display",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "ResearchTree": {
          "description": "Associated research tree",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "Messages",
        "ResearchTree"
      ]
    },
    "AFGRailroadSubsystem": {
      "type": "object",
      "properties": {
        "mConnectDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mSwitchControlClass": {
          "description": "Default switch control to place when building switches.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mVehicleSoundComponentClass": {
          "description": "This is sound component used to play sounds on trains.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStationNames": {
          "description": "A random name is picked from here when placing a stop.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mTrackGraphs": {
          "$ref": "#/definitions/Map<number,FTrackGraph>",
          "description": "All the train tracks in the world, separated by connectivity."
        },
        "mTrainStationIdentifiers": {
          "description": "All station identifiers in the world.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGTrainStationIdentifier"
          }
        },
        "mTrains": {
          "description": "All the trains in the world.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGTrain"
          }
        }
      },
      "required": [
        "mConnectDistance",
        "mStationNames",
        "mSwitchControlClass",
        "mTrackGraphs",
        "mTrainStationIdentifiers",
        "mTrains",
        "mVehicleSoundComponentClass"
      ]
    },
    "Map<number,FTrackGraph>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "AFGCircuitSubsystem": {
      "type": "object",
      "properties": {
        "mCircuits": {
          "$ref": "#/definitions/Map<number,UFGCircuit>",
          "description": "Map with all circuits and the circuit ID as the key."
        },
        "mReplicatedCircuits": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuit"
          }
        }
      },
      "required": [
        "mCircuits",
        "mReplicatedCircuits"
      ]
    },
    "AFGRecipeManager": {
      "type": "object",
      "properties": {
        "mAvailableRecipes": {
          "description": "All recipes that are available to the producers, i.e. build gun, workbench, manufacturers etc.",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        }
      },
      "required": [
        "mAvailableRecipes"
      ]
    },
    "AFGResearchManager": {
      "type": "object",
      "properties": {
        "ResearchStartedDelegate": {
          "description": "Called when a research recipe is started"
        },
        "ResearchCompletedDelegate": {
          "description": "Called when ongoing research has completed"
        },
        "ResearchStateChangedDelegate": {
          "description": "Called when research state has changed"
        },
        "ResearchResultsClaimedDelegate": {
          "description": "Called when research results are collected from completed research"
        },
        "ResearchTreeUnlockedDelegate": {
          "description": "Called when research trees are unlocked"
        },
        "mCanConductMultipleResearch": {
          "description": "Whether multiple concurrent research can be conducted, or only one at a time.",
          "type": "boolean"
        },
        "mAllResearchTrees": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mUnlockedResearchTrees": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mCompletedResearch": {
          "description": "What research has been conducted and is complete.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FResearchData"
          }
        },
        "mOngoingResearch": {
          "description": "What research that is currently being analyzed. i.e. that has started their timer and is ticking down.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FResearchTime"
          }
        },
        "mSavedOngoingResearch": {
          "description": "Used save the current ongoing research, saved research is restarted on load",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FResearchTime"
          }
        }
      },
      "required": [
        "ResearchCompletedDelegate",
        "ResearchResultsClaimedDelegate",
        "ResearchStartedDelegate",
        "ResearchStateChangedDelegate",
        "ResearchTreeUnlockedDelegate",
        "mAllResearchTrees",
        "mCanConductMultipleResearch",
        "mCompletedResearch",
        "mOngoingResearch",
        "mSavedOngoingResearch",
        "mUnlockedResearchTrees"
      ]
    },
    "FResearchData": {
      "type": "object",
      "properties": {
        "Schematic": {
          "description": "The schematic that holds the research data",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "InitiatingResearchTree": {
          "description": "The research tree that initiated the research",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "PendingRewards": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        }
      },
      "required": [
        "InitiatingResearchTree",
        "PendingRewards",
        "Schematic"
      ]
    },
    "FResearchTime": {
      "type": "object",
      "properties": {
        "ResearchData": {
          "$ref": "#/definitions/FResearchData",
          "description": "The research entry that contains data about the research conducted"
        },
        "ResearchCompleteTimestamp": {
          "description": "The time stamp for when the research is completed. When saved it represents how much time is left for research",
          "type": "number"
        }
      },
      "required": [
        "ResearchCompleteTimestamp",
        "ResearchData"
      ]
    },
    "AFGTutorialIntroManager": {
      "type": "object",
      "properties": {
        "mOnIntroSequenceStateUpdated": {
          "description": "Called when mHasCompletedIntroSequence updates"
        },
        "mTradingPostBuilt": {
          "description": "Has a trading post been built",
          "type": "boolean"
        },
        "mPendingTutorial": {
          "$ref": "#/definitions/EIntroTutorialSteps",
          "description": "Array of pending tutorial IDs that should be shown when possible ( no other widgets on screen etc )"
        },
        "mHasCompletedIntroTutorial": {
          "description": "Indicates if the player has completed the introduction tutorial",
          "type": "boolean"
        },
        "mHasCompletedIntroSequence": {
          "description": "Indicates that the introduction sequence is done (right now, drop pod sequence)",
          "type": "boolean"
        },
        "mTradingPostDescriptor": {
          "description": "The class of the trading post",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mTradingPost": {
          "$ref": "#/definitions/AFGBuildableTradingPost",
          "description": "Cached reference of trading post"
        },
        "mIntroTutorialData": {
          "description": "Data used for the intro tutorial",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTutorialHintData"
          }
        },
        "mIronOreDescriptor": {
          "description": "Class of Iron Resource Descriptor",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidPickUpIronOre": {
          "type": "boolean"
        },
        "mDropPodItemClass": {
          "description": "An item you receive when dismantling the drop pod so we can identify it",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidDismantleDropPod": {
          "description": "Checks if we have dismantled the drop pod",
          "type": "boolean"
        },
        "mStunSpearItemClass": {
          "description": "class to identify the stun spear",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidEquipStunSpear": {
          "description": "Checks if we equipped the stun spear",
          "type": "boolean"
        },
        "mStep1UpgradeSchematic": {
          "description": "Reference to the class step 1 tutorial schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidStep1Upgrade": {
          "description": "Bool for the step 1 schematic",
          "type": "boolean"
        },
        "mStep1_5UpgradeSchematic": {
          "description": "Reference to the class step 1.5 tutorial schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidStep1_5Upgrade": {
          "description": "Bool for the step 1.5 schematic",
          "type": "boolean"
        },
        "mStep2UpgradeSchematic": {
          "description": "Reference to the class step 2 tutorial schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidStep2Upgrade": {
          "description": "Bool for the step 2 schematic",
          "type": "boolean"
        },
        "mStep3UpgradeSchematic": {
          "description": "Reference to the class step 3 tutorial schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidStep3Upgrade": {
          "description": "Bool for the step 3 schematic",
          "type": "boolean"
        },
        "mStep4UpgradeSchematic": {
          "description": "Reference to the class step 4 tutorial schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidStep4Upgrade": {
          "description": "Bool for the step 4 schematic",
          "type": "boolean"
        },
        "mStep5UpgradeSchematic": {
          "description": "Reference to the class step 5 tutorial schematic",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDidStep5Upgrade": {
          "description": "Bool for the step5 schematic",
          "type": "boolean"
        },
        "mStartingPodClass": {
          "description": "Class of drop pod to spawn",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mStartingPod": {
          "$ref": "#/definitions/AFGStartingPod",
          "description": "Reference to starting pod ( server only )"
        },
        "mTradingPostLevel": {
          "description": "The upgrade level we have on our trading post",
          "type": "number"
        },
        "mWaitTimeAfterCompletingMinorStep": {
          "description": "Time to wait after completing a minor tutorial step and displaying the next",
          "type": "number"
        },
        "mWaitTimeAfterCompletingHubStep": {
          "description": "Time to wait after completing a trading post step and displaying the next",
          "type": "number"
        },
        "mHoldTimeToSkipIntro": {
          "description": "Time required to",
          "type": "number"
        },
        "mHoldToSkipTimerHandle": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mRecipesToGivePlayersSkippingTutorial": {
          "description": "List of recipes that player should get the items of if the player chooses to skip the tutorial",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FRecipeAmountPair"
          }
        }
      },
      "required": [
        "mDidDismantleDropPod",
        "mDidEquipStunSpear",
        "mDidPickUpIronOre",
        "mDidStep1Upgrade",
        "mDidStep1_5Upgrade",
        "mDidStep2Upgrade",
        "mDidStep3Upgrade",
        "mDidStep4Upgrade",
        "mDidStep5Upgrade",
        "mDropPodItemClass",
        "mHasCompletedIntroSequence",
        "mHasCompletedIntroTutorial",
        "mHoldTimeToSkipIntro",
        "mHoldToSkipTimerHandle",
        "mIntroTutorialData",
        "mIronOreDescriptor",
        "mOnIntroSequenceStateUpdated",
        "mPendingTutorial",
        "mRecipesToGivePlayersSkippingTutorial",
        "mStartingPod",
        "mStartingPodClass",
        "mStep1UpgradeSchematic",
        "mStep1_5UpgradeSchematic",
        "mStep2UpgradeSchematic",
        "mStep3UpgradeSchematic",
        "mStep4UpgradeSchematic",
        "mStep5UpgradeSchematic",
        "mStunSpearItemClass",
        "mTradingPost",
        "mTradingPostBuilt",
        "mTradingPostDescriptor",
        "mTradingPostLevel",
        "mWaitTimeAfterCompletingHubStep",
        "mWaitTimeAfterCompletingMinorStep"
      ]
    },
    "EIntroTutorialSteps": {
      "description": "Steps in the intro tutorial",
      "enum": [
        0,
        1,
        10,
        11,
        12,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9
      ],
      "type": "number"
    },
    "FTutorialHintData": {
      "type": "object",
      "properties": {
        "ID": {
          "$ref": "#/definitions/EIntroTutorialSteps"
        },
        "Title": {
          "description": "A localizable string.",
          "type": "string"
        },
        "HintTexts": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "Message": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "HintTexts",
        "ID",
        "Message",
        "Title"
      ]
    },
    "AFGStartingPod": {
      "type": "object",
      "properties": {
        "mCachedPlayer": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "Player associated with this pod"
        },
        "mDismantleStacks": {
          "description": "Array containing how much to get back when dismantling this bad boy",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        },
        "mDropPodMesh": {
          "description": "Main mesh"
        }
      },
      "required": [
        "mCachedPlayer",
        "mDismantleStacks",
        "mDropPodMesh"
      ]
    },
    "FRecipeAmountPair": {
      "type": "object",
      "properties": {
        "Recipe": {
          "description": "Recipe to give player",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Amount": {
          "description": "How many of given recipe",
          "type": "number"
        }
      },
      "required": [
        "Amount",
        "Recipe"
      ]
    },
    "AFGActorRepresentationManager": {
      "type": "object",
      "properties": {
        "mOnActorRepresentationAdded": {
          "description": "Called whenever a new representation is added"
        },
        "mOnActorRepresentationRemoved": {
          "description": "Called whenever a new representation is removed, not sure how long it will be valid after a remove."
        },
        "mOnActorRepresentationUpdated": {
          "description": "Called whenever a representation is updated"
        },
        "mOnActorRepresentationUpdatedCompassShow": {
          "description": "Called whenever a new representation changes it's show value for the compass"
        },
        "mOnActorRepresentationUpdatedMapShow": {
          "description": "Called whenever a new representation changes it's show value for the maps"
        },
        "mOnActorRepresentationTypeFilteredOnMap": {
          "description": "Called whenever a representation type changes it's filter status on the map"
        },
        "mOnActorRepresentationTypeFilteredOnCompass": {
          "description": "Called whenever a representation type changes it's filter status on the compass"
        },
        "mReplicatedRepresentations": {
          "description": "These are all the representations of actors that should replicate from server to clients",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGActorRepresentation"
          }
        },
        "mClientReplicatedRepresentations": {
          "description": "Simulated on client to keep track of added and removed representations",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGActorRepresentation"
          }
        },
        "mLocalRepresentations": {
          "description": "These are representation that the local player adds for them selves, often temporary stuff that others shouldn't see",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGActorRepresentation"
          }
        }
      },
      "required": [
        "mClientReplicatedRepresentations",
        "mLocalRepresentations",
        "mOnActorRepresentationAdded",
        "mOnActorRepresentationRemoved",
        "mOnActorRepresentationTypeFilteredOnCompass",
        "mOnActorRepresentationTypeFilteredOnMap",
        "mOnActorRepresentationUpdated",
        "mOnActorRepresentationUpdatedCompassShow",
        "mOnActorRepresentationUpdatedMapShow",
        "mReplicatedRepresentations"
      ]
    },
    "AFGMapManager": {
      "type": "object",
      "properties": {
        "mFogOfWarRawData": {
          "description": "The raw pixel data for the fog of war texture. Each element represents a channel for a pixel",
          "type": "array",
          "items": {
            "type": "number"
          }
        },
        "mFogOfWarTexture": {
          "description": "The fog of war texture that is used for the map",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCachedMinimapCaptureActor": {
          "$ref": "#/definitions/AFGMinimapCaptureActor",
          "description": "Capture actor used for translate world locations to map locations"
        },
        "mFogOfWarTransferQueue": {
          "description": "Queue to handle clients waiting for fog of war transfer",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFogOfWarQueuePair"
          }
        },
        "mActorRepresentationManager": {
          "$ref": "#/definitions/AFGActorRepresentationManager",
          "description": "Actor representation manager to get representations updates to calculate fog of war data"
        },
        "mDynamicFogOfWarRevealActors": {
          "description": "The currently active dynamic actor representations that reveal fog of war",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGActorRepresentation"
          }
        }
      },
      "required": [
        "mActorRepresentationManager",
        "mCachedMinimapCaptureActor",
        "mDynamicFogOfWarRevealActors",
        "mFogOfWarRawData",
        "mFogOfWarTexture",
        "mFogOfWarTransferQueue"
      ]
    },
    "FFogOfWarQueuePair": {
      "type": "object",
      "properties": {
        "playerController": {
          "$ref": "#/definitions/AFGPlayerController"
        }
      },
      "required": [
        "playerController"
      ]
    },
    "AFGRadioactivitySubsystem": {
      "type": "object",
      "properties": {
        "mSources": {
          "$ref": "#/definitions/Map<UObject,FRadioactiveSource>",
          "description": "All the radioactive sources."
        },
        "mAffectedActors": {
          "description": "All actors that can take damage from radiation.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AActor"
          }
        }
      },
      "required": [
        "mAffectedActors",
        "mSources"
      ]
    },
    "Map<UObject,FRadioactiveSource>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "AFGChatManager": {
      "type": "object",
      "properties": {
        "OnChatMessageAdded": {
          "description": "Called when you get a new local message"
        },
        "mMaxNumMessagesInHistory": {
          "description": "How many messages will we save in the chat history",
          "type": "number"
        },
        "mMessageVisibleDuration": {
          "description": "How long a message will stay fresh and visible without opening the chat",
          "type": "number"
        },
        "mReceivedMessages": {
          "description": "An array of all the messages that the local player have received.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FChatMessageStruct"
          }
        }
      },
      "required": [
        "OnChatMessageAdded",
        "mMaxNumMessagesInHistory",
        "mMessageVisibleDuration",
        "mReceivedMessages"
      ]
    },
    "AFGCentralStorageSubsystem": {
      "type": "object",
      "properties": {
        "CentralStorageAddedOrRemoved": {
          "description": "Called when a central storage has been removed"
        },
        "mCentralStorages": {
          "description": "All the central storages built.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCentralStorageContainer"
          }
        }
      },
      "required": [
        "CentralStorageAddedOrRemoved",
        "mCentralStorages"
      ]
    },
    "AFGPipeSubsystem": {
      "type": "object",
      "properties": {
        "mNetworks": {
          "$ref": "#/definitions/Map<number,AFGPipeNetwork>",
          "description": "Map with all circuits and the circuit ID as the key."
        }
      },
      "required": [
        "mNetworks"
      ]
    },
    "Map<number,AFGPipeNetwork>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "AFGUnlockSubsystem": {
      "type": "object",
      "properties": {
        "mOnUnlockedMoreInventorySlots": {
          "description": "SERVER ONLY: Called when we unlocked more inventory slots"
        },
        "mOnUnlockedMoreArmsSlots": {
          "description": "SERVER ONLY: Called when we unlocked more arms slots"
        },
        "mMapUnlockedMessage": {
          "description": "Message sent when the map is unlocked",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInventorySlotUnlockedMessage": {
          "description": "Message sent when unlocking inventory slot",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildingEfficiencyUnlockedMessage": {
          "description": "Message sent when unlocking building efficiency display",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildingOverclockUnlockedMessage": {
          "description": "Message sent when unlocking overclocking of buildings",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mArmEquipmentSlotUnlockedMessage": {
          "description": "Message sent when unlocking arm equipment slot",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mScannableResources": {
          "description": "These are the resources the players can use their scanner to find",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mIsMapUnlocked": {
          "description": "Did the player unlock the minimap?",
          "type": "boolean"
        },
        "mIsBuildingEfficiencyUnlocked": {
          "description": "Is the building efficiency display unlocked",
          "type": "boolean"
        },
        "mIsBuildingOverclockUnlocked": {
          "description": "Is the building overclocking unlocked",
          "type": "boolean"
        },
        "mNumTotalInventorySlots": {
          "description": "The highest total number of inventory slots that any player have ever had, saved for save compatibility and rebalancing",
          "type": "number"
        },
        "mNumTotalArmEquipmentSlots": {
          "description": "The highest total number of arm equipment slots that any player have ever had, saved for save compatibility and rebalancing",
          "type": "number"
        }
      },
      "required": [
        "mArmEquipmentSlotUnlockedMessage",
        "mBuildingEfficiencyUnlockedMessage",
        "mBuildingOverclockUnlockedMessage",
        "mInventorySlotUnlockedMessage",
        "mIsBuildingEfficiencyUnlocked",
        "mIsBuildingOverclockUnlocked",
        "mIsMapUnlocked",
        "mMapUnlockedMessage",
        "mNumTotalArmEquipmentSlots",
        "mNumTotalInventorySlots",
        "mOnUnlockedMoreArmsSlots",
        "mOnUnlockedMoreInventorySlots",
        "mScannableResources"
      ]
    },
    "FFGBuildingColorSlotStruct": {
      "type": "object",
      "properties": {
        "primary": {
          "$ref": "#/definitions/Color"
        },
        "secondary": {
          "$ref": "#/definitions/Color"
        }
      },
      "required": [
        "primary",
        "secondary"
      ]
    },
    "AFGProximitySubsystem": {
      "type": "object",
      "properties": {
        "mOwningController": {
          "$ref": "#/definitions/AFGPlayerController"
        },
        "mRootComponent": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mMapAreaParticleCollection": {
          "description": "Contains mappings of particle system that should play when entering a given map area",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FMapAreaParticleCollection"
          }
        },
        "mPooledDecals": {
          "description": "Pool of decals",
          "type": "array",
          "items": {}
        },
        "mMaxNumDecals": {
          "description": "How many decals we want to show",
          "type": "number"
        }
      },
      "required": [
        "mMapAreaParticleCollection",
        "mMaxNumDecals",
        "mOwningController",
        "mPooledDecals",
        "mRootComponent"
      ]
    },
    "FMapAreaParticleCollection": {
      "type": "object",
      "properties": {
        "Areas": {
          "description": "Array of map areas that all use the same particle",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "Particle": {
          "description": "Particle associated with map areas"
        }
      },
      "required": [
        "Areas",
        "Particle"
      ]
    },
    "AFGAdminInterface": {
      "type": "object"
    },
    "UFGCheatManager": {
      "type": "object",
      "properties": {
        "mPopularUClassChoices": {
          "description": "This is used to make picking the same classes in the cheat board easier",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "mPopularUClassChoices"
      ]
    },
    "FAggroEntry": {
      "type": "object",
      "properties": {
        "AggroTarget": {
          "$ref": "#/definitions/IFGAggroTargetInterface"
        },
        "Aggro": {
          "description": "A floating point number.",
          "type": "number"
        },
        "LastHurtTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "Ignore": {
          "$ref": "#/definitions/EIgnore"
        }
      },
      "required": [
        "Aggro",
        "AggroTarget",
        "Ignore",
        "LastHurtTime"
      ]
    },
    "IFGAggroTargetInterface": {
      "description": "Templated version of [FScriptInterface](API\\Runtime\\CoreUObject\\UObjectBase\\FScriptInterface),\nwhich provides accessors and operators for referencing the interface portion\nof a [UObjectBase](API\\Runtime\\CoreUObject\\UObjectBase\\UObjectBase) that implements a\nnative interface.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/TScriptInterface/index.html",
      "type": "object"
    },
    "EIgnore": {
      "enum": [
        0,
        1,
        2,
        3,
        4
      ],
      "type": "number"
    },
    "FRemovedInstanceArray": {
      "description": "Wrapper around the Items struct to enable custom delta serialization (we send a part of the data to the client every frame instead of sending it all in one frame)",
      "type": "object",
      "properties": {
        "FoliageRemover": {
          "$ref": "#/definitions/AFGFoliageRemoval"
        },
        "Items": {
          "description": "All the items that has been removed from the AFGFoliageRemoval",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FRemovedInstance"
          }
        }
      },
      "required": [
        "FoliageRemover",
        "Items"
      ]
    },
    "AFGFoliageRemoval": {
      "type": "object",
      "properties": {
        "mRemovedInstances": {
          "$ref": "#/definitions/FRemovedInstanceArray",
          "description": "Instances to remove, has custom \"ReplicatedUsing\", so we get a notify for each instance replicated"
        },
        "mMeshComponent": {
          "description": "This needs to be a UPROPERTY as it will become null:ed when the level this actor is associated with is streamed out"
        },
        "mLevelName": {
          "description": "The name of the level that this actor removes foliage from, so that the foliage system can find it",
          "type": "string"
        },
        "mFoliageTypeName": {
          "description": "The name of mesh component to use the level",
          "type": "string"
        },
        "mLevelBounds": {
          "description": "ServerOnly: The bounds of the level we have foliage in (@todo: Can we remove this savegame tag?)"
        }
      },
      "required": [
        "mFoliageTypeName",
        "mLevelBounds",
        "mLevelName",
        "mMeshComponent",
        "mRemovedInstances"
      ]
    },
    "FRemovedInstance": {
      "description": "We can't send the id of the instance to clients, as that requires us to maintain a commandbuffer with all done commands to be able to get the same id's a server/client",
      "type": "object",
      "properties": {
        "Location": {
          "description": "Stored in localspace. Compressed location to get the id of the item, @todo: Toy around with different FVector_NetQuantize and see what works best"
        },
        "Transform": {
          "description": "Stored in localspace"
        }
      },
      "required": [
        "Location",
        "Transform"
      ]
    },
    "Map<number,FBuilding>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGSaveSession": {
      "type": "object",
      "properties": {
        "mAutosaveInterval": {
          "description": "How often in seconds to autosave, a value of < 0 means disabled",
          "type": "number"
        },
        "mNumRotatingAutosaves": {
          "description": "The number of autosaves to rotate",
          "type": "number"
        }
      },
      "required": [
        "mAutosaveInterval",
        "mNumRotatingAutosaves"
      ]
    },
    "Map<any,any>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "Map<any,number>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "IFGExtractableResourceInterface": {
      "description": "Templated version of [FScriptInterface](API\\Runtime\\CoreUObject\\UObjectBase\\FScriptInterface),\nwhich provides accessors and operators for referencing the interface portion\nof a [UObjectBase](API\\Runtime\\CoreUObject\\UObjectBase\\UObjectBase) that implements a\nnative interface.\n\nhttps://docs.unrealengine.com/en-US/API/Runtime/CoreUObject/UObject/TScriptInterface/index.html",
      "type": "object"
    },
    "AFGBuildableResourceExtractor": {
      "type": "object",
      "properties": {
        "mExtractStartupTime": {
          "description": "Power up time for the extraction process, e.g. the time it takes for a drill to start spinning.",
          "type": "number"
        },
        "mExtractStartupTimer": {
          "description": "How much time we have left of the start up time for the extraction process (mExtractStartupTime).",
          "type": "number"
        },
        "mExtractCycleTime": {
          "description": "How long does it take to complete one mining cycle. In seconds.",
          "type": "number"
        },
        "mItemsPerCycle": {
          "description": "How many items are extracted per cycle",
          "type": "number"
        },
        "mAllowedResourceForms": {
          "description": "Can we mine solids, liquids, gases or many of the types.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/EResourceForm"
          }
        },
        "mRequireResourceAtMinimumDepthChecks": {
          "type": "boolean"
        },
        "mMinimumDepthForPlacement": {
          "description": "(For Hologram) Minimum depth to collision this extractor requires to be placed ( tex. Water Pumps need to be at least X distance above floor )",
          "type": "number"
        },
        "mDepthTraceOriginOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Offset from hologram origin to begin and end traces When performing minimum depth checks ( if enabled for this buildable ) during placement"
        },
        "mOnlyAllowCertainResources": {
          "type": "boolean"
        },
        "mAllowedResources": {
          "description": "List of acceptable resources this extractor can mine / pump",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mExtractionOffset": {
          "$ref": "#/definitions/Vector"
        },
        "mMustPlaceOnResourceDisqualifier": {
          "description": "Class disqualifier to use when this resource extractor is not placed on a matching resource node ( used in the hologram )",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mExtractorTypeName": {
          "description": "name used to mathc types of extractros for compatiblility when upgrading",
          "type": "string"
        },
        "mExtractResourceNode": {
          "$ref": "#/definitions/AFGResourceNode"
        },
        "mExtractableResource": {
          "$ref": "#/definitions/AActor"
        },
        "mCurrentExtractProgress": {
          "description": "Current extract progress in the range [0, 1]",
          "type": "number"
        },
        "mPipeOutputConnections": {
          "description": "Cached pipe output connections",
          "type": "array",
          "items": {}
        },
        "mOutputInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "Our output inventory,"
        },
        "mReplicatedFlowRate": {
          "description": "Replicated smoothed flow rate",
          "type": "number"
        },
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mAllowedResourceForms",
        "mAllowedResources",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentExtractProgress",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDepthTraceOriginOffset",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mExtractCycleTime",
        "mExtractResourceNode",
        "mExtractStartupTime",
        "mExtractStartupTimer",
        "mExtractableResource",
        "mExtractionOffset",
        "mExtractorTypeName",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mItemsPerCycle",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumDepthForPlacement",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mMustPlaceOnResourceDisqualifier",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mOnlyAllowCertainResources",
        "mOutputInventory",
        "mPendingPotential",
        "mPipeOutputConnections",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicatedFlowRate",
        "mReplicationDetailActor",
        "mRequireResourceAtMinimumDepthChecks",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "FNewsFeedMap": {
      "type": "object",
      "properties": {
        "GameVersion": {
          "$ref": "#/definitions/EGameVersion"
        },
        "URL": {
          "type": "string"
        }
      },
      "required": [
        "GameVersion",
        "URL"
      ]
    },
    "EGameVersion": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "AFGNobeliskExplosive": {
      "type": "object",
      "properties": {
        "mRotatingMovementComp": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mDetonateIn": {
          "description": "Tells client to mark this to explode after a certain time",
          "type": "number"
        },
        "mEnvironmentDestructionSphere": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mThrowRotation": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mDestructionCollisionComp": {
          "description": "Collision Component used to determine which objects should be considered for destruction"
        },
        "mDestroysRelevantActors": {
          "description": "Should actors implementing destructable interfaces be considered for destruction",
          "type": "boolean"
        },
        "mDestroysFoliage": {
          "description": "Should foliage be considered for destruction",
          "type": "boolean"
        },
        "mMaxParticleSpawnsPerDetonation": {
          "description": "Any amount of particle systems over this limit will not be spawned",
          "type": "number"
        },
        "mProjectileData": {
          "$ref": "#/definitions/FProjectileData",
          "description": "projectile data"
        },
        "mHasExploded": {
          "description": "did it explode?",
          "type": "boolean"
        },
        "mInitialVelocity": {
          "$ref": "#/definitions/Vector",
          "description": "Used to get the velocity over to clients"
        },
        "mCollisionComp": {
          "description": "Sphere collision component"
        },
        "mProjectileMovement": {
          "description": "Projectile movement component"
        },
        "mTargetLocation": {
          "$ref": "#/definitions/Vector",
          "description": "Location we are aiming at ( if any )"
        },
        "mCanTriggerExplodeBySameClass": {
          "description": "Indicates if we should explode if we are taking damage from same actor class as ourselves",
          "type": "boolean"
        },
        "mExplodeAtEndOfLife": {
          "description": "Should the projectile explode when it dies of lifespan?",
          "type": "boolean"
        },
        "mCachedPC": {
          "$ref": "#/definitions/AFGPlayerController",
          "description": "Caching the PC so that we can do damage even without a valid weapon"
        }
      },
      "required": [
        "mCachedPC",
        "mCanTriggerExplodeBySameClass",
        "mCollisionComp",
        "mDestroysFoliage",
        "mDestroysRelevantActors",
        "mDestructionCollisionComp",
        "mDetonateIn",
        "mEnvironmentDestructionSphere",
        "mExplodeAtEndOfLife",
        "mHasExploded",
        "mInitialVelocity",
        "mMaxParticleSpawnsPerDetonation",
        "mProjectileData",
        "mProjectileMovement",
        "mRotatingMovementComp",
        "mTargetLocation",
        "mThrowRotation"
      ]
    },
    "FScannableDetails": {
      "type": "object",
      "properties": {
        "ScannableClass": {
          "description": "Type of object to scan for",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "DisplayText": {
          "description": "Name of object to scan for",
          "type": "string"
        },
        "ScannerLightColor": {
          "$ref": "#/definitions/Color",
          "description": "Scanner light color"
        },
        "PreCacheAllOfType": {
          "type": "boolean"
        },
        "ShouldOverrideDetectionRange": {
          "type": "boolean"
        },
        "NewDetectionRange": {
          "description": "Override the base detection range of the scanner",
          "type": "number"
        },
        "RequiredSchematic": {
          "description": "Required schematic to search for this object. None means no requirement.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "DisplayText",
        "NewDetectionRange",
        "PreCacheAllOfType",
        "RequiredSchematic",
        "ScannableClass",
        "ScannerLightColor",
        "ShouldOverrideDetectionRange"
      ]
    },
    "AFGVehicle": {
      "type": "object",
      "properties": {
        "mDisplayName": {
          "description": "The human readable name for this vehicle.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description for this vehicle.",
          "type": "string"
        },
        "mHologramClass": {
          "description": "Hologram to build this class with.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh": {
          "description": "The main skeletal mesh associated with this Vehicle"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mDisabledByWaterLocations": {
          "description": "If any of these locations enters water, then we are unusable",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this vehicle was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mIsSelfDriving": {
          "description": "If this vehicle is self driving.",
          "type": "boolean"
        },
        "mSelfDrivingController": {
          "description": "The AI that controls this vehicle when self-driving is activated."
        },
        "mStoredPhysicsData": {
          "description": "Saved like this, as we can't store it in serialize, as it will be killed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehiclePhysicsData"
          }
        },
        "mConstructSound": {
          "description": "Sound played when this vehicle is created"
        },
        "mIsDestructible": {
          "description": "Can this vehicle be destroyed by damage?",
          "type": "number"
        },
        "mIsSubmergedInWater": {
          "description": "If true, then we are submerged in water",
          "type": "number"
        },
        "mSubmergedAngularDamping": {
          "description": "increased angular damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedLinearDamping": {
          "description": "increased linear damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedBouyantForce": {
          "description": "upwards force applied to vehicles when underwater",
          "type": "number"
        },
        "mGasDamageType": {
          "description": "Gas damage typ that should be redirected to the driver",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the vehicle should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this vehicle should be significant within",
          "type": "number"
        },
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "mAddToSignificanceManager",
        "mBuiltWithRecipe",
        "mConstructSound",
        "mDescription",
        "mDisabledByWaterLocations",
        "mDisplayName",
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mGasDamageType",
        "mHealthComponent",
        "mHologramClass",
        "mIsDestructible",
        "mIsDriverVisible",
        "mIsDriving",
        "mIsSelfDriving",
        "mIsSubmergedInWater",
        "mMesh",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mSelfDrivingController",
        "mShouldAttachDriver",
        "mSignificanceBias",
        "mSignificanceRange",
        "mStoredPhysicsData",
        "mSubmergedAngularDamping",
        "mSubmergedBouyantForce",
        "mSubmergedLinearDamping"
      ]
    },
    "AFGSplineHologram": {
      "type": "object",
      "properties": {
        "mSplineComponent": {
          "description": "The spline component we're placing."
        },
        "mSplineData": {
          "description": "This is the data needed to create the spline component (local space).",
          "type": "array",
          "items": {}
        },
        "mIsConnectionSnappedOnConstruction": {
          "description": "Used in the construction message to determine if this has snapped to an existing connection or not",
          "type": "number"
        },
        "mBuildStep": {
          "$ref": "#/definitions/ESplineHologramBuildStep"
        },
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mBuildStep",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsConnectionSnappedOnConstruction",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxPlacementFloorAngle",
        "mPlacementMaterial",
        "mRecipe",
        "mSnappedBuilding",
        "mSplineComponent",
        "mSplineData",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGPipelineSupportHologram": {
      "type": "object",
      "properties": {
        "mSupportMesh": {
          "$ref": "#/definitions/FPoleHeightMesh",
          "description": "The most fitting mesh for our aim height."
        },
        "mCanAdjustVerticalAngle": {
          "description": "if you should be able to adjust the vrticale direction of the connection and top part of the pole",
          "type": "boolean"
        },
        "mSnapConnection": {
          "description": "The connection conveyors snap to, used when placing a support automatically."
        },
        "mVerticalAngle": {
          "description": "Used to rotate the connection and top part vetically",
          "type": "number"
        },
        "mSupportMeshComponent": {
          "description": "The support mesh."
        },
        "mSupportTopPartMeshComponent": {
          "description": "The support mesh."
        },
        "mSupportLengthComponent": {
          "description": "The scene component for adjusting the length of the support."
        },
        "mClearanceMeshComponent": {
          "description": "Mesh component used to display the clearance mesh"
        },
        "mClearanceMesh": {
          "description": "Mesh we want to use in the component",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mClearanceMaterial": {
          "description": "Material to use on the clearance component"
        },
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mCanAdjustVerticalAngle",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mClearanceMaterial",
        "mClearanceMesh",
        "mClearanceMeshComponent",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxPlacementFloorAngle",
        "mPlacementMaterial",
        "mRecipe",
        "mSnapConnection",
        "mSnappedBuilding",
        "mSupportLengthComponent",
        "mSupportMesh",
        "mSupportMeshComponent",
        "mSupportTopPartMeshComponent",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial",
        "mVerticalAngle"
      ]
    },
    "AFGBuildablePipelineSupport": {
      "type": "object",
      "properties": {
        "mLength": {
          "description": "This supports length.",
          "type": "number"
        },
        "mVerticalAngle": {
          "description": "This supports length.",
          "type": "number"
        },
        "mSupportComponentDefaultMesh": {
          "$ref": "#/definitions/UFGColoredInstanceMeshProxy",
          "description": "The component we want to use with the support"
        },
        "mSnapOnly0": {
          "description": "OST BE SET FROM CONSTRUCTION SCRIPT OR IT WILL BE NULL!"
        },
        "mSupportLengthComponent": {
          "description": "The scene component for adjusting the length of the support."
        },
        "mSupportMesh": {
          "description": "Static mesh to use when rendering",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseStaticHeight": {
          "description": "Should the stack height only be calculated using the mStackHeight?",
          "type": "boolean"
        },
        "mCanStack": {
          "description": "Can this pole stack.",
          "type": "boolean"
        },
        "mStackHeight": {
          "description": "Height between two stacked poles excluding the poles height.",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanStack",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mLength",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSnapOnly0",
        "mStackHeight",
        "mSupportComponentDefaultMesh",
        "mSupportLengthComponent",
        "mSupportMesh",
        "mUseStaticHeight",
        "mVerticalAngle"
      ]
    },
    "FSplineSupportPair": {
      "type": "object",
      "properties": {
        "SplineSupportRecipeClass": {
          "description": "What recipe to use for the spline support",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "SplineRecipeClass": {
          "description": "What recipe to use for the spline",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "SplineRecipeClass",
        "SplineSupportRecipeClass"
      ]
    },
    "IFGFluidIntegrantInterface": {
      "type": "object"
    },
    "AFGBuildableFoundation": {
      "type": "object",
      "properties": {
        "mSize": {
          "description": "Size of the foundation (size of one side of the square).",
          "type": "number"
        },
        "mHeight": {
          "description": "Height of the foundation. Origo is assumed to be half way between.",
          "type": "number"
        },
        "mElevation": {
          "description": "Elevation of this foundation if ramp, assumes the ramp to go down towards a positive X.",
          "type": "number"
        },
        "mDisableSnapOn": {
          "$ref": "#/definitions/FFoundationSideSelectionFlags",
          "description": "Disable snapping on specific sides."
        },
        "mMeshComponentProxy": {
          "$ref": "#/definitions/UFGColoredInstanceMeshProxy",
          "description": "Mesh component for the factory building."
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mDescription",
        "mDidFirstTimeUse",
        "mDisableSnapOn",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mElevation",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHeight",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMeshComponentProxy",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSize",
        "mSkipBuildEffect"
      ]
    },
    "FResourceDepositPackage": {
      "type": "object",
      "properties": {
        "DropChance": {
          "description": "Chance in roulette selection to get the package",
          "type": "number"
        },
        "ResourceClass": {
          "description": "What resource class to use",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "MinAmount": {
          "description": "Amount of resources in deposit as minimum",
          "type": "number"
        },
        "MaxAmount": {
          "description": "Amount of resources in deposit as max",
          "type": "number"
        },
        "MiningAmount": {
          "description": "How much to get per \"mine cycle\"",
          "type": "number"
        }
      },
      "required": [
        "DropChance",
        "MaxAmount",
        "MinAmount",
        "MiningAmount",
        "ResourceClass"
      ]
    },
    "FMaterialAndSlotName": {
      "type": "object",
      "properties": {
        "SlotName": {
          "description": "This is the slot name on the character",
          "type": "string"
        },
        "Material": {
          "description": "The material to put on that slot name"
        }
      },
      "required": [
        "Material",
        "SlotName"
      ]
    },
    "AFGTargetPoint": {
      "type": "object",
      "properties": {
        "mNext": {
          "$ref": "#/definitions/AFGTargetPoint",
          "description": "Reference to the next target point ( used in linked list )"
        },
        "mOwningVehicle": {
          "$ref": "#/definitions/AFGWheeledVehicle",
          "description": "Vehicle that created this node"
        },
        "mIsVisible": {
          "description": "Update visibility",
          "type": "boolean"
        },
        "mWaitTime": {
          "description": "Accumulated wait time for this node",
          "type": "number"
        },
        "mDefaultWaitTime": {
          "description": "Default wait time if this target point has no target speed",
          "type": "number"
        },
        "mTargetSpeed": {
          "description": "Target speed at this node",
          "type": "number"
        }
      },
      "required": [
        "mDefaultWaitTime",
        "mIsVisible",
        "mNext",
        "mOwningVehicle",
        "mTargetSpeed",
        "mWaitTime"
      ]
    },
    "AFGWheeledVehicle": {
      "type": "object",
      "properties": {
        "mWorkBench": {
          "$ref": "#/definitions/UFGWorkBench",
          "description": "Workbench component"
        },
        "mUpdateMovementHandle": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mForceSimulationMode": {
          "description": "Forces vehicle to be in simulation mode",
          "type": "boolean"
        },
        "mForceRealMode": {
          "description": "Forces vehicle to be in real mode",
          "type": "boolean"
        },
        "TranferStatusChangedDelegate": {
          "description": "Broadcast when transfer status is updated"
        },
        "mReplicatedState": {
          "$ref": "#/definitions/FReplicatedAddedVelocitiesState",
          "description": "replicated state of vehicle"
        },
        "mFuelConsumption": {
          "description": "This vehicles fuel consumption in MW/s",
          "type": "number"
        },
        "mCurrentFuelAmount": {
          "description": "Amount left of the currently burned piece of fuel. In megawatt seconds (MWs).",
          "type": "number"
        },
        "mIsLoadingVehicle": {
          "description": "Are we currently in the process of loading inventory",
          "type": "boolean"
        },
        "mIsUnloadingVehicle": {
          "description": "Are we currently in the process of unloading inventory",
          "type": "boolean"
        },
        "mCurrentFuelClass": {
          "description": "Type of the currently burned piece of fuel.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mIsInAir": {
          "description": "Is vehicle in air",
          "type": "boolean"
        },
        "mNumWheelsOnGround": {
          "description": "Is there at least 1 wheel on the ground",
          "type": "number"
        },
        "mVehicleMovement": {
          "description": "vehicle simulation component"
        },
        "mDistBetweenDecals": {
          "description": "Distance between tire track decals",
          "type": "number"
        },
        "mDecalLifespan": {
          "description": "Time, in seconds, for the tire track decal to live",
          "type": "number"
        },
        "mDefaultTireTrackDecal": {
          "description": "default tire track decal. Can be empty for no default."
        },
        "mTireTrackDecals": {
          "description": "tire track decal  settings",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTireTrackDecalDetails"
          }
        },
        "mDecalSize": {
          "$ref": "#/definitions/Vector",
          "description": "The scale for the decal. This will probably need to be uniquely set for every vehicle."
        },
        "mFoliageDestroyRadius": {
          "description": "When foliage is run over by this vehicle, this is the radius of foliage that should be cleared",
          "type": "number"
        },
        "mAddedGroundAngularVelocityStrengthYaw": {
          "description": "Strength of the angular velocity yaw modifier when on the ground and holding \"drift\"",
          "type": "number"
        },
        "mAddedGroundAngularVelocityStrengthPitch": {
          "description": "Strength of the angular velocity pitch modifier when on the ground and holding \"drift\"",
          "type": "number"
        },
        "mAddedAirControlAngularVelocityStrengthYaw": {
          "description": "Strength of the added air control angular yaw velocity",
          "type": "number"
        },
        "mAddedAirControlAngularVelocityStrengthPitch": {
          "description": "Strength of the added air control angular pitch velocity",
          "type": "number"
        },
        "mNaturalAngularVelocityStrengthYaw": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNaturalAngularVelocityStrengthPitch": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNaturalAirAngularVelocityStrengthYaw": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNaturalAirAngularVelocityStrengthPitch": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mAddedAngularVelocityInputSmoothingSpeed": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mFoliageCollideBox": {
          "description": "Collision box for detecting overlaps with foliage only. Shape modified in BP"
        },
        "mIsSimulated": {
          "description": "Is the movement being simulated?",
          "type": "boolean"
        },
        "mSimulationDistance": {
          "description": "Distance from player at which simulation begins",
          "type": "number"
        },
        "mSimulationMovementComponent": {
          "description": "Our component used for simulated movement"
        },
        "mFuelInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "Inventory for fuel"
        },
        "mStorageInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "Inventory for storage"
        },
        "mInventorySize": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mTireParticleCollection": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FTireParticleCollection"
          }
        },
        "mVehicleParticeMap": {
          "description": "Map that lists which templates corresponds to what surface type",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FSurfaceParticlePair"
          }
        },
        "mActiveParticleAndTemplate": {
          "description": "Contains references to all current active partice systems on the tires",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FParticleTemplatePair"
          }
        },
        "mTireEffectSocketName": {
          "description": "Base name of socket use for tire particles",
          "type": "string"
        },
        "mTargetNodeLinkedList": {
          "$ref": "#/definitions/UFGTargetPointLinkedList",
          "description": "Linked list with target nodes that make up our path to travel"
        },
        "mIsPathVisible": {
          "description": "Should targets nodes be visible",
          "type": "boolean"
        },
        "mLastDecalLocations": {
          "description": "location of the last placed decals for each wheel",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mOverlappedHISMComponents": {
          "description": "If we have overlapped foliage go nuts and destroy them",
          "type": "array",
          "items": {}
        },
        "mAddedAngularVelocityInputPitch": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mAddedAngularVelocityInputYaw": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mReverseAddedAngularVelocityYawMultiplier": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mHasAirControl": {
          "description": "if true, can control vehicle in air",
          "type": "boolean"
        },
        "mGroundTraceLength": {
          "description": "length to trace to check for ground",
          "type": "number"
        },
        "mMaxDeltaLinearVelocity": {
          "description": "max change in linear velocity since last frame",
          "type": "number"
        },
        "mMaxDeltaAngularVelocity": {
          "description": "max change in angular velocity since last frame",
          "type": "number"
        },
        "mRollStabilisationStrength": {
          "description": "Amount of damping to add to roll",
          "type": "number"
        },
        "mMaxRollAngleForUpsideDown": {
          "description": "The min roll angle to consider the vehicle upside down - only as far as roll goes. Other factors are also taken into account.",
          "type": "number"
        },
        "mMaxFlatOnGroundRollAngleLimit": {
          "description": "The max roll angle to consider the vehicle flat on ground - only as far as roll goes. Other factors are also taken into account.",
          "type": "number"
        },
        "mMaxRollForActivationOfAssistedVelocities": {
          "description": "If roll angle is over this value then assisted velocities will not be applied.",
          "type": "number"
        },
        "mMaxSpeedForAddedAcceleration": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "mMaxAssistedAcceleration": {
          "description": "Maximum amount of force that can be added to assist acceleration",
          "type": "number"
        },
        "mHasAssistedVelocities": {
          "description": "If true, Assisted Acceleration & drifting is be in effect",
          "type": "boolean"
        },
        "mHasRollStabilisation": {
          "description": "If true, roll stabilisation is be in effect",
          "type": "boolean"
        },
        "mDriftingLateralForce": {
          "description": "the lateral force we add for drifting",
          "type": "number"
        },
        "mDriftingUpwardForce": {
          "description": "the upward force we add for drifting (this is to reduce friction & encourage oversteer)",
          "type": "number"
        },
        "mDriftForwardForceStrengthCurve": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mDriftForceBones": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mMinAngleForDrift": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mCachedSurfaceMaterial": {
          "description": "Cached surface material under the first tire"
        },
        "mNeedsFuelToDrive": {
          "description": "Do we need fuel to drive",
          "type": "boolean"
        },
        "mDisplayName": {
          "description": "The human readable name for this vehicle.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description for this vehicle.",
          "type": "string"
        },
        "mHologramClass": {
          "description": "Hologram to build this class with.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMesh": {
          "description": "The main skeletal mesh associated with this Vehicle"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mDisabledByWaterLocations": {
          "description": "If any of these locations enters water, then we are unusable",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this vehicle was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mIsSelfDriving": {
          "description": "If this vehicle is self driving.",
          "type": "boolean"
        },
        "mSelfDrivingController": {
          "description": "The AI that controls this vehicle when self-driving is activated."
        },
        "mStoredPhysicsData": {
          "description": "Saved like this, as we can't store it in serialize, as it will be killed",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehiclePhysicsData"
          }
        },
        "mConstructSound": {
          "description": "Sound played when this vehicle is created"
        },
        "mIsDestructible": {
          "description": "Can this vehicle be destroyed by damage?",
          "type": "number"
        },
        "mIsSubmergedInWater": {
          "description": "If true, then we are submerged in water",
          "type": "number"
        },
        "mSubmergedAngularDamping": {
          "description": "increased angular damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedLinearDamping": {
          "description": "increased linear damping when vehicle is under water",
          "type": "number"
        },
        "mSubmergedBouyantForce": {
          "description": "upwards force applied to vehicles when underwater",
          "type": "number"
        },
        "mGasDamageType": {
          "description": "Gas damage typ that should be redirected to the driver",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the vehicle should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this vehicle should be significant within",
          "type": "number"
        },
        "mShouldAttachDriver": {
          "description": "True if the driver should be attached, false if this is a \"remote controlled\" pawn.",
          "type": "boolean"
        },
        "mIsDriverVisible": {
          "description": "True if the driver should be visible, set from FVehicleSeat",
          "type": "boolean"
        },
        "mDriverSeatSocket": {
          "description": "Socket to attach the driver to, if mShouldAttachDriver is true, set from FVehicleSeat",
          "type": "string"
        },
        "mDriverSeatAnimation": {
          "description": "Animation to play on the character player when in the driver seat, set from FVehicleSeat"
        },
        "mDriverExitOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where to place the driver upon exiting (local space), set from FVehicleSeat"
        },
        "mDriver": {
          "$ref": "#/definitions/AFGCharacterPlayer",
          "description": "The driver, not saved, pawns remember their last driven vehicle and enters it in begin play."
        },
        "mIsDriving": {
          "description": "Is this vehicle being driven.",
          "type": "boolean"
        }
      },
      "required": [
        "TranferStatusChangedDelegate",
        "mActiveParticleAndTemplate",
        "mAddToSignificanceManager",
        "mAddedAirControlAngularVelocityStrengthPitch",
        "mAddedAirControlAngularVelocityStrengthYaw",
        "mAddedAngularVelocityInputPitch",
        "mAddedAngularVelocityInputSmoothingSpeed",
        "mAddedAngularVelocityInputYaw",
        "mAddedGroundAngularVelocityStrengthPitch",
        "mAddedGroundAngularVelocityStrengthYaw",
        "mBuiltWithRecipe",
        "mCachedSurfaceMaterial",
        "mConstructSound",
        "mCurrentFuelAmount",
        "mCurrentFuelClass",
        "mDecalLifespan",
        "mDecalSize",
        "mDefaultTireTrackDecal",
        "mDescription",
        "mDisabledByWaterLocations",
        "mDisplayName",
        "mDistBetweenDecals",
        "mDriftForceBones",
        "mDriftForwardForceStrengthCurve",
        "mDriftingLateralForce",
        "mDriftingUpwardForce",
        "mDriver",
        "mDriverExitOffset",
        "mDriverSeatAnimation",
        "mDriverSeatSocket",
        "mFoliageCollideBox",
        "mFoliageDestroyRadius",
        "mForceRealMode",
        "mForceSimulationMode",
        "mFuelConsumption",
        "mFuelInventory",
        "mGasDamageType",
        "mGroundTraceLength",
        "mHasAirControl",
        "mHasAssistedVelocities",
        "mHasRollStabilisation",
        "mHealthComponent",
        "mHologramClass",
        "mInventorySize",
        "mIsDestructible",
        "mIsDriverVisible",
        "mIsDriving",
        "mIsInAir",
        "mIsLoadingVehicle",
        "mIsPathVisible",
        "mIsSelfDriving",
        "mIsSimulated",
        "mIsSubmergedInWater",
        "mIsUnloadingVehicle",
        "mLastDecalLocations",
        "mMaxAssistedAcceleration",
        "mMaxDeltaAngularVelocity",
        "mMaxDeltaLinearVelocity",
        "mMaxFlatOnGroundRollAngleLimit",
        "mMaxRollAngleForUpsideDown",
        "mMaxRollForActivationOfAssistedVelocities",
        "mMaxSpeedForAddedAcceleration",
        "mMesh",
        "mMinAngleForDrift",
        "mNaturalAirAngularVelocityStrengthPitch",
        "mNaturalAirAngularVelocityStrengthYaw",
        "mNaturalAngularVelocityStrengthPitch",
        "mNaturalAngularVelocityStrengthYaw",
        "mNeedsFuelToDrive",
        "mNetConstructionID",
        "mNumWheelsOnGround",
        "mOverlappedHISMComponents",
        "mPrimaryColor",
        "mReplicatedState",
        "mReverseAddedAngularVelocityYawMultiplier",
        "mRollStabilisationStrength",
        "mSecondaryColor",
        "mSelfDrivingController",
        "mShouldAttachDriver",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSimulationDistance",
        "mSimulationMovementComponent",
        "mStorageInventory",
        "mStoredPhysicsData",
        "mSubmergedAngularDamping",
        "mSubmergedBouyantForce",
        "mSubmergedLinearDamping",
        "mTargetNodeLinkedList",
        "mTireEffectSocketName",
        "mTireParticleCollection",
        "mTireTrackDecals",
        "mUpdateMovementHandle",
        "mVehicleMovement",
        "mVehicleParticeMap",
        "mWorkBench"
      ]
    },
    "UFGWorkBench": {
      "type": "object",
      "properties": {
        "mCurrentRecipe": {
          "description": "The recipe we're currently running.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCurrentManufacturingProgress": {
          "description": "Manufacturing progress in range [0,1].",
          "type": "number"
        },
        "mManufacturingSpeed": {
          "description": "The speed of which this manufacturer manufactures stuff. Slower for Work Bench",
          "type": "number"
        },
        "mPlayerWorkingAtBench": {
          "$ref": "#/definitions/AFGCharacterPlayer"
        },
        "mRecipeRate": {
          "description": "Manufacturing rate in product per second.",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing?",
          "type": "boolean"
        },
        "mInventory": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The inventory this workbench is set to work with"
        },
        "mFatigueMultiplier": {
          "description": "Work bench efficiency decrease per interval. 0.2 means 20%",
          "type": "number"
        },
        "mFatigueDecreaseSpeedMultiplier": {
          "description": "Multiplier for mFatigueUpdaterInterval, shows how long it takes to go down one step in fatigue",
          "type": "number"
        },
        "mHoldProduceTime": {
          "description": "How long it takes to produce one cycle",
          "type": "number"
        },
        "mManufacturingButton": {
          "$ref": "#/definitions/UFGManufacturingButton"
        },
        "mFatigueUpdaterInterval": {
          "description": "at what interval should the fatigue multiplier be applied?",
          "type": "number"
        },
        "mRecipeDuration": {
          "description": "DUration it takes to make a recipe with added multipliers of manufacturingspeed and manufacturingmultiplier",
          "type": "number"
        },
        "mCooldownDelay": {
          "description": "How long to wait before applying cooldown",
          "type": "number"
        },
        "mIsFatigueEnabled": {
          "description": "Should fatigue be used on this component",
          "type": "boolean"
        }
      },
      "required": [
        "mCooldownDelay",
        "mCurrentManufacturingProgress",
        "mCurrentRecipe",
        "mFatigueDecreaseSpeedMultiplier",
        "mFatigueMultiplier",
        "mFatigueUpdaterInterval",
        "mHoldProduceTime",
        "mInventory",
        "mIsFatigueEnabled",
        "mIsProducing",
        "mManufacturingButton",
        "mManufacturingSpeed",
        "mPlayerWorkingAtBench",
        "mRecipeDuration",
        "mRecipeRate"
      ]
    },
    "UFGManufacturingButton": {
      "type": "object",
      "properties": {
        "OnManufacturePressed": {
          "description": "Called when a valid press on manufacture happens"
        }
      },
      "required": [
        "OnManufacturePressed"
      ]
    },
    "FReplicatedAddedVelocitiesState": {
      "type": "object",
      "properties": {
        "IsDrifting": {
          "description": "input replication: steering",
          "type": "boolean"
        },
        "AddedAngularVelocityInputPitch": {
          "description": "input replication: angular velocity pitch",
          "type": "number"
        },
        "AddedAngularVelocityInputYaw": {
          "description": "input replication: angular velocity yaw",
          "type": "number"
        }
      },
      "required": [
        "AddedAngularVelocityInputPitch",
        "AddedAngularVelocityInputYaw",
        "IsDrifting"
      ]
    },
    "FTireTrackDecalDetails": {
      "type": "object",
      "properties": {
        "SurfacePhysicsMaterial": {
          "description": "Surface material to override for"
        },
        "DecalMaterialOverride": {
          "description": "Material to use as an override"
        }
      },
      "required": [
        "DecalMaterialOverride",
        "SurfacePhysicsMaterial"
      ]
    },
    "FTireParticleCollection": {
      "type": "object",
      "properties": {
        "Collection": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FParticleTemplatePair"
          }
        }
      },
      "required": [
        "Collection"
      ]
    },
    "FParticleTemplatePair": {
      "type": "object",
      "properties": {
        "Template": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "Particle": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "Particle",
        "Template"
      ]
    },
    "FSurfaceParticlePair": {
      "type": "object",
      "properties": {
        "EmitterTemplate": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "Surface": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "EmitterTemplate",
        "Surface"
      ]
    },
    "UFGTargetPointLinkedList": {
      "type": "object",
      "properties": {
        "mFirst": {
          "$ref": "#/definitions/AFGTargetPoint",
          "description": "First node in linked list"
        },
        "mLast": {
          "$ref": "#/definitions/AFGTargetPoint",
          "description": "Last node in linked list"
        },
        "mCurrentTarget": {
          "$ref": "#/definitions/AFGTargetPoint",
          "description": "Current node"
        },
        "mMaxLength": {
          "description": "Max length that the linked list can be",
          "type": "number"
        }
      },
      "required": [
        "mCurrentTarget",
        "mFirst",
        "mLast",
        "mMaxLength"
      ]
    },
    "AFGFactoryHologram": {
      "type": "object",
      "properties": {
        "mClearanceMeshComponent": {
          "description": "Mesh component used to display the clearance mesh"
        },
        "mClearanceMesh": {
          "description": "Mesh we want to use in the component",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mClearanceMaterial": {
          "description": "Material to use on the clearance component"
        },
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mClearanceMaterial",
        "mClearanceMesh",
        "mClearanceMeshComponent",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxPlacementFloorAngle",
        "mPlacementMaterial",
        "mRecipe",
        "mSnappedBuilding",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGBuildableHologram": {
      "type": "object",
      "properties": {
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxPlacementFloorAngle",
        "mPlacementMaterial",
        "mRecipe",
        "mSnappedBuilding",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGRailroadTrackHologram": {
      "type": "object",
      "properties": {
        "mMinLength": {
          "description": "Length restriction of the track. [cm]",
          "type": "number"
        },
        "mMaxLength": {
          "description": "Length restriction of the track. [cm]",
          "type": "number"
        },
        "mMinBendRadius": {
          "description": "Turn radius restriction of the track. [cm]",
          "type": "number"
        },
        "mMaxGrade": {
          "description": "Grade restriction of the track. [degrees]",
          "type": "number"
        },
        "mSnapDistance": {
          "description": "From how far away we should snap to another track. [cm]",
          "type": "number"
        },
        "mConnectionComponents": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "The track connections we have."
        },
        "mSnappedConnectionComponents": {
          "$ref": "#/definitions/UFGRailroadTrackConnectionComponent",
          "description": "The track connection we snap when building the track."
        },
        "mSplineMeshes": {
          "description": "All the generated spline meshes.",
          "type": "array",
          "items": {}
        },
        "mMesh": {
          "description": "Cached from the default buildable.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSplineComponent": {
          "description": "The spline component we're placing."
        },
        "mSplineData": {
          "description": "This is the data needed to create the spline component (local space).",
          "type": "array",
          "items": {}
        },
        "mIsConnectionSnappedOnConstruction": {
          "description": "Used in the construction message to determine if this has snapped to an existing connection or not",
          "type": "number"
        },
        "mBuildStep": {
          "$ref": "#/definitions/ESplineHologramBuildStep"
        },
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mBuildStep",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mConnectionComponents",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsConnectionSnappedOnConstruction",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxGrade",
        "mMaxLength",
        "mMaxPlacementFloorAngle",
        "mMesh",
        "mMinBendRadius",
        "mMinLength",
        "mPlacementMaterial",
        "mRecipe",
        "mSnapDistance",
        "mSnappedBuilding",
        "mSnappedConnectionComponents",
        "mSplineComponent",
        "mSplineData",
        "mSplineMeshes",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGPowerPoleHologram": {
      "type": "object",
      "properties": {
        "mSnapConnection": {
          "$ref": "#/definitions/UFGCircuitConnectionComponent",
          "description": "The connection wires snap to, used when placing a pole automatically."
        },
        "mMaxPlacementFloorAngle": {
          "description": "The maximum allowed angle on the floor for this hologram to be placed on (in degrees).",
          "type": "number"
        },
        "mLegs": {
          "$ref": "#/definitions/UFGFactoryLegsComponent"
        },
        "mClearanceBox": {
          "description": "Component to check build clearance to other buildings."
        },
        "mSnappedBuilding": {
          "$ref": "#/definitions/AFGBuildable",
          "description": "If we have snapped to another buildable, i.e. foundation, floor etc, this is it."
        },
        "mValidHitClasses": {
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mRecipe": {
          "description": "The recipe for this hologram.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mLoopSound": {
          "description": "Looping sound to play on holograms"
        },
        "mClearanceDetector": {
          "description": "Clearance detector box. Used to detect nearby clearances an display them during the build steps"
        },
        "mPlacementMaterial": {
          "description": "Can we construct the building, updated by SetCanConstruct from the build gun.",
          "type": "boolean"
        },
        "mValidPlacementMaterial": {
          "description": "Material on hologram for valid placement."
        },
        "mInvalidPlacementMaterial": {
          "description": "Material on hologram for invalid placement."
        },
        "mChildren": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGHologram"
          }
        },
        "mBuildClass": {
          "description": "The class for the build actor this hologram wants to construct. Set on spawn.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseBuildClearanceOverlapSnapp": {
          "type": "boolean"
        },
        "mConstructionInstigator": {
          "description": "Who is building"
        },
        "mIsDisabled": {
          "description": "If this hologram is disabled and should not be visible or constructed.",
          "type": "boolean"
        },
        "mIsChanged": {
          "description": "If the hologram has changed, i.e. multi step placement or rotation.",
          "type": "boolean"
        },
        "mInitialScrollModeValue": {
          "description": "The client needs to know the initial saved scroll mode value from the BuildGun.",
          "type": "number"
        },
        "mConstructionPosition": {
          "$ref": "#/definitions/Vector",
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        },
        "mConstructionRotation": {
          "description": "Temp memory holders for when holograms are serialized for construction messages (replication)"
        }
      },
      "required": [
        "mBuildClass",
        "mChildren",
        "mClearanceBox",
        "mClearanceDetector",
        "mConstructionInstigator",
        "mConstructionPosition",
        "mConstructionRotation",
        "mInitialScrollModeValue",
        "mInvalidPlacementMaterial",
        "mIsChanged",
        "mIsDisabled",
        "mLegs",
        "mLoopSound",
        "mMaxPlacementFloorAngle",
        "mPlacementMaterial",
        "mRecipe",
        "mSnapConnection",
        "mSnappedBuilding",
        "mUseBuildClearanceOverlapSnapp",
        "mValidHitClasses",
        "mValidPlacementMaterial"
      ]
    },
    "AFGAtmosphereVolume": {
      "type": "object",
      "properties": {
        "mPriority": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mBlendDistance": {
          "description": "The distance that the fog blends over",
          "type": "number"
        },
        "mFogHeight": {
          "description": "Interpolate the fog height during the day"
        },
        "mFogDensity": {
          "description": "Interpolate the fog height during the day"
        },
        "mFogInscatteringColor": {
          "description": "Interpolate the fog height during the day"
        },
        "mFullyDirectionalInscatteringColorDistance": {
          "description": "Interpolate the fog height during the day"
        },
        "mNonDirectionalInscatteringColorDistance": {
          "description": "Interpolate the fog height during the day"
        },
        "mDirectionalInscatteringExponent": {
          "description": "Interpolate the fog height during the day"
        },
        "mDirectionalInscatteringStartDistance": {
          "description": "Interpolate the fog height during the day"
        },
        "mDirectionalInscatteringColor": {
          "description": "Interpolate the fog height during the day"
        },
        "mFogHeightFalloff": {
          "description": "Interpolate the fog height during the day"
        },
        "mFogMaxOpacity": {
          "description": "Interpolate the fog height during the day"
        },
        "mStartDistance": {
          "description": "Interpolate the fog height during the day"
        },
        "mFogCutoffDistance": {
          "description": "Interpolate the fog height during the day"
        },
        "mHorizonColorCurve": {
          "description": "How the color of the horizon changes during the day"
        },
        "mZenithColorCurve": {
          "description": "How the color of the zenith changes during the day"
        },
        "mCloudColorCurve": {
          "description": "How the color of clouds zenith changes during the day"
        },
        "mSunLightColorCurve": {
          "description": "How the opakeness of the clouds change during the day"
        },
        "mMoonLightColorCurve": {
          "description": "How the opakeness of the clouds change during the day"
        },
        "mSunIntensity": {
          "description": "How the opakeness of the clouds change during the day"
        },
        "mMoonIntensity": {
          "description": "How the opakeness of the clouds change during the day"
        },
        "mCloudOpacity": {
          "description": "How the opakeness of the clouds change during the day"
        },
        "mBlendWeight": {
          "description": "The blend weight of the post process volume",
          "type": "number"
        },
        "mWhiteTemp": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mWhiteTint": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorSaturation": {
          "description": "Color Correction controls"
        },
        "mColorContrast": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGamma": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGain": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorOffset": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorSaturationShadows": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorContrastShadows": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGammaShadows": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGainShadows": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorOffsetShadows": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorSaturationMidtones": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorContrastMidtones": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGammaMidtones": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGainMidtones": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorOffsetMidtones": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorSaturationHighlights": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorContrastHighlights": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGammaHighlights": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorGainHighlights": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorOffsetHighlights": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorCorrectionHighlightsMin": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mColorCorrectionShadowsMax": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mBlueCorrection": {
          "description": "Correct for artifacts with \"electric\" blues due to the ACEScg color space. Bright blue desaturates instead of going to violet."
        },
        "mExpandGamut": {
          "description": "Expand bright saturated colors outside the sRGB gamut to fake wide gamut rendering."
        },
        "mSceneColorTint": {
          "description": "Scene tint color"
        },
        "mFilmSlope": {
          "description": "Film Controls"
        },
        "mFilmToe": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mFilmShoulder": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mFilmBlackClip": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mFilmWhiteClip": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mContrast_DEPRECATED": {
          "description": "BEGIN DEPRECATED"
        },
        "mGain_DEPRECATED": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mSaturation_DEPRECATED": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mEnableContrast_DEPRECATED": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableGain_DEPRECATED": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableSaturation_DEPRECATED": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFogHeight": {
          "description": "Height fog bools",
          "type": "number"
        },
        "mEnableFogDensity": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFogInscatteringColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFullyDirectionalInscatteringColorDistance": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableNonDirectionalInscatteringColorDistance": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableDirectionalInscatteringExponent": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableDirectionalInscatteringStartDistance": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableDirectionalInscatteringColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFogHeightFalloff": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFogMaxOpacity": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableStartDistance": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFogCutoffDistance": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideHorizonColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideMoonIntensity": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideCloudOpacity": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideSunIntensity": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideZenithColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideCloudColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideSunLightColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mOverrideMoonLightColor": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableWhiteTemp": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableWhiteTint": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorSaturation": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorContrast": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGamma": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGain": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorOffset": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFilmSlope": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFilmToe": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFilmShoulder": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFilmBlackClip": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableFilmWhiteClip": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorSaturationShadows": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorContrastShadows": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGammaShadows": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGainShadows": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorOffsetShadows": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorSaturationMidtones": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorContrastMidtones": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGammaMidtones": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGainMidtones": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorOffsetMidtones": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorSaturationHighlights": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorContrastHighlights": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGammaHighlights": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorGainHighlights": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorOffsetHighlights": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorCorrectionShadowsMax": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableColorCorrectionHighlightsMin": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableBlueCorrection": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableExpandGamut": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mEnableSceneColorTint": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mPreviewTime": {
          "description": "A stampdown in time, where we want to show of the preview settings",
          "type": "number"
        },
        "mPreviewSettings": {
          "$ref": "#/definitions/FExponentialFogSettings",
          "description": "A preview of all the settings in the current fog-volume"
        }
      },
      "required": [
        "mBlendDistance",
        "mBlendWeight",
        "mBlueCorrection",
        "mCloudColorCurve",
        "mCloudOpacity",
        "mColorContrast",
        "mColorContrastHighlights",
        "mColorContrastMidtones",
        "mColorContrastShadows",
        "mColorCorrectionHighlightsMin",
        "mColorCorrectionShadowsMax",
        "mColorGain",
        "mColorGainHighlights",
        "mColorGainMidtones",
        "mColorGainShadows",
        "mColorGamma",
        "mColorGammaHighlights",
        "mColorGammaMidtones",
        "mColorGammaShadows",
        "mColorOffset",
        "mColorOffsetHighlights",
        "mColorOffsetMidtones",
        "mColorOffsetShadows",
        "mColorSaturation",
        "mColorSaturationHighlights",
        "mColorSaturationMidtones",
        "mColorSaturationShadows",
        "mContrast_DEPRECATED",
        "mDirectionalInscatteringColor",
        "mDirectionalInscatteringExponent",
        "mDirectionalInscatteringStartDistance",
        "mEnableBlueCorrection",
        "mEnableColorContrast",
        "mEnableColorContrastHighlights",
        "mEnableColorContrastMidtones",
        "mEnableColorContrastShadows",
        "mEnableColorCorrectionHighlightsMin",
        "mEnableColorCorrectionShadowsMax",
        "mEnableColorGain",
        "mEnableColorGainHighlights",
        "mEnableColorGainMidtones",
        "mEnableColorGainShadows",
        "mEnableColorGamma",
        "mEnableColorGammaHighlights",
        "mEnableColorGammaMidtones",
        "mEnableColorGammaShadows",
        "mEnableColorOffset",
        "mEnableColorOffsetHighlights",
        "mEnableColorOffsetMidtones",
        "mEnableColorOffsetShadows",
        "mEnableColorSaturation",
        "mEnableColorSaturationHighlights",
        "mEnableColorSaturationMidtones",
        "mEnableColorSaturationShadows",
        "mEnableContrast_DEPRECATED",
        "mEnableDirectionalInscatteringColor",
        "mEnableDirectionalInscatteringExponent",
        "mEnableDirectionalInscatteringStartDistance",
        "mEnableExpandGamut",
        "mEnableFilmBlackClip",
        "mEnableFilmShoulder",
        "mEnableFilmSlope",
        "mEnableFilmToe",
        "mEnableFilmWhiteClip",
        "mEnableFogCutoffDistance",
        "mEnableFogDensity",
        "mEnableFogHeight",
        "mEnableFogHeightFalloff",
        "mEnableFogInscatteringColor",
        "mEnableFogMaxOpacity",
        "mEnableFullyDirectionalInscatteringColorDistance",
        "mEnableGain_DEPRECATED",
        "mEnableNonDirectionalInscatteringColorDistance",
        "mEnableSaturation_DEPRECATED",
        "mEnableSceneColorTint",
        "mEnableStartDistance",
        "mEnableWhiteTemp",
        "mEnableWhiteTint",
        "mExpandGamut",
        "mFilmBlackClip",
        "mFilmShoulder",
        "mFilmSlope",
        "mFilmToe",
        "mFilmWhiteClip",
        "mFogCutoffDistance",
        "mFogDensity",
        "mFogHeight",
        "mFogHeightFalloff",
        "mFogInscatteringColor",
        "mFogMaxOpacity",
        "mFullyDirectionalInscatteringColorDistance",
        "mGain_DEPRECATED",
        "mHorizonColorCurve",
        "mMoonIntensity",
        "mMoonLightColorCurve",
        "mNonDirectionalInscatteringColorDistance",
        "mOverrideCloudColor",
        "mOverrideCloudOpacity",
        "mOverrideHorizonColor",
        "mOverrideMoonIntensity",
        "mOverrideMoonLightColor",
        "mOverrideSunIntensity",
        "mOverrideSunLightColor",
        "mOverrideZenithColor",
        "mPreviewSettings",
        "mPreviewTime",
        "mPriority",
        "mSaturation_DEPRECATED",
        "mSceneColorTint",
        "mStartDistance",
        "mSunIntensity",
        "mSunLightColorCurve",
        "mWhiteTemp",
        "mWhiteTint",
        "mZenithColorCurve"
      ]
    },
    "AFGAmbientVolume": {
      "type": "object",
      "properties": {
        "mAmbientSettings": {
          "description": "The settings for the volume",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAudioComponent": {
          "description": "The audio component we want to move around"
        },
        "mAdditionalAttenuationDistance": {
          "description": "How much further away than the attenuation distance do we want to start playing the ambient OnGeCloseSound",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "Range that this volume should be significant within",
          "type": "number"
        }
      },
      "required": [
        "mAdditionalAttenuationDistance",
        "mAmbientSettings",
        "mAudioComponent",
        "mSignificanceRange"
      ]
    },
    "AFGWaterVolume": {
      "type": "object",
      "properties": {
        "mAreaClass": {
          "description": "Specify what typ of nav area blocker this is ( defaults to null )",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mWaterAudio": {
          "description": "Audio settings for the this water volume",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCanPlaceExtractor": {
          "type": "boolean"
        },
        "mPostProcessSettings": {
          "description": "A template of settings for our post process settings",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAssociatedPostProcessVolume_DEPRECATED": {
          "description": "Old deprecated data that isn't used anymore, but we want to be sure that the post process volumes will be deleted"
        },
        "mResourceClass": {
          "description": "Reference to the Water Descriptor specified in FGResourceSettings. Assigned in begin play",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "mAreaClass",
        "mAssociatedPostProcessVolume_DEPRECATED",
        "mCanPlaceExtractor",
        "mPostProcessSettings",
        "mResourceClass",
        "mWaterAudio"
      ]
    },
    "AFGSkySphere": {
      "type": "object",
      "properties": {
        "mSunLightColorCurve": {
          "description": "How the sunlight changes during the day"
        },
        "mSunIntensity": {
          "description": "How does the suns intensity change during the day"
        },
        "mSunRotationPitch": {
          "description": "Unlogical property, basically tells how the suns location in it's curve should change during the day"
        },
        "mSunLightShaftOcclusionCurve": {
          "description": "Changes how the lightshafts changes during the day"
        },
        "mMoonLightColorCurve": {
          "description": "How the moonlight changes during the NIGHT"
        },
        "mMoonIntensity": {
          "description": "How does the moons intensity change during the NIGHT"
        },
        "mMoonRotationPitch": {
          "description": "Unlogical property, basically tells how the moons location in it's curve should change during the day"
        },
        "mMoonLightShaftOcclusionCurve": {
          "description": "Changes how the lightshafts changes during the day"
        },
        "mSkyLightIntensity": {
          "description": "How does the sky light intensity change during the day"
        },
        "mOcclusionTintColor": {
          "description": "How does the occlusion tint intensity change during the day"
        },
        "mHorizonColorCurve": {
          "description": "How the color of the horizon changes during the day"
        },
        "mZenithColorCurve": {
          "description": "How the color of the zenith changes during the day"
        },
        "mCloudColorCurve": {
          "description": "How the color of clouds zenith changes during the day"
        },
        "mCloudOpacity": {
          "description": "How the opakeness of the clouds change during the day"
        },
        "mStarBrightness": {
          "description": "How does the stars brightness change during the day"
        },
        "mSkyLightColor": {
          "description": "How does the ambient light color change during the day"
        },
        "mSunFogMultiplier": {
          "description": "How does the sun multiplier change during the day in the atmospheric fog"
        },
        "mPreviewTime": {
          "description": "How the sunlight changes during the day",
          "type": "number"
        }
      },
      "required": [
        "mCloudColorCurve",
        "mCloudOpacity",
        "mHorizonColorCurve",
        "mMoonIntensity",
        "mMoonLightColorCurve",
        "mMoonLightShaftOcclusionCurve",
        "mMoonRotationPitch",
        "mOcclusionTintColor",
        "mPreviewTime",
        "mSkyLightColor",
        "mSkyLightIntensity",
        "mStarBrightness",
        "mSunFogMultiplier",
        "mSunIntensity",
        "mSunLightColorCurve",
        "mSunLightShaftOcclusionCurve",
        "mSunRotationPitch",
        "mZenithColorCurve"
      ]
    },
    "AFGBuildableSubsystem": {
      "type": "object",
      "properties": {
        "mDistanceConsideredClose": {
          "description": "Distance used when calculating if a location is near a base",
          "type": "number"
        },
        "mNumFactoriesNeededForCloseCheck": {
          "description": "How many factories need to be within the close range for it to count as if a given location is near a base",
          "type": "number"
        },
        "BuildableConstructedGlobalDelegate": {
          "description": "Broadcast when a buildable or decor has been constructed. Regardless of who built it"
        },
        "mBuildables": {
          "description": "List of all buildables.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildable"
          }
        },
        "mConveyorAttachments": {
          "description": "All conveyor attachments",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGBuildableConveyorAttachment"
          }
        },
        "mBuildableInstancesActor": {
          "$ref": "#/definitions/AActor",
          "description": "Hierarchical instances for the factory buildings."
        },
        "mBuildableMeshInstances": {
          "$ref": "#/definitions/Map<packageReference<any>,any>"
        },
        "mColoredInstances": {
          "$ref": "#/definitions/Map<packageReference<any>,UFGColoredInstanceManager>",
          "description": "/"
        },
        "mColorSlotsPrimary": {
          "$ref": "#/definitions/Color"
        },
        "mColorSlotsSecondary": {
          "$ref": "#/definitions/Color"
        },
        "mNbPlayerExposedSlots": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mFactoryColoredMaterialMap": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "This is also used for non-colored materials, for example, the conveyor belt materials so that the same instance can be applied to many different belts"
        },
        "mUseFixedFactoryTick": {
          "description": "Begin Fixed Factory Tick Config Parameters",
          "type": "boolean"
        },
        "mMinFactoryTickRate": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxFactoryTickRate": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxTickSubsteps": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mDistanceBasedTickRate": {
          "description": "Information about what distances we change the tick rate on",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FDistanceBasedTickRate"
          }
        },
        "mFactoryOptimizationEnabled": {
          "description": "Is factory optimization ( tick control ) active",
          "type": "boolean"
        },
        "mReplayEffecTimeDilation": {
          "description": "How much time can differ between each build effect",
          "type": "number"
        },
        "mReplayEffectTimerDefault": {
          "description": "How much time between each build effect when replaying the whole factory",
          "type": "number"
        },
        "mDefaultFactoryMaterial": {
          "description": "used for comparing and finding materials of factory meshes"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        }
      },
      "required": [
        "BuildableConstructedGlobalDelegate",
        "mBuildableInstancesActor",
        "mBuildableMeshInstances",
        "mBuildables",
        "mColorSlotsPrimary",
        "mColorSlotsSecondary",
        "mColoredInstances",
        "mConveyorAttachments",
        "mDefaultFactoryMaterial",
        "mDistanceBasedTickRate",
        "mDistanceConsideredClose",
        "mFactoryColoredMaterialMap",
        "mFactoryOptimizationEnabled",
        "mFactoryTickFunction",
        "mMaxFactoryTickRate",
        "mMaxTickSubsteps",
        "mMinFactoryTickRate",
        "mNbPlayerExposedSlots",
        "mNumFactoriesNeededForCloseCheck",
        "mReplayEffecTimeDilation",
        "mReplayEffectTimerDefault",
        "mUseFixedFactoryTick"
      ]
    },
    "AFGFoundationSubsystem": {
      "type": "object",
      "properties": {
        "mBuildings": {
          "$ref": "#/definitions/Map<number,FBuilding>",
          "description": "All the buildings in the game, map with foundation ID and the building struct."
        }
      },
      "required": [
        "mBuildings"
      ]
    },
    "AFGAudioVolumeSubsystem": {
      "type": "object"
    },
    "AFGFoliageRemovalSubsystem": {
      "type": "object"
    },
    "AFGCharacterBase": {
      "type": "object",
      "properties": {
        "mFeetNames": {
          "description": "When receiving FootDown on index 2, then we will trace from mFeetNames[2] socket for ground",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDefaultFootstepEffect": {
          "$ref": "#/definitions/FFootstepEffect",
          "description": "Default effects to play when a foot hits the ground when the material doesn't exist in mFootstepEffects"
        },
        "mFootstepEffect": {
          "description": "Effects to play when a foot hits the ground",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FFootstepEffectSurface"
          }
        },
        "mFootstepAudioEvents": {
          "description": "Audio event to play (where index in array is the feet index passed from AnimNotify_FootDown)",
          "type": "array",
          "items": {}
        },
        "mMaxFootstepParticleSpawnDistance": {
          "description": "Maximum distance we want to play footstep particles at",
          "type": "number"
        },
        "mMaxFootstepDecalSpawnDistance": {
          "description": "Maximum distance we want to spawn footsteps decals at",
          "type": "number"
        },
        "mFootstepDecalSize": {
          "description": "Size of footstep decals",
          "type": "array",
          "items": {
            "$ref": "#/definitions/Vector"
          }
        },
        "mFootstepDecalLifetime": {
          "description": "Lifetime of footstep decals",
          "type": "number"
        },
        "mHealthComponent": {
          "$ref": "#/definitions/UFGHealthComponent",
          "description": "Keeps track of our current health"
        },
        "mFallDamageCurve": {
          "description": "How much damage to take falling with a given velocity"
        },
        "mFallDamageCurveOverride": {
          "description": "Overrides the default fall damage curve, utilized by Equipment"
        },
        "mFallDamageDamageType": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMaxDeathStayTime": {
          "description": "The maximum time after death (in seconds) the pawn will stay in the world, so it will be removed even if it's in sight after this time",
          "type": "number"
        },
        "mDeathRemoveCheckTime": {
          "description": "How often will we check if the pawn is in sight of any player",
          "type": "number"
        },
        "mEnemyTargetDesirability": {
          "description": "Multiplier for targeting desirability",
          "type": "number"
        },
        "mTakeDamageSound": {
          "description": "Sound played when pawn takes damage"
        },
        "mDeathSound": {
          "description": "Sound played when pawn dies"
        },
        "mLandEvent": {
          "description": "Event posted when landing"
        },
        "mTakeDamageParticle": {
          "description": "Particle for when pawn takes damage"
        },
        "mMinVehiclePushVelocityForRagdoll": {
          "description": "Min push velocity required to start ragdoll",
          "type": "number"
        },
        "mTimeToGetUpFromRagdoll": {
          "description": "time in seconds until character gets up from ragdoll if alive",
          "type": "number"
        },
        "mMaxDistanceMovedToGetUp": {
          "description": "the furthest distance we can move during ragdoll before we are considered still enough to stand up from ragdoll",
          "type": "number"
        },
        "mIsRagdolled": {
          "description": "true if ragdolled",
          "type": "boolean"
        },
        "mRagdollMeshLoc": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshVelocity": {
          "$ref": "#/definitions/Vector"
        },
        "mRagdollMeshLocBoneName": {
          "description": "Name of the bone we take mesh location from",
          "type": "string"
        },
        "mRagdollMeshPhysicsBoneName": {
          "description": "Name of the bone we take physics velocity from",
          "type": "string"
        },
        "mSyncBodyMaxDistance": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mApplyDamageMomentum": {
          "description": "Should the auto momentum be applied when taking damage?",
          "type": "boolean"
        },
        "mIgnoredDamageTypes": {
          "description": "Damage types that this character is immune to",
          "type": "array",
          "items": {
            "type": "object",
            "properties": {
              "package": {
                "type": "string"
              },
              "name": {
                "type": "string"
              }
            },
            "required": [
              "name",
              "package"
            ]
          }
        },
        "mWeakspotMultiplier": {
          "description": "How much more damage should be dealt when taking a weakspot hit",
          "type": "number"
        },
        "mWeakspotBoneNames": {
          "description": "Bone names that result in a weakspot hit",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mNormalDamageMultiplier": {
          "description": "Multiplier for this creature and normal damage taken",
          "type": "number"
        },
        "mIsPossessed": {
          "description": "Used to let client know when a pawn gets possessed/unpossessed",
          "type": "boolean"
        }
      },
      "required": [
        "mApplyDamageMomentum",
        "mDeathRemoveCheckTime",
        "mDeathSound",
        "mDefaultFootstepEffect",
        "mEnemyTargetDesirability",
        "mFallDamageCurve",
        "mFallDamageCurveOverride",
        "mFallDamageDamageType",
        "mFeetNames",
        "mFootstepAudioEvents",
        "mFootstepDecalLifetime",
        "mFootstepDecalSize",
        "mFootstepEffect",
        "mHealthComponent",
        "mIgnoredDamageTypes",
        "mIsPossessed",
        "mIsRagdolled",
        "mLandEvent",
        "mMaxDeathStayTime",
        "mMaxDistanceMovedToGetUp",
        "mMaxFootstepDecalSpawnDistance",
        "mMaxFootstepParticleSpawnDistance",
        "mMinVehiclePushVelocityForRagdoll",
        "mNormalDamageMultiplier",
        "mRagdollMeshLoc",
        "mRagdollMeshLocBoneName",
        "mRagdollMeshPhysicsBoneName",
        "mRagdollMeshVelocity",
        "mSyncBodyMaxDistance",
        "mTakeDamageParticle",
        "mTakeDamageSound",
        "mTimeToGetUpFromRagdoll",
        "mWeakspotBoneNames",
        "mWeakspotMultiplier"
      ]
    },
    "FItemView": {
      "type": "object",
      "properties": {
        "Distance": {
          "description": "The distance to the object when creating it's view",
          "type": "number"
        },
        "FocalOffset": {
          "$ref": "#/definitions/Vector",
          "description": "Where should the camera focus offsetted on the mesh"
        },
        "CameraPitch": {
          "description": "How much \"down or up\" the camera should be angeled (in degrees) when crating the view",
          "type": "number"
        }
      },
      "required": [
        "CameraPitch",
        "Distance",
        "FocalOffset"
      ]
    },
    "FFactoryClearanceData": {
      "type": "object",
      "properties": {
        "Factory": {
          "$ref": "#/definitions/AFGBuildableFactory"
        },
        "ClearanceComponent": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mConnectionComponents": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FConnectionRepresentation"
          }
        }
      },
      "required": [
        "ClearanceComponent",
        "Factory",
        "mConnectionComponents"
      ]
    },
    "AFGBuildableFactory": {
      "type": "object",
      "properties": {
        "mPowerConsumption": {
          "description": "Power consumption of this factory.",
          "type": "number"
        },
        "mPowerConsumptionExponent": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPowerInfoClass": {
          "description": "Class to use for the power simulation on this factory, this is only used if the building has any FGPowerConnectionComponent attached.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mPowerInfo": {
          "$ref": "#/definitions/UFGPowerInfoComponent",
          "description": "Power simulation info"
        },
        "mOnHasPowerChanged": {
          "description": "So that you can listen for when power has changed"
        },
        "mOnHasProductionChanged": {
          "description": "So that you can listen for when production has changed"
        },
        "mMinimumProducingTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMinimumStoppedTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mTimeSinceStartStopProducing": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mNumCyclesForProductivity": {
          "description": "How many cycles back do we base the productivity on",
          "type": "number"
        },
        "mCanChangePotential": {
          "description": "Set this to true if we want this building to be able to change the production rate potential with the \"Slider of Potential\"",
          "type": "boolean"
        },
        "mCurrentPotential": {
          "description": "This is the current potential (overclock, overcharge) of this factory [0..N]",
          "type": "number"
        },
        "mPendingPotential": {
          "description": "When ever a production cycle is completed we set the current potential to this value",
          "type": "number"
        },
        "mMinPotential": {
          "description": "You can never set the potential to less than this when playing",
          "type": "number"
        },
        "mMaxPotential": {
          "description": "You can never set the potential to more than this when playing",
          "type": "number"
        },
        "mMaxPotentialIncreasePerCrystal": {
          "description": "When the player adds another crystal in the inventory we unlock even more potential",
          "type": "number"
        },
        "mFluidStackSizeDefault": {
          "$ref": "#/definitions/EStackSize",
          "description": "Item stack size Enum to use as base for how much fluid a Liquid / Gas Item descriptor can be stored on an index in an inventory"
        },
        "mFluidStackSizeMultiplier": {
          "description": "Scalar for multiplying the default Stack Size for Fluid Inventory Slots ( 1 is default. 2 == 2\n  FluidStackSize )",
          "type": "number"
        },
        "mIsProductionPaused": {
          "description": "The player is able to toggle if production should be paused or not",
          "type": "boolean"
        },
        "mReplicationDetailActor": {
          "$ref": "#/definitions/AFGReplicationDetailActor"
        },
        "OnReplicationDetailActorCreatedEvent": {
          "description": "Event for when ReplicationDetailActors are created. Will only be dispatched if this buildable inherits from the ReplicationDetailActorOwnerInterface."
        },
        "mInventoryPotential": {
          "$ref": "#/definitions/UFGInventoryComponent",
          "description": "The input we place a crystal in to unlock the potential"
        },
        "mSignificanceBias": {
          "description": "A bias to the significance value",
          "type": "number"
        },
        "mEffectUpdateInterval": {
          "description": "How often effect update should update",
          "type": "number"
        },
        "mCurrentProductivity": {
          "description": "A replicated compressed version of the productivity",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Are we producing? Do not set this manually, some delegates and other stuff might not get triggered then.",
          "type": "number"
        },
        "mHasPower": {
          "description": "If building has power, for more details about the circuitry see mPowerInfo.",
          "type": "number"
        },
        "mAddToSignificanceManager": {
          "description": "Indicates if the factory should be handled by significance manager",
          "type": "number"
        },
        "mSignificanceRange": {
          "description": "The range to keep the factory in significance",
          "type": "number"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "OnReplicationDetailActorCreatedEvent",
        "mAddToSignificanceManager",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mCanChangePotential",
        "mColorSlot",
        "mCurrentPotential",
        "mCurrentProductivity",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mEffectUpdateInterval",
        "mFactoryTickFunction",
        "mFluidStackSizeDefault",
        "mFluidStackSizeMultiplier",
        "mForceNetUpdateOnRegisterPlayer",
        "mHasPower",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mInventoryPotential",
        "mIsProducing",
        "mIsProductionPaused",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMaxPotential",
        "mMaxPotentialIncreasePerCrystal",
        "mMinPotential",
        "mMinimumProducingTime",
        "mMinimumStoppedTime",
        "mNetConstructionID",
        "mNumCyclesForProductivity",
        "mOnHasPowerChanged",
        "mOnHasProductionChanged",
        "mPendingPotential",
        "mPowerConsumption",
        "mPowerConsumptionExponent",
        "mPowerInfo",
        "mPowerInfoClass",
        "mPrimaryColor",
        "mReplicationDetailActor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSignificanceBias",
        "mSignificanceRange",
        "mSkipBuildEffect",
        "mTimeSinceStartStopProducing"
      ]
    },
    "FConnectionRepresentation": {
      "type": "object",
      "properties": {
        "mConnectionComponent": {
          "$ref": "#/definitions/UFGConnectionComponent"
        },
        "mConnectionRepresentation": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "mConnectionComponent",
        "mConnectionRepresentation"
      ]
    },
    "UFGConnectionComponent": {
      "type": "object"
    },
    "FDismantleRefunds": {
      "type": "object",
      "properties": {
        "NumPendingActors": {
          "description": "An 32-bit unsigned integer.",
          "type": "number"
        },
        "PeekDismantleRefund": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/FInventoryStack"
          }
        }
      },
      "required": [
        "NumPendingActors",
        "PeekDismantleRefund"
      ]
    },
    "AFGJetPack": {
      "type": "object",
      "properties": {
        "mJumpTimeStamp": {
          "description": "The duration we've held down thrust this flight, only resets when Landed",
          "type": "number"
        },
        "mIsThrusting": {
          "description": "If we are actually thrusting or not",
          "type": "boolean"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mIsThrusting",
        "mJumpTimeStamp",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "AFGParachute": {
      "type": "object",
      "properties": {
        "mTerminalVelocityZ": {
          "description": "The velocity we fall at using the parachute.",
          "type": "number"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mTerminalVelocityZ",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "AFGHookshot": {
      "type": "object",
      "properties": {
        "mMaxHookDistance": {
          "description": "How far we will trace to try and find something to attach to",
          "type": "number"
        },
        "mAccelRate": {
          "description": "How fast do we accellerate toward the grappled target.",
          "type": "number"
        },
        "mBrakeAccelRate": {
          "description": "Accel bonus added when we are moving away from the grappled target.",
          "type": "number"
        },
        "mHookshotAudio": {
          "description": "Component handling our hookshot sounds"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mAccelRate",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mBrakeAccelRate",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mHasPersistentOwner",
        "mHookshotAudio",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mMaxHookDistance",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "AFGJumpingStilts": {
      "type": "object",
      "properties": {
        "mFallDamageCurveOverride": {
          "description": "The UCurveFloat to use to override the default fall damage curve"
        },
        "mSprintSpeedFactor": {
          "description": "The factor by which the default sprint speed is multiplied while equipped",
          "type": "number"
        },
        "mJumpSpeedFactor": {
          "description": "The factor by which the default JumpZ is multiplied while equipped",
          "type": "number"
        },
        "mAttachmentClass": {
          "description": "This is the attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSecondaryAttachmentClass": {
          "description": "This is the secondary attachment for this class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipmentSlot": {
          "$ref": "#/definitions/EEquipmentSlot",
          "description": "To what slot is this limited to?"
        },
        "mSprintHeadBobShake": {
          "description": "Camera shake to play when sprinting",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mEquipSound": {
          "description": "Sound played when equipping"
        },
        "mUnequipSound": {
          "description": "Sound played when unequipping"
        },
        "mEquipmentWidget": {
          "description": "Class of widget to add when equipping this equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mChildEquipment": {
          "$ref": "#/definitions/AFGEquipmentChild",
          "description": "Holds a reference to the child equipment that may be spawned with this"
        },
        "m1PAnimClass": {
          "description": "The AnimBlueprint class to use for the 1p anim for our pawn, specifying none here means that the pawn default 1p anim will be used",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mAttachSocket": {
          "description": "If this equipment should attach to a socket, this is the socket.",
          "type": "string"
        },
        "mChildEquipmentClass": {
          "description": "The class (if any) to use to spawn a child equipment",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mCostToUse": {
          "description": "The cost of using this equipment",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemAmount"
          }
        },
        "mArmAnimation": {
          "$ref": "#/definitions/EArmEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_ARMS)"
        },
        "mBackAnimation": {
          "$ref": "#/definitions/EBackEquipment",
          "description": "Arms animation this should play on the when the equipment is equipped (only used if mEquipmentSlot == ES_BACK)"
        },
        "mHasPersistentOwner": {
          "description": "If the owner is persistent throughout the lifetime of this equipment",
          "type": "boolean"
        },
        "mAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is the attachment of this equipment"
        },
        "mSecondaryAttachment": {
          "$ref": "#/definitions/AFGEquipmentAttachment",
          "description": "This is a potential secondary attachment"
        },
        "mIdlePoseAnimation": {
          "description": "Idle animation to play when equipped. Can be null if we don't want to play any special animation"
        },
        "mIdlePoseAnimation3p": {
          "description": "Idle animation to play when equipped in 3p. Can be null if we don't want to play any special animation"
        },
        "mUseDefaultPrimaryFire": {
          "description": "Should we use the default primary fire implementation",
          "type": "boolean"
        }
      },
      "required": [
        "m1PAnimClass",
        "mArmAnimation",
        "mAttachSocket",
        "mAttachment",
        "mAttachmentClass",
        "mBackAnimation",
        "mChildEquipment",
        "mChildEquipmentClass",
        "mCostToUse",
        "mEquipSound",
        "mEquipmentSlot",
        "mEquipmentWidget",
        "mFallDamageCurveOverride",
        "mHasPersistentOwner",
        "mIdlePoseAnimation",
        "mIdlePoseAnimation3p",
        "mJumpSpeedFactor",
        "mSecondaryAttachment",
        "mSecondaryAttachmentClass",
        "mSprintHeadBobShake",
        "mSprintSpeedFactor",
        "mUnequipSound",
        "mUseDefaultPrimaryFire"
      ]
    },
    "UFGLadderComponent": {
      "type": "object",
      "properties": {
        "mClimbableLookAngle": {
          "description": "Climbable angle in degrees. The player must be looking and moving within this angle relative to the ladder to climb it.",
          "type": "number"
        },
        "mEndClimbingLookAngle": {
          "description": "Angle in degrees. If the player must be looking and moving within this angle relative to the ladder or else they will hop off.",
          "type": "number"
        },
        "mPotentialClimbers": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        }
      },
      "required": [
        "mClimbableLookAngle",
        "mEndClimbingLookAngle",
        "mPotentialClimbers"
      ]
    },
    "FPlayerPipeHyperData": {
      "type": "object",
      "properties": {
        "mTravelingPipeHyper": {
          "$ref": "#/definitions/AActor",
          "description": "The pipe we are currently traveling in"
        },
        "mMinPipeSpeed": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPipeGravityStrength": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPipeFriction": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPipeConstantAcceleration": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPipeCurveDamping": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPipeDirectionLast": {
          "$ref": "#/definitions/Vector",
          "description": "World space direction of pipe last frame."
        },
        "mPipeDirection": {
          "$ref": "#/definitions/Vector",
          "description": "World space direction of pipe in current location."
        },
        "mDistanceToEndOfPipe": {
          "description": "Distance to the end of the whole pipe chain, but maximum of 2000 (To save time on calculating it on update)",
          "type": "number"
        },
        "mCombinedLengthTillEndOfPipesINcludingCurrent": {
          "description": "maximum of 2000 (To save time on calculating it on update)",
          "type": "number"
        },
        "mMaxCurveDiffThisFrame": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mMaxCurveDiffSmooth": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mPipeTempMinSpeed": {
          "description": "used so we can reduce even further due to curves, but not have the pipes too slow in upwards slopes",
          "type": "number"
        },
        "mFulPipeEndPoint": {
          "$ref": "#/definitions/Vector",
          "description": "World space position of the end of the pipe chain.. Only guaranteed to be accurate if the end is within 2000 units."
        },
        "mFulPipeEndDir": {
          "$ref": "#/definitions/Vector",
          "description": "World space direction of the end of the pipe chain.. Only guaranteed to be accurate if the end is within 2000 units."
        }
      },
      "required": [
        "mCombinedLengthTillEndOfPipesINcludingCurrent",
        "mDistanceToEndOfPipe",
        "mFulPipeEndDir",
        "mFulPipeEndPoint",
        "mMaxCurveDiffSmooth",
        "mMaxCurveDiffThisFrame",
        "mMinPipeSpeed",
        "mPipeConstantAcceleration",
        "mPipeCurveDamping",
        "mPipeDirection",
        "mPipeDirectionLast",
        "mPipeFriction",
        "mPipeGravityStrength",
        "mPipeTempMinSpeed",
        "mTravelingPipeHyper"
      ]
    },
    "UFGCompassObjectWidget": {
      "type": "object",
      "properties": {
        "mTexture": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mText": {
          "description": "A localizable string.",
          "type": "string"
        },
        "mPositionOffset": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mClampPosition": {
          "type": "boolean"
        },
        "mShouldFadeInEdges": {
          "type": "boolean"
        },
        "mImage": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mCheckForBlockingInCompass": {
          "type": "boolean"
        },
        "mActorRepresentation": {
          "$ref": "#/definitions/UFGActorRepresentation"
        },
        "mStaticDirection": {
          "$ref": "#/definitions/Vector"
        },
        "mIsBlocking": {
          "type": "boolean"
        }
      },
      "required": [
        "mActorRepresentation",
        "mCheckForBlockingInCompass",
        "mClampPosition",
        "mImage",
        "mIsBlocking",
        "mPositionOffset",
        "mShouldFadeInEdges",
        "mStaticDirection",
        "mText",
        "mTexture"
      ]
    },
    "EPlayOnDamageEvent": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "EOverrideSetting": {
      "enum": [
        0,
        1
      ],
      "type": "number"
    },
    "Map<ESchematicCategory,packageReference<UFGSchematicCategory>>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "FDropPackage": {
      "description": "Describes a package of items you can get in a drop.",
      "type": "object",
      "properties": {
        "DropDisplayText": {
          "description": "Text showing up when finding the drop.",
          "type": "string"
        },
        "DropChance": {
          "description": "Chance in roulette selection to get the package.",
          "type": "number"
        },
        "Items": {
          "description": "Item contained in the package",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FItemDrop"
          }
        },
        "RequiredSchematic": {
          "description": "We can not find this package if we haven't purchased this schematic.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        }
      },
      "required": [
        "DropChance",
        "DropDisplayText",
        "Items",
        "RequiredSchematic"
      ]
    },
    "FItemDrop": {
      "type": "object",
      "properties": {
        "ItemClass": {
          "description": "Item class",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "NumItems": {
          "description": "Range of items you can get"
        }
      },
      "required": [
        "ItemClass",
        "NumItems"
      ]
    },
    "UFGOptionsValueController": {
      "type": "object",
      "properties": {
        "mOptionRowData": {
          "$ref": "#/definitions/FOptionRowData"
        },
        "mIsDynamicOption": {
          "type": "boolean"
        }
      },
      "required": [
        "mIsDynamicOption",
        "mOptionRowData"
      ]
    },
    "FOptionRowData": {
      "type": "object",
      "properties": {
        "OptionName": {
          "description": "A localizable string.",
          "type": "string"
        },
        "OptionType": {
          "$ref": "#/definitions/EOptionType"
        },
        "ConsoleVariable": {
          "type": "string"
        },
        "DefaultCheckBoxValue": {
          "type": "boolean"
        },
        "MinValue": {
          "description": "A floating point number.",
          "type": "number"
        },
        "MaxValue": {
          "description": "A floating point number.",
          "type": "number"
        },
        "MinDisplayValue": {
          "description": "A floating point number.",
          "type": "number"
        },
        "MaxDisplayValue": {
          "description": "A floating point number.",
          "type": "number"
        },
        "MaxFractionalDigits": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "ShowZeroAsOff": {
          "type": "boolean"
        },
        "DefaultSliderValue": {
          "description": "A floating point number.",
          "type": "number"
        },
        "IntegerSelectionValues": {
          "$ref": "#/definitions/Map<string,number>"
        },
        "FloatSelectionValues": {
          "$ref": "#/definitions/Map<string,number>"
        },
        "DefaultSelectionValue": {
          "type": "string"
        },
        "UpdateInstantly": {
          "type": "boolean"
        },
        "RequireRestart": {
          "type": "boolean"
        },
        "Tooltip": {
          "description": "A localizable string.",
          "type": "string"
        }
      },
      "required": [
        "ConsoleVariable",
        "DefaultCheckBoxValue",
        "DefaultSelectionValue",
        "DefaultSliderValue",
        "FloatSelectionValues",
        "IntegerSelectionValues",
        "MaxDisplayValue",
        "MaxFractionalDigits",
        "MaxValue",
        "MinDisplayValue",
        "MinValue",
        "OptionName",
        "OptionType",
        "RequireRestart",
        "ShowZeroAsOff",
        "Tooltip",
        "UpdateInstantly"
      ]
    },
    "EOptionType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "Map<string,number>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "EErrorResponse": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "FViscosityToPuddlePair": {
      "type": "object",
      "properties": {
        "Viscosity": {
          "description": "Viscosity for this entry",
          "type": "number"
        },
        "Puddle": {
          "description": "Required puddle amount before this fluid viscosity can be moved from a fluid box [ 0 , 1 ] normalized fill amount",
          "type": "number"
        }
      },
      "required": [
        "Puddle",
        "Viscosity"
      ]
    },
    "FAnimInstanceProxyFactory": {
      "type": "object",
      "properties": {
        "mDeltaTime": {
          "description": "saved DT",
          "type": "number"
        },
        "mProductionProgress": {
          "description": "saved production progress for the factory",
          "type": "number"
        },
        "mProductionCycleTime": {
          "description": "saved production cycle time for the factory",
          "type": "number"
        },
        "mAnimPlayRate": {
          "description": "Multiplier for play rate",
          "type": "number"
        },
        "mRampUpTime": {
          "description": "Time factory should spend ramping up",
          "type": "number"
        },
        "mTimeNotProducing": {
          "description": "Time factory should not produce stuff",
          "type": "number"
        },
        "mRampDownTime": {
          "description": "Time factory should spend ramping up",
          "type": "number"
        },
        "mLastProductionProgress": {
          "description": "Last frames production progress",
          "type": "number"
        },
        "mRecipePlayRate": {
          "description": "Play rate for recipe",
          "type": "number"
        },
        "mCycleTime": {
          "description": "Length of production cycle",
          "type": "number"
        },
        "mDefaultCycleTime": {
          "description": "Actual animation length",
          "type": "number"
        },
        "mStartFrame": {
          "description": "Frame to...start?...i dunno",
          "type": "number"
        },
        "mLoadPercentage": {
          "description": "From 0.0 - 1.0 Only valid for generators!",
          "type": "number"
        },
        "mHasFuel": {
          "description": "valid for generators!",
          "type": "boolean"
        },
        "mHasPower": {
          "description": "Factory has power",
          "type": "number"
        },
        "mIsProducing": {
          "description": "Factory is producing something",
          "type": "number"
        },
        "mIsActivated": {
          "description": "An 8-bit unsigned integer.",
          "type": "number"
        },
        "mCycleComplete": {
          "description": "A production cycle was completed",
          "type": "number"
        },
        "mUseRampUp": {
          "description": "If we should use the ramp up system",
          "type": "number"
        },
        "mIsGenerator": {
          "description": "Is the owning actor a generator",
          "type": "number"
        },
        "mIsFuelGeneratorOnline": {
          "description": "True if generator has power and is producing",
          "type": "number"
        }
      },
      "required": [
        "mAnimPlayRate",
        "mCycleComplete",
        "mCycleTime",
        "mDefaultCycleTime",
        "mDeltaTime",
        "mHasFuel",
        "mHasPower",
        "mIsActivated",
        "mIsFuelGeneratorOnline",
        "mIsGenerator",
        "mIsProducing",
        "mLastProductionProgress",
        "mLoadPercentage",
        "mProductionCycleTime",
        "mProductionProgress",
        "mRampDownTime",
        "mRampUpTime",
        "mRecipePlayRate",
        "mStartFrame",
        "mTimeNotProducing",
        "mUseRampUp"
      ]
    },
    "FItemDropWithChance": {
      "type": "object",
      "properties": {
        "DropChance": {
          "description": "A chance between 0->1, 1 means 100% drop chance",
          "type": "number"
        },
        "Drop": {
          "$ref": "#/definitions/FItemDrop",
          "description": "The drop to be given if we gain the item"
        }
      },
      "required": [
        "Drop",
        "DropChance"
      ]
    },
    "FFGEngineCommon": {
      "type": "object",
      "properties": {
        "Engine": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "CreatedWorlds": {
          "description": "The worlds created through IFGWorldCreationInterface",
          "type": "array",
          "items": {}
        },
        "HeightFogUpdater": {
          "$ref": "#/definitions/UFGAtmosphereUpdater",
          "description": "Height fog properties that's controlled from camera"
        }
      },
      "required": [
        "CreatedWorlds",
        "Engine",
        "HeightFogUpdater"
      ]
    },
    "UFGAtmosphereUpdater": {
      "type": "object",
      "properties": {
        "mActiveWorlds": {
          "description": "The worlds we want to affect",
          "type": "array",
          "items": {}
        }
      },
      "required": [
        "mActiveWorlds"
      ]
    },
    "UFGSaveSystem": {
      "type": "object",
      "properties": {
        "mMapRedirectors": {
          "description": "Redirects for the maps when someone renames a map",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FMapRedirector"
          }
        }
      },
      "required": [
        "mMapRedirectors"
      ]
    },
    "FMapRedirector": {
      "type": "object",
      "properties": {
        "OldMapName": {
          "description": "Old map name",
          "type": "string"
        },
        "NewMapName": {
          "description": "New map name",
          "type": "string"
        }
      },
      "required": [
        "NewMapName",
        "OldMapName"
      ]
    },
    "UFGErrorMessage": {
      "type": "object",
      "properties": {
        "mErrorMessage": {
          "description": "Localized error message that we can push",
          "type": "string"
        },
        "mErrorResponse": {
          "$ref": "#/definitions/EErrorResponse",
          "description": "Shows how this error should be handled"
        }
      },
      "required": [
        "mErrorMessage",
        "mErrorResponse"
      ]
    },
    "FOnJoinSessionData": {
      "type": "object",
      "properties": {
        "LocalPlayer": {
          "$ref": "#/definitions/UFGLocalPlayer",
          "description": "Player that want to join the session"
        }
      },
      "required": [
        "LocalPlayer"
      ]
    },
    "UFGLocalPlayer": {
      "type": "object",
      "properties": {
        "mOnLoginStateChanged": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mOnFriendsListUpdated": {
          "description": "Called when the friendslist has been updated (that is, a user is has added/removed you as a friend)"
        },
        "mOnCreateSessionStateChanged": {
          "description": "Called when the session state has changed when creating a online game"
        },
        "mOnFriendsPresenceUpdated": {
          "description": "Called a friends presence is updated"
        },
        "mOnInviteReceived": {
          "description": "Called a friends presence is updated"
        }
      },
      "required": [
        "mOnCreateSessionStateChanged",
        "mOnFriendsListUpdated",
        "mOnFriendsPresenceUpdated",
        "mOnInviteReceived",
        "mOnLoginStateChanged"
      ]
    },
    "FFGModPackage": {
      "type": "object",
      "properties": {
        "ModPath": {
          "type": "string"
        },
        "HasFGMods": {
          "type": "boolean"
        },
        "Author": {
          "type": "string"
        },
        "Version": {
          "type": "string"
        },
        "Description": {
          "type": "string"
        }
      },
      "required": [
        "Author",
        "Description",
        "HasFGMods",
        "ModPath",
        "Version"
      ]
    },
    "UFGMusicManager": {
      "type": "object",
      "properties": {
        "mUpdateInterval": {
          "description": "How often (in seconds) we want to check if we are close to a factory",
          "type": "number"
        },
        "mFactoryCloseDistance": {
          "description": "The distance that we considers a factory as close",
          "type": "number"
        },
        "mAkObject": {
          "description": "Object we post event on, set RTPC on etc."
        },
        "mMusicManagerClassName": {
          "description": "Music manager class name"
        }
      },
      "required": [
        "mAkObject",
        "mFactoryCloseDistance",
        "mMusicManagerClassName",
        "mUpdateInterval"
      ]
    },
    "FAudioVolumeMap": {
      "type": "object",
      "properties": {
        "Name": {
          "description": "Name of the RTPC that this maps to",
          "type": "string"
        },
        "Value": {
          "description": "The stored value of the RTPC",
          "type": "number"
        }
      },
      "required": [
        "Name",
        "Value"
      ]
    },
    "FFGKeyMapping": {
      "type": "object",
      "properties": {
        "ActionKeyMapping": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "AxisKeyMapping": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "IsAxisMapping": {
          "type": "boolean"
        }
      },
      "required": [
        "ActionKeyMapping",
        "AxisKeyMapping",
        "IsAxisMapping"
      ]
    },
    "Map<ECompassViewDistance,number>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "UFGMapWidget": {
      "type": "object",
      "properties": {
        "mFogOfWarTexture": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/Engine/Engine/UTexture2D/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMapActors": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGActorRepresentation"
          }
        },
        "mActorRepresentationManager": {
          "$ref": "#/definitions/AFGActorRepresentationManager"
        }
      },
      "required": [
        "mActorRepresentationManager",
        "mFogOfWarTexture",
        "mMapActors"
      ]
    },
    "FCachedMaterialArray": {
      "type": "object",
      "properties": {
        "MaterialInterfaces": {
          "type": "array",
          "items": {}
        },
        "MeshFNames": {
          "description": "Component FName for each material interface",
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "required": [
        "MaterialInterfaces",
        "MeshFNames"
      ]
    },
    "UFGWidgetSwitcher": {
      "type": "object",
      "properties": {
        "mFadeOutTime": {
          "description": "A floating point number.",
          "type": "number"
        },
        "mOnWidgetSet": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mOnFadoutDone": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mPendingNewWidget": {
          "description": "Pending widget that will be set when the animations is done"
        },
        "mEnteringWidget": {
          "$ref": "#/definitions/UFGMenuBase",
          "description": "Widget currently running it's entering animation"
        },
        "mExitingWidget": {
          "$ref": "#/definitions/UFGMenuBase",
          "description": "Widget currently running it's exiting animation"
        }
      },
      "required": [
        "mEnteringWidget",
        "mExitingWidget",
        "mFadeOutTime",
        "mOnFadoutDone",
        "mOnWidgetSet",
        "mPendingNewWidget"
      ]
    },
    "UFGMenuBase": {
      "type": "object",
      "properties": {
        "mCachedOwner": {
          "$ref": "#/definitions/UFGWidgetSwitcher",
          "description": "Cached switcher owning this widget"
        }
      },
      "required": [
        "mCachedOwner"
      ]
    },
    "Map<EOptionType,packageReference<UFGOptionsValueController>>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "FPowerCircuitStats": {
      "type": "object",
      "properties": {
        "StatIntervalTime": {
          "description": "The duration between each stat.",
          "type": "number"
        },
        "StatHistoryTime": {
          "description": "For how long do we keep the stats.",
          "type": "number"
        },
        "PowerProductionCapacity": {
          "description": "How much power can be produced.",
          "type": "number"
        },
        "PowerProduced": {
          "description": "How much power is produced.",
          "type": "number"
        },
        "PowerConsumed": {
          "description": "How much power is consumed.",
          "type": "number"
        },
        "Items": {
          "description": "All the points on the graph.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FPowerGraphPoint"
          }
        },
        "FirstIndex": {
          "description": "The index we count as the first index in our ring buffer",
          "type": "number"
        }
      },
      "required": [
        "FirstIndex",
        "Items",
        "PowerConsumed",
        "PowerProduced",
        "PowerProductionCapacity",
        "StatHistoryTime",
        "StatIntervalTime"
      ]
    },
    "FPowerGraphPoint": {
      "type": "object",
      "properties": {
        "Consumed": {
          "description": "Data for this point.",
          "type": "number"
        },
        "Produced": {
          "description": "A floating point number.",
          "type": "number"
        },
        "ProductionCapacity": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "Consumed",
        "Produced",
        "ProductionCapacity"
      ]
    },
    "UFGPowerCircuit": {
      "type": "object",
      "properties": {
        "mPowerProductionCapacity": {
          "description": "Total amount of energy that can be produced in the circuit. Used for stats.",
          "type": "number"
        },
        "mPowerProduced": {
          "description": "Total amount of energy produced in the circuit.",
          "type": "number"
        },
        "mPowerConsumed": {
          "description": "Total amount of energy consumed in the circuit.",
          "type": "number"
        },
        "mIsFuseTriggered": {
          "description": "true if the fuse was triggered.",
          "type": "boolean"
        },
        "mPowerStats": {
          "$ref": "#/definitions/FPowerCircuitStats",
          "description": "The power consumption/production over time. Used for feedback."
        },
        "mCircuitID": {
          "description": "The id used to identify this circuit.",
          "type": "number"
        },
        "mComponents": {
          "description": "List of all the components (nodes) in this circuit.",
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGCircuitConnectionComponent"
          }
        },
        "mNeedFullRebuild": {
          "description": "Do this circuit needs to be rebuilt, e.g. wires or components have been removed.",
          "type": "number"
        },
        "mHasChanged": {
          "description": "True if this circuit has changed.",
          "type": "number"
        },
        "mInteractingPlayers": {
          "description": "All players interacting with a building that's connected to this circuit",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        }
      },
      "required": [
        "mCircuitID",
        "mComponents",
        "mHasChanged",
        "mInteractingPlayers",
        "mIsFuseTriggered",
        "mNeedFullRebuild",
        "mPowerConsumed",
        "mPowerProduced",
        "mPowerProductionCapacity",
        "mPowerStats"
      ]
    },
    "Map<EResourcePurity,number>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "FRadiationVisualization": {
      "type": "object",
      "properties": {
        "Case": {
          "type": "string"
        },
        "ItemAmount": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "Decay": {
          "description": "A floating point number.",
          "type": "number"
        },
        "UnitMultiplier": {
          "description": "An 32-bit signed integer.",
          "type": "number"
        },
        "HighestIntensity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "HighestDamageInterval": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DistanceForHighestIntensity": {
          "description": "A floating point number.",
          "type": "number"
        },
        "DistanceForNoticableIntensity": {
          "description": "A floating point number.",
          "type": "number"
        }
      },
      "required": [
        "Case",
        "Decay",
        "DistanceForHighestIntensity",
        "DistanceForNoticableIntensity",
        "HighestDamageInterval",
        "HighestIntensity",
        "ItemAmount",
        "UnitMultiplier"
      ]
    },
    "FAnimInstanceProxyRailRoadVehicle": {
      "type": "object",
      "properties": {
        "mDeltaTime": {
          "description": "saved DT",
          "type": "number"
        },
        "mFrontBogieRotation": {
          "description": "Front Bogie Rotation"
        },
        "mBackBogieRotation": {
          "description": "Front Bogie Rotation"
        },
        "mWheelRotation": {
          "description": "Wheel Rotation"
        },
        "mFrontConnectorRotation": {
          "description": "Front Connector Rotation"
        },
        "mFrontConnectorTranslation": {
          "$ref": "#/definitions/Vector",
          "description": "Front Connector Translation"
        },
        "mBackConnectorRotation": {
          "description": "Back Connector Rotation"
        },
        "mBackConnectorTranslation": {
          "$ref": "#/definitions/Vector",
          "description": "Back Connector Translation"
        },
        "mTrackCurvature": {
          "description": "Track curvature"
        },
        "mForwardSpeed": {
          "description": "Forward speed",
          "type": "number"
        },
        "mTractiveForce": {
          "description": "Tractive force",
          "type": "number"
        },
        "mHandBrakeForce": {
          "description": "Hand break",
          "type": "number"
        },
        "mThrottle": {
          "description": "Throttle",
          "type": "number"
        },
        "mBrakeForce": {
          "description": "brake force",
          "type": "number"
        },
        "mHandBrakeForceSpeed": {
          "description": "hand brake force multiplied with forward speed and clamped within nice values",
          "type": "number"
        },
        "mHandBrakeGlow": {
          "description": "Glow value for when using handbrake on moving vehicle",
          "type": "number"
        },
        "mHandBrakeVfxSpawn": {
          "description": "Spawn rate of brake particles",
          "type": "number"
        },
        "mAGBrakePlayRate": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mIsMoving": {
          "description": "Is Moving",
          "type": "number"
        },
        "mIsUsingHandBrake": {
          "description": "is break boosting",
          "type": "number"
        },
        "mIsLocomotive": {
          "description": "Is Locomotive",
          "type": "number"
        },
        "mHasPower": {
          "description": "Has Power",
          "type": "number"
        },
        "mAGThrottleZero": {
          "description": "Is throttle value zero",
          "type": "number"
        },
        "mAGThrottlePositive": {
          "description": "Is throttle value positive",
          "type": "number"
        },
        "mAGStartToRunningTransition": {
          "description": "Phase when train starts moving",
          "type": "number"
        },
        "mAGHandBrakeTransition01": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mAGHandBrakeTransition02": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mAGBrakeForcePositive": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mAGBrakeToRunningTransition": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mAGHandBrakeReset01": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mAGHandBrakeReset02": {
          "description": "Bigge values, I dunno",
          "type": "number"
        },
        "mAGHandBrakeStop": {
          "description": "Bigge values, I dunno",
          "type": "number"
        }
      },
      "required": [
        "mAGBrakeForcePositive",
        "mAGBrakePlayRate",
        "mAGBrakeToRunningTransition",
        "mAGHandBrakeReset01",
        "mAGHandBrakeReset02",
        "mAGHandBrakeStop",
        "mAGHandBrakeTransition01",
        "mAGHandBrakeTransition02",
        "mAGStartToRunningTransition",
        "mAGThrottlePositive",
        "mAGThrottleZero",
        "mBackBogieRotation",
        "mBackConnectorRotation",
        "mBackConnectorTranslation",
        "mBrakeForce",
        "mDeltaTime",
        "mForwardSpeed",
        "mFrontBogieRotation",
        "mFrontConnectorRotation",
        "mFrontConnectorTranslation",
        "mHandBrakeForce",
        "mHandBrakeForceSpeed",
        "mHandBrakeGlow",
        "mHandBrakeVfxSpawn",
        "mHasPower",
        "mIsLocomotive",
        "mIsMoving",
        "mIsUsingHandBrake",
        "mThrottle",
        "mTrackCurvature",
        "mTractiveForce",
        "mWheelRotation"
      ]
    },
    "UFGReplicationGraphNode_ConditionallyAlwaysRelevant": {
      "type": "object"
    },
    "FConnectionAlwaysRelevant_NodePair": {
      "type": "object",
      "properties": {
        "NetConnection": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "Node": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "NetConnection",
        "Node"
      ]
    },
    "EIncludeInBuilds": {
      "description": "Where this schematic should be included. Cooker strips away builds that's marked for different build types",
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "UFGAvailabilityDependency": {
      "type": "object"
    },
    "UFGResearchTreeNode": {
      "type": "object"
    },
    "Map<number,EStackSize>": {
      "type": "object",
      "properties": {
        "size": {
          "type": "number"
        },
        "__@toStringTag": {
          "type": "string"
        }
      },
      "required": [
        "__@toStringTag",
        "size"
      ]
    },
    "FItemSettings": {
      "type": "object",
      "properties": {
        "ResourceClass": {
          "description": "The class (and it's subclasses) that we want to specify the resolution for",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Resolution": {
          "description": "The x and y resolution of the icon (must be power of 2), -1 means no icon",
          "type": "number"
        },
        "MasterMaterial": {
          "description": "Material that should be used for each icon, need to have a parameter named Texture"
        }
      },
      "required": [
        "MasterMaterial",
        "Resolution",
        "ResourceClass"
      ]
    },
    "ESchematicType": {
      "enum": [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8
      ],
      "type": "number"
    },
    "UFGUnlock": {
      "type": "object"
    },
    "ESchematicCategory": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "UFGSignElementDragDrop": {
      "type": "object"
    },
    "UFGSignElementDragWidget": {
      "type": "object",
      "properties": {
        "mElementReference": {
          "$ref": "#/definitions/UFGSignElementWidget",
          "description": "Hold a reference to the widget we are representing"
        },
        "mSizeBox": {
          "description": "/"
        },
        "mBackground": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        }
      },
      "required": [
        "mBackground",
        "mElementReference",
        "mSizeBox"
      ]
    },
    "UFGSignElementWidget": {
      "type": "object",
      "properties": {
        "mSelectionBorder": {
          "description": "Border widget to indicate object selection"
        },
        "mDragWidgetClass": {
          "description": "Specify the widget to virually represent being dragged",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mSignElementSettingsWidget": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDragElement": {
          "$ref": "#/definitions/UFGSignElementDragWidget",
          "description": "Reference to the sign element being dragged"
        },
        "mCanvasParent": {
          "$ref": "#/definitions/UFGSignCanvasWidget",
          "description": "Reference to the parent SignCanvasWidget"
        },
        "mElementData": {
          "$ref": "#/definitions/UFGSignElementData",
          "description": "Reference to the element data represented by this widget"
        },
        "mPanelSlot": {
          "description": "Keep a reference to the panel slot this is stored in the FGSignCanvasWidget"
        }
      },
      "required": [
        "mCanvasParent",
        "mDragElement",
        "mDragWidgetClass",
        "mElementData",
        "mPanelSlot",
        "mSelectionBorder",
        "mSignElementSettingsWidget"
      ]
    },
    "UFGSignCanvasWidget": {
      "type": "object",
      "properties": {
        "mCanvasSizeBox": {
          "description": "Size Box that holds our Canvas, its size is set to absolute and the canvas fills that space"
        },
        "mCanvasPanel": {
          "description": "The canvas panel where actual sign elements will be added"
        },
        "mSelectionBrushTemplate": {
          "description": "https://docs.unrealengine.com/en-US/API/Runtime/SlateCore/Styling/FSlateBrush/index.html",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDefaultElementClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mTextElementClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mIconElementClass": {
          "description": "Reference to a class.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDragAndDrop": {
          "$ref": "#/definitions/UFGSignElementDragDrop"
        },
        "mDragElement": {
          "$ref": "#/definitions/UFGSignElementDragWidget"
        },
        "mElementWidgets": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/UFGSignElementWidget"
          }
        },
        "mSelectedElement": {
          "$ref": "#/definitions/UFGSignElementWidget",
          "description": "Reference to the currently selected widget"
        },
        "mInteractWidget": {
          "$ref": "#/definitions/UFGSignInteractWidget"
        }
      },
      "required": [
        "mCanvasPanel",
        "mCanvasSizeBox",
        "mDefaultElementClass",
        "mDragAndDrop",
        "mDragElement",
        "mElementWidgets",
        "mIconElementClass",
        "mInteractWidget",
        "mSelectedElement",
        "mSelectionBrushTemplate",
        "mTextElementClass"
      ]
    },
    "UFGSignInteractWidget": {
      "type": "object",
      "properties": {
        "mElementListWidget": {
          "$ref": "#/definitions/UFGSignElementListWidget",
          "description": "Widget reference that holds a list of all active elements and allows for creation / deletion of sign elements"
        },
        "mElementSettingsContainer": {
          "description": "Container (Canvas Panel) to add the appropriate settings widget to when an element is selected"
        },
        "mCanvasSizeBox": {
          "description": "Size box from where we determine the drawing canvases maximum size constraints"
        },
        "mCanvasContainer": {
          "description": "Panel to hold the FGSignCanvas ( dimensions will never be skewed )"
        },
        "mSignCanvasWidget": {
          "$ref": "#/definitions/UFGSignCanvasWidget",
          "description": "Custom widget that holds the panel for which actual sign elements are added"
        },
        "mElementSettingsWidget": {
          "$ref": "#/definitions/UFGSignElementSettingsWidget",
          "description": "Created at runtime, can be null if no element is selected"
        },
        "mSignData": {
          "$ref": "#/definitions/FSignData"
        },
        "mUseKeyboard": {
          "description": "If we should take the keyboard input from the player. The player won't be able to move around.",
          "type": "boolean"
        },
        "mUseMouse": {
          "description": "If we should take the mouse input from the player. The player won't be able to look around.",
          "type": "boolean"
        },
        "mCaptureInput": {
          "description": "Decides if we should share input with game or capture it completely",
          "type": "boolean"
        },
        "mRestoreFocusWhenLost": {
          "description": "Decides if the widget should restore focus when it looses it. (e.g. when the user clicks outside of the widget)",
          "type": "boolean"
        },
        "mInputToPassThrough": {
          "description": "There need to be a clear hierarchy of how input is handled and what to pass and not pass and if the default is pass all or pass none.",
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "mDesiredHorizontalAlignment": {
          "description": "Our desired horizontal alignment"
        },
        "mDesiredVerticalAlignment": {
          "description": "Our desired vetical alignment"
        },
        "mDesiredAlignmentSize": {
          "description": "Our desired horizontal size"
        },
        "mInteractObject": {
          "$ref": "#/definitions/UObject",
          "description": "Object that we interacted with in order to show this widget ( can be nullPeter )"
        },
        "mDefaultFocusWidgetClass": {
          "description": "Class of the default widget we want to give focus to",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mUseGamepadCursor": {
          "description": "Should gamepad act as cursor when using this widget?",
          "type": "boolean"
        },
        "mCustomTickRate": {
          "description": "The rate for the timer that triggers the custom tick. If <= 0.f no timer will be started",
          "type": "number"
        },
        "mCallCustomTickOnConstruct": {
          "description": "True if the custom tick event be called on construct. If <= 0.f no event will be triggered",
          "type": "boolean"
        },
        "mDefaultFocusWidget": {
          "description": "Used to give focus to an object when nothing else has focus"
        },
        "mSupportsStacking": {
          "description": "Does this widget support stacking widgets on top?",
          "type": "boolean"
        }
      },
      "required": [
        "mCallCustomTickOnConstruct",
        "mCanvasContainer",
        "mCanvasSizeBox",
        "mCaptureInput",
        "mCustomTickRate",
        "mDefaultFocusWidget",
        "mDefaultFocusWidgetClass",
        "mDesiredAlignmentSize",
        "mDesiredHorizontalAlignment",
        "mDesiredVerticalAlignment",
        "mElementListWidget",
        "mElementSettingsContainer",
        "mElementSettingsWidget",
        "mInputToPassThrough",
        "mInteractObject",
        "mRestoreFocusWhenLost",
        "mSignCanvasWidget",
        "mSignData",
        "mSupportsStacking",
        "mUseGamepadCursor",
        "mUseKeyboard",
        "mUseMouse"
      ]
    },
    "UFGSignElementListWidget": {
      "type": "object",
      "properties": {
        "mAddTextElementButton": {
          "description": "Button to add a new Text Element"
        },
        "mAddIconElementButton": {
          "description": "Button to add a new Icon Element"
        },
        "mElementListBox": {
          "description": "The verticle box where added elements will be listed"
        }
      },
      "required": [
        "mAddIconElementButton",
        "mAddTextElementButton",
        "mElementListBox"
      ]
    },
    "UFGSignElementSettingsWidget": {
      "type": "object",
      "properties": {
        "mElementWidget": {
          "$ref": "#/definitions/UFGSignElementWidget"
        }
      },
      "required": [
        "mElementWidget"
      ]
    },
    "AFGBuildableConveyorBase": {
      "type": "object",
      "properties": {
        "PresistentConveyorPackagingDataObject": {
          "$ref": "#/definitions/UPresistentConveyorPackagingData",
          "description": "held here, but created by conveyors when replicated, as we don't want to create it unless it's used."
        },
        "mSpeed": {
          "description": "Speed of this conveyor.",
          "type": "number"
        },
        "mItems": {
          "$ref": "#/definitions/FConveyorBeltItems",
          "description": "All the locally simulated resource offsets on the conveyor belt."
        },
        "mConnection0": {
          "description": "First connection on conveyor belt, Connections are always in the same order, mConnection0 is the input, mConnection1 is the output."
        },
        "mConnection1": {
          "description": "Second connection on conveyor belt"
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "PresistentConveyorPackagingDataObject",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mItems",
        "mMaterialNameToInstanceManager",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSpeed"
      ]
    },
    "AFGBuildablePipeBase": {
      "type": "object",
      "properties": {
        "mMesh": {
          "description": "Mesh to use for his conveyor.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mMeshLength": {
          "description": "Length of the mesh to use for this conveyor.",
          "type": "number"
        },
        "mConnection0": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mConnection1": {
          "description": "An unknown type (likely an Unreal Engine or plugin type)."
        },
        "mSplineData": {
          "description": "Compact representation of mSplineComponent, used for replication and save game",
          "type": "array",
          "items": {}
        },
        "mSplineComponent": {
          "description": "The spline component for this splined factory."
        },
        "mInstancedSplineComponent": {
          "description": "The spline meshes for this train track."
        },
        "mHologramClass": {
          "description": "The hologram class to use for constructing this object.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDisplayName": {
          "description": "The human readable display name of this object.",
          "type": "string"
        },
        "mDescription": {
          "description": "The human readable description of this object.",
          "type": "string"
        },
        "MaxRenderDistance": {
          "description": "Max draw distance, inactive when < 0",
          "type": "number"
        },
        "mHighlightVector": {
          "$ref": "#/definitions/Vector",
          "description": "Vector used to determine highlight effects location"
        },
        "mFactoryTickFunction": {
          "$ref": "#/definitions/FFactoryTickFunction",
          "description": "Controls if we should receive Factory_Tick and how frequent."
        },
        "mMaterialNameToInstanceManager": {
          "$ref": "#/definitions/Map<string,UFGFactoryMaterialInstanceManager>",
          "description": "Map of colorable mesh materials to their respective colored factory material instance manager"
        },
        "mPrimaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mSecondaryColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The primary color of this buildable"
        },
        "mColorSlot": {
          "description": "The color slot of this buildable",
          "type": "number"
        },
        "mBuildEffectTemplate": {
          "description": "What build effect to use when building this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mDismantleEffectTemplate": {
          "description": "What build effect to use when dismantling this building",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildEffectInstignator": {
          "$ref": "#/definitions/AActor",
          "description": "Used to sync and start build effect on buildings when created, but not after creation. Set's to true when creating a building, turns off in the construction effect finish play.\n[DavalliusA:Mon/01-04-2019] this is sett to null in default. If it's non null, we expect the build effects need to play."
        },
        "mDismantleEffectClassName": {
          "description": "Name read from config"
        },
        "mBuildEffectClassName": {
          "description": "Name read from config"
        },
        "mSkipBuildEffect": {
          "description": "Skip the build effect.",
          "type": "boolean"
        },
        "mBuildEffectSpeed": {
          "description": "Build effect speed, a constant speed (distance over time) that the build effect should have, so bigger buildings take longer",
          "type": "number"
        },
        "mForceNetUpdateOnRegisterPlayer": {
          "description": "Whether or not this building should use ForceNetUpdate() when a player registers/unregisters from it.",
          "type": "boolean"
        },
        "mHighlightParticleClassName": {
          "description": "Name read from config"
        },
        "mHighlightParticleSystemTemplate": {
          "description": "Particle system component"
        },
        "mHighlightParticleSystemComponent": {
          "description": "Particle system component"
        },
        "mDidFirstTimeUse": {
          "description": "If this building should show highlight before first use, save when it has been shown",
          "type": "boolean"
        },
        "mShouldShowHighlight": {
          "description": "Should we show highlight when building this building",
          "type": "boolean"
        },
        "mAllowCleranceSeparationEvenIfStackedOn": {
          "type": "boolean"
        },
        "mCameraDistanceSq": {
          "description": "Squared distance to closest camera",
          "type": "number"
        },
        "mBuildingID": {
          "description": "The building ID this belongs to.",
          "type": "number"
        },
        "mInteractWidgetClass": {
          "description": "The widget that will present our UI.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mInteractingPlayers": {
          "description": "Players interacting with this building",
          "type": "array",
          "items": {
            "$ref": "#/definitions/AFGCharacterPlayer"
          }
        },
        "mIsUseable": {
          "description": "If you can interact with this buildable.",
          "type": "number"
        },
        "mNetConstructionID": {
          "$ref": "#/definitions/FNetConstructionID",
          "description": "ID given from server when constructed. Has not been assigned a value by server if 0."
        },
        "mBuiltWithRecipe": {
          "description": "Recipe this building was built with, e.g. used for refunds and stats.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "mBuildTimeStamp": {
          "description": "Time when this building was built",
          "type": "number"
        },
        "mCachedShapeComponent": {
          "description": "Caching the shape component once we have gotten it"
        }
      },
      "required": [
        "MaxRenderDistance",
        "mAllowCleranceSeparationEvenIfStackedOn",
        "mBuildEffectClassName",
        "mBuildEffectInstignator",
        "mBuildEffectSpeed",
        "mBuildEffectTemplate",
        "mBuildTimeStamp",
        "mBuildingID",
        "mBuiltWithRecipe",
        "mCachedShapeComponent",
        "mCameraDistanceSq",
        "mColorSlot",
        "mConnection0",
        "mConnection1",
        "mDescription",
        "mDidFirstTimeUse",
        "mDismantleEffectClassName",
        "mDismantleEffectTemplate",
        "mDisplayName",
        "mFactoryTickFunction",
        "mForceNetUpdateOnRegisterPlayer",
        "mHighlightParticleClassName",
        "mHighlightParticleSystemComponent",
        "mHighlightParticleSystemTemplate",
        "mHighlightVector",
        "mHologramClass",
        "mInstancedSplineComponent",
        "mInteractWidgetClass",
        "mInteractingPlayers",
        "mIsUseable",
        "mMaterialNameToInstanceManager",
        "mMesh",
        "mMeshLength",
        "mNetConstructionID",
        "mPrimaryColor",
        "mSecondaryColor",
        "mShouldShowHighlight",
        "mSkipBuildEffect",
        "mSplineComponent",
        "mSplineData"
      ]
    },
    "FSignColorData": {
      "type": "object",
      "properties": {
        "SignColor": {
          "$ref": "#/definitions/LinearColor",
          "description": "The static mesh that will be rendered on the actual sign in the world"
        },
        "ColorName": {
          "description": "A text name to display with the icon inside of menus",
          "type": "string"
        },
        "TextMaterialInstance": {
          "description": "The TEXT material instance is created at runtime and stored here when it is needed"
        },
        "IconMaterialInstance": {
          "description": "The ICON material instance is created at runtime and stored here when it is needed"
        },
        "BackgroundMaterialInstance": {
          "description": "The BACKGROUND material instance is created at runtime and stored here when it is needed"
        }
      },
      "required": [
        "BackgroundMaterialInstance",
        "ColorName",
        "IconMaterialInstance",
        "SignColor",
        "TextMaterialInstance"
      ]
    },
    "EHorizontalSignTextAlignment": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    },
    "FPawnImpactAudio": {
      "type": "object",
      "properties": {
        "MinImpactVelocity": {
          "description": "If we have at least this velocity (in Z) when entering the volume, we will post the specified event",
          "type": "number"
        },
        "ImpactEvent": {
          "description": "Event to post if the pawn has the specified velocity"
        }
      },
      "required": [
        "ImpactEvent",
        "MinImpactVelocity"
      ]
    },
    "FVehicleEngineData6W": {
      "type": "object",
      "properties": {
        "TorqueCurve": {
          "description": "Torque (Nm) at a given RPM"
        },
        "MaxRPM": {
          "description": "Maximum revolutions per minute of the engine",
          "type": "number"
        },
        "MOI": {
          "description": "Moment of inertia of the engine around the axis of rotation (Kgm^2).",
          "type": "number"
        },
        "DampingRateFullThrottle": {
          "description": "Damping rate of engine when full throttle is applied (Kgm^2/s)",
          "type": "number"
        },
        "DampingRateZeroThrottleClutchEngaged": {
          "description": "Damping rate of engine in at zero throttle when the clutch is engaged (Kgm^2/s)",
          "type": "number"
        },
        "DampingRateZeroThrottleClutchDisengaged": {
          "description": "Damping rate of engine in at zero throttle when the clutch is disengaged (in neutral gear) (Kgm^2/s)",
          "type": "number"
        }
      },
      "required": [
        "DampingRateFullThrottle",
        "DampingRateZeroThrottleClutchDisengaged",
        "DampingRateZeroThrottleClutchEngaged",
        "MOI",
        "MaxRPM",
        "TorqueCurve"
      ]
    },
    "FVehicleDifferential6WData": {
      "type": "object",
      "properties": {
        "DifferentialConfig": {
          "$ref": "#/definitions/FDifferentialSetup6W",
          "description": "Type of differential"
        }
      },
      "required": [
        "DifferentialConfig"
      ]
    },
    "FDifferentialSetup6W": {
      "description": "Described which axles are powered by the engine. True == Powered.",
      "type": "object",
      "properties": {
        "Front": {
          "type": "boolean"
        },
        "Mid": {
          "type": "boolean"
        },
        "Rear": {
          "type": "boolean"
        }
      },
      "required": [
        "Front",
        "Mid",
        "Rear"
      ]
    },
    "FVehicleTransmissionData6W": {
      "type": "object",
      "properties": {
        "bUseGearAutoBox": {
          "description": "Whether to use automatic transmission",
          "type": "boolean"
        },
        "GearSwitchTime": {
          "description": "Time it takes to switch gears (seconds)",
          "type": "number"
        },
        "GearAutoBoxLatency": {
          "description": "Minimum time it takes the automatic transmission to initiate a gear change (seconds)",
          "type": "number"
        },
        "FinalRatio": {
          "description": "The final gear ratio multiplies the transmission gear ratios.",
          "type": "number"
        },
        "ForwardGears": {
          "description": "Forward gear ratios (up to 30)",
          "type": "array",
          "items": {
            "$ref": "#/definitions/FVehicleGearData6W"
          }
        },
        "ReverseGearRatio": {
          "description": "Reverse gear ratio",
          "type": "number"
        },
        "NeutralGearUpRatio": {
          "description": "Value of engineRevs/maxEngineRevs that is high enough to increment gear",
          "type": "number"
        },
        "ClutchStrength": {
          "description": "Strength of clutch (Kgm^2/s)",
          "type": "number"
        }
      },
      "required": [
        "ClutchStrength",
        "FinalRatio",
        "ForwardGears",
        "GearAutoBoxLatency",
        "GearSwitchTime",
        "NeutralGearUpRatio",
        "ReverseGearRatio",
        "bUseGearAutoBox"
      ]
    },
    "FVehicleGearData6W": {
      "type": "object",
      "properties": {
        "Ratio": {
          "description": "Determines the amount of torque multiplication",
          "type": "number"
        },
        "DownRatio": {
          "description": "Value of engineRevs/maxEngineRevs that is low enough to gear down",
          "type": "number"
        },
        "UpRatio": {
          "description": "Value of engineRevs/maxEngineRevs that is high enough to gear up",
          "type": "number"
        }
      },
      "required": [
        "DownRatio",
        "Ratio",
        "UpRatio"
      ]
    },
    "ECachedNATType": {
      "enum": [
        0,
        1,
        2,
        3
      ],
      "type": "number"
    },
    "FMaterialFlowConnection": {
      "type": "object",
      "properties": {
        "Descriptor": {
          "description": "Details about the material flow in this step.",
          "type": "object",
          "properties": {
            "package": {
              "type": "string"
            },
            "name": {
              "type": "string"
            }
          },
          "required": [
            "name",
            "package"
          ]
        },
        "Count": {
          "description": "Base count. [items/cycle]",
          "type": "number"
        },
        "Flow": {
          "description": "Base flow. [items/second]",
          "type": "number"
        },
        "TotalCount": {
          "description": "Total count. [items/cycle]",
          "type": "number"
        },
        "TotalFlow": {
          "description": "Total flow. [items/second]",
          "type": "number"
        }
      },
      "required": [
        "Count",
        "Descriptor",
        "Flow",
        "TotalCount",
        "TotalFlow"
      ]
    },
    "EPopupId": {
      "enum": [
        0,
        1,
        2
      ],
      "type": "number"
    }
  },
  "$schema": "http://json-schema.org/draft-07/schema#"
}